[{"source": "gpt3.5", "name": "10", "file_name": "Exercise0.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n    // Define the size of the spaceship deck\n    private static final int WIDTH = 12;\n    private static final int HEIGHT = 8;\n\n    // Define the locations of the obstacles\n    private static final int[][] OBSTACLES = {\n            {6, 2, 6, 5},\n            {5, 5, 6, 5},\n            {5, 5, 5, 6},\n            {5, 6, 12, 6}\n    };\n\n    // Define the initial position of the maintenance droid\n    private int x = 11;\n    private int y = 7;\n\n    @Override\n    public String goTo(String goCommandString) {\n        // Parse the command string\n        String[] parts = goCommandString.replaceAll(\"[\\\\[\\\\]]\", \"\").split(\",\");\n        String direction = parts[0];\n        int steps = Integer.parseInt(parts[1]);\n\n        // Move the maintenance droid in the specified direction\n        switch (direction) {\n            case \"no\":\n                y += steps;\n                break;\n            case \"ea\":\n                x += steps;\n                break;\n            case \"so\":\n                y -= steps;\n                break;\n            case \"we\":\n                x -= steps;\n                break;\n        }\n\n        // Check for collisions with obstacles or the spaceship deck boundary\n        for (int[] obstacle : OBSTACLES) {\n            if (x >= obstacle[0] && x <= obstacle[2] && y >= obstacle[1] && y <= obstacle[3]) {\n                // Collision detected, adjust the position of the droid\n                if (direction.equals(\"no\")) {\n                    y = obstacle[1] - 1;\n                } else if (direction.equals(\"ea\")) {\n                    x = obstacle[0] - 1;\n                } else if (direction.equals(\"so\")) {\n                    y = obstacle[3] + 1;\n                } else if (direction.equals(\"we\")) {\n                    x = obstacle[2] + 1;\n                }\n                break;\n            }\n        }\n\n        // Check if the maintenance droid has moved out of the spaceship deck boundary\n        if (x < 0) {\n            x = 0;\n        } else if (x >= WIDTH) {\n            x = WIDTH - 1;\n        }\n        if (y < 0) {\n            y = 0;\n        } else if (y >= HEIGHT) {\n            y = HEIGHT - 1;\n        }\n\n        // Return the current position of the maintenance droid\n        return \"(\" + x + \",\" + y + \")\";\n    }\n}\n"}, {"source": "gpt3.5", "name": "10", "file_name": "GoAble.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "gpt3.5", "name": "11", "file_name": "Exercise0.java", "style": "cc", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Exercise0 implements GoAble {\n\n    private static final int GRID_WIDTH = 12;\n    private static final int GRID_HEIGHT = 8;\n    private static final int[][] OBSTACLES = {{6, 2, 6, 5}, {5, 5, 6, 5}, {5, 5, 5, 6}, {5, 6, 12, 6}};\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    private int[] position = {11, 7};\n\n    public String goTo(String goCommandString) throws IllegalArgumentException {\n        int[] newPosition = Arrays.copyOf(position, position.length);\n        String[] goCommand = goCommandString.replaceAll(\"[^A-Za-z0-9]\", \"\").split(\"(?<=\\\\D)(?=\\\\d)|(?<=\\\\d)(?=\\\\D)\");\n\n        if (goCommand.length != 2) {\n            throw new IllegalArgumentException(\"Invalid command: \" + goCommandString);\n        }\n\n        int steps = Integer.parseInt(goCommand[1]);\n        int directionIndex = getDirectionIndex(goCommand[0]);\n\n        while (steps > 0) {\n            int[] nextPosition = Arrays.copyOf(newPosition, newPosition.length);\n            nextPosition[0] += DIRECTIONS[directionIndex][0];\n            nextPosition[1] += DIRECTIONS[directionIndex][1];\n\n            if (isOutOfBounds(nextPosition) || collidesWithObstacle(newPosition, nextPosition)) {\n                break;\n            }\n\n            newPosition = nextPosition;\n            steps--;\n        }\n\n        position = newPosition;\n        return \"(\" + position[0] + \",\" + position[1] + \")\";\n    }\n\n    private boolean isOutOfBounds(int[] position) {\n        return position[0] < 0 || position[0] >= GRID_WIDTH || position[1] < 0 || position[1] >= GRID_HEIGHT;\n    }\n\n    private boolean collidesWithObstacle(int[] currentPosition, int[] nextPosition) {\n        for (int[] obstacle : OBSTACLES) {\n            if (currentPosition[0] == nextPosition[0] && currentPosition[0] == obstacle[0]\n                    && obstacle[1] <= Math.max(currentPosition[1], nextPosition[1]) && obstacle[3] >= Math.min(currentPosition[1], nextPosition[1])) {\n                return true;\n            }\n            if (currentPosition[1] == nextPosition[1] && currentPosition[1] == obstacle[1]\n                    && obstacle[0] <= Math.max(currentPosition[0], nextPosition[0]) && obstacle[2] >= Math.min(currentPosition[0], nextPosition[0])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private int getDirectionIndex(String direction) throws IllegalArgumentException {\n        List<String> directions = Arrays.asList(\"no\", \"ea\", \"so\", \"we\");\n        int directionIndex = directions.indexOf(direction.toLowerCase());\n        if (directionIndex == -1) {\n            throw new IllegalArgumentException(\"Invalid direction: \" + direction);\n        }\n        return directionIndex;\n    }\n}\n"}, {"source": "gpt3.5", "name": "11", "file_name": "GoAble.java", "style": "cc", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "gpt3.5", "name": "12", "file_name": "Exercise0.java", "style": "cc", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n    private static final int WIDTH = 12;\n    private static final int HEIGHT = 8;\n    private static final int[][] OBSTACLES = {{6,2,6,5}, {5,5,6,5}, {5,5,5,6}, {5,6,12,6}};\n    private static final int[][] DIRECTIONS = {{0,1}, {1,0}, {0,-1}, {-1,0}}; // {dx, dy} for each direction\n    private int x;\n    private int y;\n\n    public Exercise0() {\n        this.x = 11;\n        this.y = 7;\n    }\n\n    public String goTo(String goCommandString) {\n        String[] commandParts = goCommandString.replaceAll(\"[\\\\[\\\\]]\", \"\").split(\",\");\n        int directionIndex = getDirectionIndex(commandParts[0]);\n        int steps = Integer.parseInt(commandParts[1]);\n\n        int dx = DIRECTIONS[directionIndex][0];\n        int dy = DIRECTIONS[directionIndex][1];\n\n        for (int i = 0; i < steps; i++) {\n            int newX = x + dx;\n            int newY = y + dy;\n            boolean obstacleHit = false;\n\n            // Check if new position hits an obstacle or boundary\n            for (int[] obstacle : OBSTACLES) {\n                if (dx == 0 && obstacle[0] <= newX && newX <= obstacle[2] && obstacle[1] <= y && y <= obstacle[3]) {\n                    newX = obstacle[0] - 1;\n                    obstacleHit = true;\n                } else if (dy == 0 && obstacle[1] <= newY && newY <= obstacle[3] && obstacle[0] <= x && x <= obstacle[2]) {\n                    newY = obstacle[1] - 1;\n                    obstacleHit = true;\n                }\n            }\n            if (newX < 0) newX = 0;\n            if (newX >= WIDTH) newX = WIDTH - 1;\n            if (newY < 0) newY = 0;\n            if (newY >= HEIGHT) newY = HEIGHT - 1;\n\n            if (obstacleHit) {\n                break; // Stop if obstacle hit\n            } else {\n                x = newX;\n                y = newY;\n            }\n        }\n\n        return \"(\" + (x+1) + \",\" + (y+1) + \")\";\n    }\n\n    private int getDirectionIndex(String direction) {\n        switch (direction) {\n            case \"no\":\n                return 0;\n            case \"ea\":\n                return 1;\n            case \"so\":\n                return 2;\n            case \"we\":\n                return 3;\n            default:\n                throw new IllegalArgumentException(\"Invalid direction: \" + direction);\n        }\n    }\n}"}, {"source": "gpt3.5", "name": "12", "file_name": "GoAble.java", "style": "cc", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "gpt3.5", "name": "13", "file_name": "Exercise0.java", "style": "cc", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Exercise0 implements GoAble {\n\n    private static final int GRID_WIDTH = 12;\n    private static final int GRID_HEIGHT = 8;\n    private static final int[][] OBSTACLES = {{6, 2, 6, 5}, {5, 5, 6, 5}, {5, 5, 5, 6}, {5, 6, 12, 6}};\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    private int[] position = {11, 7};\n\n    public String goTo(String goCommandString) throws IllegalArgumentException {\n        int[] newPosition = Arrays.copyOf(position, position.length);\n        String[] goCommand = goCommandString.replaceAll(\"[^A-Za-z0-9]\", \"\").split(\"(?<=\\\\D)(?=\\\\d)|(?<=\\\\d)(?=\\\\D)\");\n\n        if (goCommand.length != 2) {\n            throw new IllegalArgumentException(\"Invalid command: \" + goCommandString);\n        }\n\n        int steps = Integer.parseInt(goCommand[1]);\n        int directionIndex = getDirectionIndex(goCommand[0]);\n\n        while (steps > 0) {\n            int[] nextPosition = Arrays.copyOf(newPosition, newPosition.length);\n            nextPosition[0] += DIRECTIONS[directionIndex][0];\n            nextPosition[1] += DIRECTIONS[directionIndex][1];\n\n            if (isOutOfBounds(nextPosition) || collidesWithObstacle(newPosition, nextPosition)) {\n                break;\n            }\n\n            newPosition = nextPosition;\n            steps--;\n        }\n\n        position = newPosition;\n        return \"(\" + position[0] + \",\" + position[1] + \")\";\n    }\n\n    private boolean isOutOfBounds(int[] position) {\n        return position[0] < 0 || position[0] >= GRID_WIDTH || position[1] < 0 || position[1] >= GRID_HEIGHT;\n    }\n\n    private boolean collidesWithObstacle(int[] currentPosition, int[] nextPosition) {\n        for (int[] obstacle : OBSTACLES) {\n            if (currentPosition[0] == nextPosition[0] && currentPosition[0] == obstacle[0]\n                    && obstacle[1] <= Math.max(currentPosition[1], nextPosition[1]) && obstacle[3] >= Math.min(currentPosition[1], nextPosition[1])) {\n                return true;\n            }\n            if (currentPosition[1] == nextPosition[1] && currentPosition[1] == obstacle[1]\n                    && obstacle[0] <= Math.max(currentPosition[0], nextPosition[0]) && obstacle[2] >= Math.min(currentPosition[0], nextPosition[0])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private int getDirectionIndex(String direction) throws IllegalArgumentException {\n        List<String> directions = Arrays.asList(\"no\", \"ea\", \"so\", \"we\");\n        int directionIndex = directions.indexOf(direction.toLowerCase());\n        if (directionIndex == -1) {\n            throw new IllegalArgumentException(\"Invalid direction: \" + direction);\n        }\n        return directionIndex;\n    }\n}\n"}, {"source": "gpt3.5", "name": "13", "file_name": "GoAble.java", "style": "cc", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "gpt3.5", "name": "14", "file_name": "Exercise0.java", "style": "cc", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Exercise0 implements GoAble {\n\n    private final int SPACESHIP_WIDTH = 12;\n    private final int SPACESHIP_HEIGHT = 8;\n\n    private final List<int[]> OBSTACLES = Arrays.asList(\n            new int[]{6, 2, 6, 5},\n            new int[]{5, 5, 6, 5},\n            new int[]{5, 5, 5, 6},\n            new int[]{5, 6, 12, 6}\n    );\n\n    private int[] droidPosition = new int[]{11, 7};\n\n    @Override\n    public String goTo(String goCommandString) throws IllegalArgumentException {\n        int[] newDroidPosition = Arrays.copyOf(droidPosition, droidPosition.length);\n        String[] goCommand = parseCommand(goCommandString);\n\n        int steps = Integer.parseInt(goCommand[1]);\n\n        switch (goCommand[0]) {\n            case \"no\":\n                newDroidPosition[1] += steps;\n                break;\n            case \"ea\":\n                newDroidPosition[0] += steps;\n                break;\n            case \"so\":\n                newDroidPosition[1] -= steps;\n                break;\n            case \"we\":\n                newDroidPosition[0] -= steps;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid direction: \" + goCommand[0]);\n        }\n\n        if (isPositionOutOfBounds(newDroidPosition)) {\n            throw new IllegalArgumentException(\"New position is out of bounds: \" + Arrays.toString(newDroidPosition));\n        }\n\n        if (doesIntersectObstacle(newDroidPosition)) {\n            return formatCoordinateString(droidPosition);\n        } else {\n            droidPosition = newDroidPosition;\n            return formatCoordinateString(droidPosition);\n        }\n    }\n\n    private boolean doesIntersectObstacle(int[] position) {\n        for (int[] obstacle : OBSTACLES) {\n            if (doesOverlap(obstacle, position)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean doesOverlap(int[] obstacle, int[] position) {\n        // Obstacle is horizontal and overlaps with position\n        if (obstacle[1] == obstacle[3] && obstacle[1] == position[1] && position[0] >= obstacle[0] && position[0] <= obstacle[2]) {\n            return true;\n        }\n        // Obstacle is vertical and overlaps with position\n        if (obstacle[0] == obstacle[2] && obstacle[0] == position[0] && position[1] >= obstacle[1] && position[1] <= obstacle[3]) {\n            return true;\n        }\n        return false;\n    }\n\n    private boolean isPositionOutOfBounds(int[] position) {\n        return position[0] < 0 || position[0] >= SPACESHIP_WIDTH || position[1] < 0 || position[1] >= SPACESHIP_HEIGHT;\n    }\n\n    private String[] parseCommand(String commandString) throws IllegalArgumentException {\n        String[] command = commandString.replaceAll(\"\\\\[|\\\\]\", \"\").split(\",\");\n        if (command.length != 2) {\n            throw new IllegalArgumentException(\"Invalid command: \" + commandString);\n        }\n        return command;\n    }\n\n    private String formatCoordinateString(int[] coordinate) {\n        return String.format(\"(%d,%d)\", coordinate[0], coordinate[1]);\n    }\n}\n"}, {"source": "gpt3.5", "name": "14", "file_name": "GoAble.java", "style": "cc", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "gpt3.5", "name": "15", "file_name": "Exercise0.java", "style": "styled", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n\n    private int x = 11;\n    private int y = 7;\n\n    private final int deckWidth = 12;\n    private final int deckHeight = 8;\n\n    private final int[][] obstacles = {{6,2,6,5}, {5,5,6,5}, {5,5,5,6}, {5,6,12,6}};\n\n    public String goTo(String goCommandString) {\n        String[] command = goCommandString.replaceAll(\"[\\\\[\\\\]]\", \"\").split(\",\");\n\n        String direction = command[0];\n        int steps = Integer.parseInt(command[1]);\n\n        switch (direction) {\n            case \"no\":\n                for (int i = 0; i < steps; i++) {\n                    if (y+1 >= deckHeight) break;\n                    boolean isObstacle = checkObstacles(x, y+1);\n                    if (isObstacle) break;\n                    y++;\n                }\n                break;\n            case \"ea\":\n                for (int i = 0; i < steps; i++) {\n                    if (x+1 >= deckWidth) break;\n                    boolean isObstacle = checkObstacles(x+1, y);\n                    if (isObstacle) break;\n                    x++;\n                }\n                break;\n            case \"so\":\n                for (int i = 0; i < steps; i++) {\n                    if (y-1 < 0) break;\n                    boolean isObstacle = checkObstacles(x, y-1);\n                    if (isObstacle) break;\n                    y--;\n                }\n                break;\n            case \"we\":\n                for (int i = 0; i < steps; i++) {\n                    if (x-1 < 0) break;\n                    boolean isObstacle = checkObstacles(x-1, y);\n                    if (isObstacle) break;\n                    x--;\n                }\n                break;\n            default:\n                System.out.println(\"Invalid direction\");\n                break;\n        }\n\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    private boolean checkObstacles(int x2, int y2) {\n        for (int[] obstacle : obstacles) {\n            int x1 = obstacle[0];\n            int y1 = obstacle[1];\n            int x3 = obstacle[2];\n            int y3 = obstacle[3];\n\n            if (x2 >= x1 && x2 <= x3 && y2 >= y1 && y2 <= y3) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n"}, {"source": "gpt3.5", "name": "15", "file_name": "GoAble.java", "style": "styled", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "gpt3.5", "name": "16", "file_name": "Exercise0.java", "style": "styled", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n\n    // values for the spaceship deck size and obstacle locations\n    private final int WIDTH = 12;\n    private final int HEIGHT = 8;\n    private final int[][] OBSTACLES = {{6, 2, 6, 5}, {5, 5, 6, 5}, {5, 5, 5, 6}, {5, 6, 12, 6}};\n\n    // initial position for the maintenance droid\n    private int x = 11;\n    private int y = 7;\n\n    @Override\n    public String goTo(String goCommandString) {\n        // parse the goCommandString to get the direction and number of steps\n        String direction = goCommandString.substring(1, 3);\n        int steps = Integer.parseInt(goCommandString.substring(4, goCommandString.length() - 1));\n\n        // update the position of the maintenance droid based on the given direction and number of steps\n        switch (direction) {\n            case \"no\":\n                for (int i = 0; i < steps; i++) {\n                    if (y + 1 >= HEIGHT) break;\n                    boolean obstacleDetected = false;\n                    for (int[] obstacle : OBSTACLES) {\n                        if (obstacle[0] <= x && x <= obstacle[2] && obstacle[1] == y + 1) {\n                            obstacleDetected = true;\n                            break;\n                        }\n                    }\n                    if (obstacleDetected) break;\n                    y++;\n                }\n                break;\n            case \"ea\":\n                for (int i = 0; i < steps; i++) {\n                    if (x + 1 >= WIDTH) break;\n                    boolean obstacleDetected = false;\n                    for (int[] obstacle : OBSTACLES) {\n                        if (obstacle[1] <= y && y <= obstacle[3] && obstacle[0] == x + 1) {\n                            obstacleDetected = true;\n                            break;\n                        }\n                    }\n                    if (obstacleDetected) break;\n                    x++;\n                }\n                break;\n            case \"so\":\n                for (int i = 0; i < steps; i++) {\n                    if (y - 1 < 0) break;\n                    boolean obstacleDetected = false;\n                    for (int[] obstacle : OBSTACLES) {\n                        if (obstacle[0] <= x && x <= obstacle[2] && obstacle[3] == y - 1) {\n                            obstacleDetected = true;\n                            break;\n                        }\n                    }\n                    if (obstacleDetected) break;\n                    y--;\n                }\n                break;\n            case \"we\":\n                for (int i = 0; i < steps; i++) {\n                    if (x - 1 < 0) break;\n                    boolean obstacleDetected = false;\n                    for (int[] obstacle : OBSTACLES) {\n                        if (obstacle[1] <= y && y <= obstacle[3] && obstacle[2] == x - 1) {\n                            obstacleDetected = true;\n                            break;\n                        }\n                    }\n                    if (obstacleDetected) break;\n                    x--;\n                }\n                break;\n        }\n\n        // return the new position of the maintenance droid\n        return \"(\" + x + \",\" + y + \")\";\n    }\n}\n"}, {"source": "gpt3.5", "name": "16", "file_name": "GoAble.java", "style": "styled", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "gpt3.5", "name": "17", "file_name": "Exercise0.java", "style": "styled", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble{\n    private int robotX = 11;\n    private int robotY = 7;\n    private int gridWidth = 12;\n    private int gridHeight = 8;\n    private int[][] obstacles = {{6,2,6,5},{5,5,6,5},{5,5,5,6},{5,6,12,6}};\n\n    public String goTo(String goCommandString) {\n        String[] goCommand = goCommandString.replaceAll(\"\\\\[|\\\\]\", \"\").split(\",\");\n        String direction = goCommand[0];\n        int steps = Integer.parseInt(goCommand[1]);\n        int newX = robotX;\n        int newY = robotY;\n\n        if (direction.equals(\"no\")) {\n            newY += steps;\n        } else if (direction.equals(\"ea\")) {\n            newX += steps;\n        } else if (direction.equals(\"so\")) {\n            newY -= steps;\n        } else if (direction.equals(\"we\")) {\n            newX -= steps;\n        }\n\n        for (int[] obstacle : obstacles) {\n            int x1 = obstacle[0];\n            int y1 = obstacle[1];\n            int x2 = obstacle[2];\n            int y2 = obstacle[3];\n            if ((newX >= x1 && newX <= x2 && newY == robotY) ||\n                    (newY >= y1 && newY <= y2 && newX == robotX)) {\n                newX = Math.min(Math.max(newX, 0), gridWidth);\n                newY = Math.min(Math.max(newY, 0), gridHeight);\n                break;\n            }\n        }\n\n        robotX = newX;\n        robotY = newY;\n        return \"(\" + robotX + \",\" + robotY + \")\";\n    }\n}\n"}, {"source": "gpt3.5", "name": "17", "file_name": "GoAble.java", "style": "styled", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "gpt3.5", "name": "18", "file_name": "Exercise0.java", "style": "styled", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n    public String goTo(String goCommandString) {\n        String direction = goCommandString.substring(1,3);\n        int steps = Integer.parseInt(goCommandString.substring(4, goCommandString.length() - 1));\n        int x = 11, y = 7;\n        int maxX = 12, maxY = 8;\n        int[][] obstacles = {{6,2,6,5},{5,5,6,5},{5,5,5,6},{5,6,12,6}};\n        for (int i = 0; i < steps; i++) {\n            switch(direction) {\n                case \"no\":\n                    y++;\n                    break;\n                case \"ea\":\n                    x++;\n                    break;\n                case \"so\":\n                    y--;\n                    break;\n                case \"we\":\n                    x--;\n                    break;\n            }\n            if (x < 0 || x >= maxX || y < 0 || y >= maxY) {\n                switch(direction) {\n                    case \"no\":\n                        y--;\n                        break;\n                    case \"ea\":\n                        x--;\n                        break;\n                    case \"so\":\n                        y++;\n                        break;\n                    case \"we\":\n                        x++;\n                        break;\n                }\n                break;\n            }\n            for (int j = 0; j < obstacles.length; j++) {\n                int x1 = obstacles[j][0];\n                int y1 = obstacles[j][1];\n                int x2 = obstacles[j][2];\n                int y2 = obstacles[j][3];\n                if (x == x1 && y >= y1 && y <= y2) {\n                    y = y2 + 1;\n                    break;\n                } else if (x == x2 && y >= y1 && y <= y2) {\n                    y = y1 - 1;\n                    break;\n                } else if (y == y1 && x >= x1 && x <= x2) {\n                    x = x2 + 1;\n                    break;\n                } else if (y == y2 && x >= x1 && x <= x2) {\n                    x = x1 - 1;\n                    break;\n                }\n            }\n        }\n        return \"(\" + x + \",\" + y + \")\";\n    }\n}\n"}, {"source": "gpt3.5", "name": "18", "file_name": "GoAble.java", "style": "styled", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "gpt3.5", "name": "19", "file_name": "Exercise0.java", "style": "styled", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble{\n    private int droidX;\n    private int droidY;\n    private int gridWidth = 12;\n    private int gridHeight = 8;\n    private boolean[][] obstacles;\n\n    public Exercise0() {\n        droidX = 11;\n        droidY = 7;\n        obstacles = new boolean[gridWidth][gridHeight];\n        // Set up the obstacles\n        for (int x = 0; x < gridWidth; x++) {\n            for (int y = 0; y < gridHeight; y++) {\n                obstacles[x][y] = false;\n            }\n        }\n        obstacles[6][2] = true;\n        obstacles[6][3] = true;\n        obstacles[6][4] = true;\n        obstacles[6][5] = true;\n        obstacles[5][5] = true;\n        obstacles[5][6] = true;\n        obstacles[7][6] = true;\n        obstacles[8][6] = true;\n        obstacles[9][6] = true;\n        obstacles[10][6] = true;\n        obstacles[11][6] = true;\n    }\n\n    public String goTo(String goCommandString) {\n        String[] parts = goCommandString.split(\",\");\n        String direction = parts[0].substring(1);\n        int steps = Integer.parseInt(parts[1].substring(0, parts[1].length() - 1));\n        int newX = droidX;\n        int newY = droidY;\n        switch (direction) {\n            case \"no\":\n                newY += steps;\n                break;\n            case \"ea\":\n                newX += steps;\n                break;\n            case \"so\":\n                newY -= steps;\n                break;\n            case \"we\":\n                newX -= steps;\n                break;\n            default:\n                break;\n        }\n        // Check for obstacles and spaceship deck boundary\n        if (newX < 0) {\n            newX = 0;\n        }\n        if (newX >= gridWidth) {\n            newX = gridWidth - 1;\n        }\n        if (newY < 0) {\n            newY = 0;\n        }\n        if (newY >= gridHeight) {\n            newY = gridHeight - 1;\n        }\n        if (obstacles[newX][newY]) {\n            // Check for obstacle in the way\n            if (direction.equals(\"no\") || direction.equals(\"so\")) {\n                // Check if obstacle is above or below the droid\n                int maxSteps = Math.abs(newY - droidY);\n                if (newY > droidY) {\n                    newY = droidY + maxSteps;\n                } else {\n                    newY = droidY - maxSteps;\n                }\n            } else {\n                // Obstacle is to the east or west of the droid\n                int maxSteps = Math.abs(newX - droidX);\n                if (newX > droidX) {\n                    newX = droidX + maxSteps;\n                } else {\n                    newX = droidX - maxSteps;\n                }\n            }\n        }\n        // Update the droid's position\n        droidX = newX;\n        droidY = newY;\n        return \"(\" + (droidX+1) + \",\" + (droidY+1) + \")\";\n    }\n}\n\n"}, {"source": "gpt3.5", "name": "19", "file_name": "GoAble.java", "style": "styled", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "gpt3.5", "name": "1", "file_name": "Exercise0.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n    private int x; // current x-coordinate\n    private int y; // current y-coordinate\n    private int[][] obstacles; // array to store obstacle coordinates\n\n    // Constructor\n    public Exercise0() {\n        x = 11; // starting x-coordinate\n        y = 7; // starting y-coordinate\n        // Initialize obstacle coordinates\n        obstacles = new int[][]{{6, 2, 6, 5}, {5, 5, 6, 5}, {5, 5, 5, 6}, {5, 6, 12, 6}};\n    }\n\n    @Override\n    public String goTo(String goCommandString) {\n        // Parse goCommandString to extract direction and steps\n        String direction = goCommandString.substring(1, 3);\n        int steps = Integer.parseInt(goCommandString.substring(4, goCommandString.length() - 1));\n\n        // Update coordinates based on direction and steps\n        switch (direction) {\n            case \"no\": // Move north\n                for (int i = 0; i < steps; i++) {\n                    if (isObstacle(x, y + 1)) { // Check for obstacle\n                        break;\n                    }\n                    y++;\n                }\n                break;\n            case \"ea\": // Move east\n                for (int i = 0; i < steps; i++) {\n                    if (isObstacle(x + 1, y)) { // Check for obstacle\n                        break;\n                    }\n                    x++;\n                }\n                break;\n            case \"so\": // Move south\n                for (int i = 0; i < steps; i++) {\n                    if (isObstacle(x, y - 1)) { // Check for obstacle\n                        break;\n                    }\n                    y--;\n                }\n                break;\n            case \"we\": // Move west\n                for (int i = 0; i < steps; i++) {\n                    if (isObstacle(x - 1, y)) { // Check for obstacle\n                        break;\n                    }\n                    x--;\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid direction: \" + direction);\n        }\n\n        // Clamp coordinates within spaceship deck boundaries\n        x = Math.max(0, Math.min(x, 11));\n        y = Math.max(0, Math.min(y, 7));\n\n        // Return current coordinates as string\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    // Helper method to check if given coordinates are part of an obstacle\n    private boolean isObstacle(int x, int y) {\n        for (int[] obstacle : obstacles) {\n            if (x >= obstacle[0] && x <= obstacle[2] && y >= obstacle[1] && y <= obstacle[3]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"}, {"source": "gpt3.5", "name": "1", "file_name": "GoAble.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "gpt3.5", "name": "2", "file_name": "Exercise0.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n\n    private int x; // current x-coordinate\n    private int y; // current y-coordinate\n\n    public Exercise0() {\n        // Initialize the starting position of the maintenance droid\n        x = 11;\n        y = 7;\n    }\n\n    @Override\n    public String goTo(String goCommandString) {\n        String[] command = goCommandString.replace(\"[\", \"\").replace(\"]\", \"\").split(\",\");\n        String direction = command[0];\n        int steps = Integer.parseInt(command[1]);\n\n        // Update the coordinates based on the direction and number of steps\n        for (int i = 0; i < steps; i++) {\n            switch (direction) {\n                case \"no\": // north\n                    if (y == 5 && x >= 5 && x <= 6) {\n                        y = 4;\n                        break;\n                    } else if (y > 0) {\n                        y--;\n                    }\n                    break;\n                case \"ea\": // east\n                    if (x == 5 && y >= 5 && y <= 6) {\n                        x = 6;\n                        break;\n                    } else if (x < 11) {\n                        x++;\n                    }\n                    break;\n                case \"so\": // south\n                    if (y == 0 && x >= 5 && x <= 6) {\n                        y = 1;\n                        break;\n                    } else if (y < 7) {\n                        y++;\n                    }\n                    break;\n                case \"we\": // west\n                    if (x == 6 && y >= 1 && y <= 5) {\n                        x = 5;\n                        break;\n                    } else if (x > 0) {\n                        x--;\n                    }\n                    break;\n            }\n        }\n\n        return \"(\" + x + \",\" + y + \")\";\n    }\n}"}, {"source": "gpt3.5", "name": "2", "file_name": "GoAble.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "gpt3.5", "name": "3", "file_name": "Exercise0.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Exercise0 implements GoAble {\n    private int[][] grid; // 2D array representing the spaceship deck grid\n    private int startX; // starting x-coordinate of the maintenance droid\n    private int startY; // starting y-coordinate of the maintenance droid\n    private List<int[]> obstacles; // list of obstacles represented as start and end coordinates\n\n    public Exercise0() {\n        // Define the spaceship deck grid size\n        int gridSizeX = 12;\n        int gridSizeY = 8;\n        grid = new int[gridSizeX][gridSizeY];\n\n        // Set the starting coordinates of the maintenance droid\n        startX = 11;\n        startY = 7;\n\n        // Define the obstacles\n        obstacles = new ArrayList<>();\n        obstacles.add(new int[]{6, 2, 6, 5});\n        obstacles.add(new int[]{5, 5, 6, 5});\n        obstacles.add(new int[]{5, 5, 5, 6});\n        obstacles.add(new int[]{5, 6, 12, 6});\n    }\n\n    @Override\n    public String goTo(String goCommandString) {\n        // Parse the goCommandString to extract direction and number of steps\n        String[] parts = goCommandString.substring(1, goCommandString.length() - 1).split(\",\");\n        String direction = parts[0];\n        int steps = Integer.parseInt(parts[1]);\n\n        // Update the coordinates of the maintenance droid based on the direction and steps\n        int newX = startX;\n        int newY = startY;\n        if (direction.equals(\"no\")) {\n            newY += steps;\n        } else if (direction.equals(\"ea\")) {\n            newX += steps;\n        } else if (direction.equals(\"so\")) {\n            newY -= steps;\n        } else if (direction.equals(\"we\")) {\n            newX -= steps;\n        }\n\n        // Check if the new coordinates are within the spaceship deck boundaries\n        if (newX < 0) {\n            newX = 0;\n        } else if (newX >= grid.length) {\n            newX = grid.length - 1;\n        }\n        if (newY < 0) {\n            newY = 0;\n        } else if (newY >= grid[0].length) {\n            newY = grid[0].length - 1;\n        }\n\n        // Check if the new coordinates are blocked by any obstacles\n        for (int[] obstacle : obstacles) {\n            int startX = obstacle[0];\n            int startY = obstacle[1];\n            int endX = obstacle[2];\n            int endY = obstacle[3];\n\n            if ((newX == startX && newY >= startY && newY <= endY) || (newY == startY && newX >= startX && newX <= endX)) {\n                // The new coordinates are blocked by an obstacle, reset to the previous coordinates\n                newX = startX;\n                newY = startY;\n                break;\n            }\n        }\n\n        startX = newX;\n        startY = newY;\n\n        // Return the new coordinates as a string in the format \"(x, y)\"\n        return \"(\" + startX + \",\" + startY + \")\";\n    }\n}"}, {"source": "gpt3.5", "name": "3", "file_name": "GoAble.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "gpt3.5", "name": "4", "file_name": "Exercise0.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n    private int[][] obstacles;\n    private int[][] spaceshipDeck;\n    private int[] currentPosition;\n\n    public Exercise0() {\n        obstacles = new int[][]{{6, 2, 6, 5}, {5, 5, 6, 5}, {5, 5, 5, 6}, {5, 6, 12, 6}};\n        spaceshipDeck = new int[][]{{0, 0, 12, 8}};\n        currentPosition = new int[]{11, 7};\n    }\n\n    @Override\n    public String goTo(String goCommandString) {\n        int steps = Integer.parseInt(goCommandString.substring(4, goCommandString.length() - 1));\n        String direction = goCommandString.substring(1, 3);\n        int[] newPosition = new int[]{currentPosition[0], currentPosition[1]};\n        switch (direction) {\n            case \"no\": // move north\n                for (int i = 0; i < steps; i++) {\n                    newPosition[1]++;\n                    if (isCollision(newPosition)) {\n                        newPosition[1]--;\n                        break;\n                    }\n                }\n                break;\n            case \"ea\": // move east\n                for (int i = 0; i < steps; i++) {\n                    newPosition[0]++;\n                    if (isCollision(newPosition)) {\n                        newPosition[0]--;\n                        break;\n                    }\n                }\n                break;\n            case \"so\": // move south\n                for (int i = 0; i < steps; i++) {\n                    newPosition[1]--;\n                    if (isCollision(newPosition)) {\n                        newPosition[1]++;\n                        break;\n                    }\n                }\n                break;\n            case \"we\": // move west\n                for (int i = 0; i < steps; i++) {\n                    newPosition[0]--;\n                    if (isCollision(newPosition)) {\n                        newPosition[0]++;\n                        break;\n                    }\n                }\n                break;\n        }\n        currentPosition = newPosition;\n        return \"(\" + currentPosition[0] + \",\" + currentPosition[1] + \")\";\n    }\n\n    private boolean isCollision(int[] position) {\n        for (int[] obstacle : obstacles) {\n            if ((position[0] >= obstacle[0] && position[0] <= obstacle[2])\n                    && (position[1] >= obstacle[1] && position[1] <= obstacle[3])) {\n                return true;\n            }\n        }\n        for (int[] deck : spaceshipDeck) {\n            if ((position[0] >= deck[0] && position[0] <= deck[2])\n                    && (position[1] >= deck[1] && position[1] <= deck[3])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"}, {"source": "gpt3.5", "name": "4", "file_name": "GoAble.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "gpt3.5", "name": "5", "file_name": "Exercise0.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n    private int[][] obstacles;\n    private int[][] grid;\n    private int currentX;\n    private int currentY;\n\n    // Constructor\n    public Exercise0() {\n        // Initialize the grid and obstacles based on the provided map\n        obstacles = new int[][]{{6, 2, 6, 5}, {5, 5, 6, 5}, {5, 5, 5, 6}, {5, 6, 12, 6}};\n        grid = new int[12][8];\n        currentX = 11;\n        currentY = 7;\n    }\n\n    @Override\n    public String goTo(String goCommandString) {\n        // Parse the goCommandString to get the direction and steps\n        String direction = goCommandString.substring(1, 3);\n        int steps = Integer.parseInt(goCommandString.substring(4, goCommandString.length() - 1));\n\n        // Update the current position based on the direction and steps\n        switch (direction) {\n            case \"no\":\n                for (int i = 1; i <= steps; i++) {\n                    if (currentY + i >= 8 || isObstacle(currentX, currentY + i)) {\n                        currentY += i - 1;\n                        break;\n                    }\n                    currentY += i;\n                }\n                break;\n            case \"ea\":\n                for (int i = 1; i <= steps; i++) {\n                    if (currentX + i >= 12 || isObstacle(currentX + i, currentY)) {\n                        currentX += i - 1;\n                        break;\n                    }\n                    currentX += i;\n                }\n                break;\n            case \"so\":\n                for (int i = 1; i <= steps; i++) {\n                    if (currentY - i < 0 || isObstacle(currentX, currentY - i)) {\n                        currentY -= i - 1;\n                        break;\n                    }\n                    currentY -= i;\n                }\n                break;\n            case \"we\":\n                for (int i = 1; i <= steps; i++) {\n                    if (currentX - i < 0 || isObstacle(currentX - i, currentY)) {\n                        currentX -= i - 1;\n                        break;\n                    }\n                    currentX -= i;\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid direction: \" + direction);\n        }\n\n        // Return the updated position as a formatted string\n        return \"(\" + currentX + \",\" + currentY + \")\";\n    }\n\n    // Helper method to check if a given position is an obstacle\n    private boolean isObstacle(int x, int y) {\n        for (int[] obstacle : obstacles) {\n            if (x >= obstacle[0] && x <= obstacle[2] && y >= obstacle[1] && y <= obstacle[3]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}, {"source": "gpt3.5", "name": "5", "file_name": "GoAble.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "gpt3.5", "name": "6", "file_name": "Exercise0.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n\n    private int currentX; // current x-coordinate of the droid\n    private int currentY; // current y-coordinate of the droid\n    private int gridWidth; // width of the grid\n    private int gridHeight; // height of the grid\n    private boolean[][] obstacles; // 2D array to represent the obstacles in the grid\n\n    // Constructor with hardcoded values for the droid's starting position, grid size, and obstacle positions\n    public Exercise0() {\n        this.currentX = 11; // Starting x-coordinate of the droid\n        this.currentY = 7; // Starting y-coordinate of the droid\n        this.gridWidth = 12; // Width of the grid\n        this.gridHeight = 8; // Height of the grid\n\n        // Initialize the obstacles array with false (no obstacles)\n        this.obstacles = new boolean[gridWidth][gridHeight];\n\n        // Set obstacles at specific positions (0-based coordinates)\n        for (int x = 6; x <= 6; x++) {\n            for (int y = 2; y <= 5; y++) {\n                obstacles[x][y] = true;\n            }\n        }\n        for (int x = 5; x <= 6; x++) {\n            obstacles[x][5] = true;\n        }\n        for (int x = 5; x <= 5; x++) {\n            for (int y = 5; y <= 6; y++) {\n                obstacles[x][y] = true;\n            }\n        }\n        for (int x = 5; x <= 12; x++) {\n            obstacles[x][6] = true;\n        }\n    }\n\n    // Method to move the droid based on the given command and return the new position\n    @Override\n    public String goTo(String goCommandString) {\n        String[] goCommand = goCommandString.substring(1, goCommandString.length() - 1).split(\",\");\n        String direction = goCommand[0];\n        int steps = Integer.parseInt(goCommand[1]);\n\n        int newX = currentX;\n        int newY = currentY;\n\n        switch (direction) {\n            case \"no\": // Move north\n                newY = Math.min(currentY + steps, gridHeight - 1);\n                break;\n            case \"ea\": // Move east\n                newX = Math.min(currentX + steps, gridWidth - 1);\n                break;\n            case \"so\": // Move south\n                newY = Math.max(currentY - steps, 0);\n                break;\n            case \"we\": // Move west\n                newX = Math.max(currentX - steps, 0);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid direction: \" + direction);\n        }\n\n        // Check for obstacles and update the droid's position\n        if (!obstacles[newX][newY]) {\n            currentX = newX;\n            currentY = newY;\n        }\n\n        // Return the new position of the droid as a formatted string\n        return \"(\" + currentX + \",\" + currentY + \")\";\n    }\n}"}, {"source": "gpt3.5", "name": "6", "file_name": "GoAble.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "gpt3.5", "name": "7", "file_name": "Exercise0.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n    private int droidX;\n    private int droidY;\n    private final int gridWidth;\n    private final int gridHeight;\n    private final int[][] obstacles;\n\n    public Exercise0() {\n        // Initialize droid starting position and grid size\n        droidX = 11;\n        droidY = 7;\n        gridWidth = 12;\n        gridHeight = 8;\n\n        // Define obstacle positions\n        obstacles = new int[][]{\n                {6, 2, 6, 5},\n                {5, 5, 6, 5},\n                {5, 5, 5, 6},\n                {5, 6, 12, 6}\n        };\n    }\n\n    @Override\n    public String goTo(String goCommandString) {\n        // Parse goCommandString to extract direction and steps\n        String direction = goCommandString.substring(1, 3);\n        int steps = Integer.parseInt(goCommandString.substring(4, goCommandString.length() - 1));\n\n        // Update droid position based on direction and steps\n        switch (direction) {\n            case \"no\":\n                droidY = Math.max(0, droidY - steps);\n                break;\n            case \"ea\":\n                droidX = Math.min(gridWidth - 1, droidX + steps);\n                break;\n            case \"so\":\n                droidY = Math.min(gridHeight - 1, droidY + steps);\n                break;\n            case \"we\":\n                droidX = Math.max(0, droidX - steps);\n                break;\n            default:\n                // Invalid direction, do nothing\n                break;\n        }\n\n        // Check for collision with obstacles or spaceship deck boundaries\n        for (int[] obstacle : obstacles) {\n            int obstacleX1 = obstacle[0];\n            int obstacleY1 = obstacle[1];\n            int obstacleX2 = obstacle[2];\n            int obstacleY2 = obstacle[3];\n\n            if ((droidX >= obstacleX1 && droidX <= obstacleX2) && (droidY >= obstacleY1 && droidY <= obstacleY2)) {\n                // Collision with obstacle, reset droid position\n                droidX = Math.max(obstacleX2 + 1, Math.min(gridWidth - 1, droidX));\n                droidY = Math.max(obstacleY2 + 1, Math.min(gridHeight - 1, droidY));\n                break;\n            }\n        }\n\n        // Format and return droid's current position as a string\n        return String.format(\"(%d,%d)\", droidX, droidY);\n    }\n}"}, {"source": "gpt3.5", "name": "7", "file_name": "GoAble.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "gpt3.5", "name": "8", "file_name": "Exercise0.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n\n    private static final int GRID_WIDTH = 12;\n    private static final int GRID_HEIGHT = 8;\n    private static final int START_X = 11;\n    private static final int START_Y = 7;\n    private static final int[][] OBSTACLES = {{6, 2, 6, 5}, {5, 5, 6, 5}, {5, 5, 5, 6}, {5, 6, 12, 6}};\n\n    private int currentX;\n    private int currentY;\n\n    public Exercise0() {\n        currentX = START_X;\n        currentY = START_Y;\n    }\n\n    @Override\n    public String goTo(String goCommandString) {\n        String[] parts = goCommandString.substring(1, goCommandString.length() - 1).split(\",\");\n        String direction = parts[0];\n        int steps = Integer.parseInt(parts[1]);\n\n        int newX = currentX;\n        int newY = currentY;\n\n        // Update the new position based on the direction and number of steps\n        switch (direction) {\n            case \"no\":\n                newY = Math.max(currentY - steps, 0);\n                break;\n            case \"ea\":\n                newX = Math.min(currentX + steps, GRID_WIDTH - 1);\n                break;\n            case \"so\":\n                newY = Math.min(currentY + steps, GRID_HEIGHT - 1);\n                break;\n            case \"we\":\n                newX = Math.max(currentX - steps, 0);\n                break;\n            default:\n                // Invalid direction\n                return \"Invalid direction\";\n        }\n\n        // Check for collisions with obstacles or spaceship deck boundaries\n        for (int[] obstacle : OBSTACLES) {\n            int obstacleStartX = obstacle[0];\n            int obstacleStartY = obstacle[1];\n            int obstacleEndX = obstacle[2];\n            int obstacleEndY = obstacle[3];\n\n            if ((currentX == newX && currentY == newY) || // Same position as before\n                    (currentX == newX && newY >= obstacleStartY && newY <= obstacleEndY &&\n                            ((obstacleStartX >= currentX && obstacleStartX <= newX) ||\n                                    (obstacleEndX >= currentX && obstacleEndX <= newX))) || // Colliding with vertical obstacle\n                    (currentY == newY && newX >= obstacleStartX && newX <= obstacleEndX &&\n                            ((obstacleStartY >= currentY && obstacleStartY <= newY) ||\n                                    (obstacleEndY >= currentY && obstacleEndY <= newY)))) { // Colliding with horizontal obstacle\n                // Stay at current position\n                return \"(\" + currentX + \",\" + currentY + \")\";\n            }\n        }\n\n        currentX = newX;\n        currentY = newY;\n\n        return \"(\" + currentX + \",\" + currentY + \")\";\n    }\n}"}, {"source": "gpt3.5", "name": "8", "file_name": "GoAble.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "gpt3.5", "name": "9", "file_name": "Exercise0.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Exercise0 implements GoAble {\n\n    private int[][] obstacles;\n    private int xMax;\n    private int yMax;\n    private int[] currentPosition;\n\n    public Exercise0() {\n        obstacles = new int[][]{{6, 2, 6, 5}, {5, 5, 6, 5}, {5, 5, 5, 6}, {5, 6, 12, 6}};\n        xMax = 12;\n        yMax = 8;\n        currentPosition = new int[]{11, 7};\n    }\n\n    @Override\n    public String goTo(String goCommandString) {\n        int[] newPosition = Arrays.copyOf(currentPosition, currentPosition.length);\n        String[] goCommand = goCommandString.substring(1, goCommandString.length() - 1).split(\",\");\n        int steps = Integer.parseInt(goCommand[1]);\n        switch (goCommand[0]) {\n            case \"no\":\n                newPosition[1] += steps;\n                break;\n            case \"ea\":\n                newPosition[0] += steps;\n                break;\n            case \"so\":\n                newPosition[1] -= steps;\n                break;\n            case \"we\":\n                newPosition[0] -= steps;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid direction: \" + goCommand[0]);\n        }\n        newPosition = clampToBoundaries(newPosition);\n        for (int[] obstacle : obstacles) {\n            if (isObstacleInPath(currentPosition, newPosition, obstacle)) {\n                return formatPosition(currentPosition);\n            }\n        }\n        currentPosition = newPosition;\n        return formatPosition(currentPosition);\n    }\n\n    private int[] clampToBoundaries(int[] position) {\n        int x = Math.max(0, Math.min(position[0], xMax));\n        int y = Math.max(0, Math.min(position[1], yMax));\n        return new int[]{x, y};\n    }\n\n    private boolean isObstacleInPath(int[] startPosition, int[] endPosition, int[] obstacle) {\n        if (obstacle[0] == obstacle[2]) { // vertical obstacle\n            int x = obstacle[0];\n            int y1 = obstacle[1];\n            int y2 = obstacle[3];\n            if (startPosition[0] == endPosition[0] && startPosition[0] == x &&\n                    Math.max(startPosition[1], endPosition[1]) >= y1 &&\n                    Math.min(startPosition[1], endPosition[1]) <= y2) {\n                return true;\n            }\n        } else if (obstacle[1] == obstacle[3]) { // horizontal obstacle\n            int y = obstacle[1];\n            int x1 = obstacle[0];\n            int x2 = obstacle[2];\n            if (startPosition[1] == endPosition[1] && startPosition[1] == y &&\n                    Math.max(startPosition[0], endPosition[0]) >= x1 &&\n                    Math.min(startPosition[0], endPosition[0]) <= x2) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private String formatPosition(int[] position) {\n        return String.format(\"(%d,%d)\", position[0], position[1]);\n    }\n\n}"}, {"source": "gpt3.5", "name": "9", "file_name": "GoAble.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "bing", "name": "1", "file_name": "Exercise0.java", "style": "plain", "version": "balanced", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n    private int[][] walls = {{3,0},{3,1},{3,2},{3,3},{4,3},{5,3},{6,3},{7,3},{7,2},{7,1},{7,0},{1,4},{2,4},{3,4},{4,4},{5,4},{6,4},{7,4}};\n    private int[] currentPos = {3,0};\n    private int[] roomSize = {12,8};\n\n    public String walkTo(String walkCommandString) {\n        String[] walkCommand = walkCommandString.substring(1,walkCommandString.length()-1).split(\",\");\n        int steps = Integer.parseInt(walkCommand[1]);\n        switch(walkCommand[0]) {\n            case \"no\":\n                for(int i=0; i<steps; i++) {\n                    if(currentPos[1]+1>=roomSize[1] || isWall(currentPos[0],currentPos[1]+1)) break;\n                    currentPos[1]++;\n                }\n                break;\n            case \"ea\":\n                for(int i=0; i<steps; i++) {\n                    if(currentPos[0]+1>=roomSize[0] || isWall(currentPos[0]+1,currentPos[1])) break;\n                    currentPos[0]++;\n                }\n                break;\n            case \"so\":\n                for(int i=0; i<steps; i++) {\n                    if(currentPos[1]-1<0 || isWall(currentPos[0],currentPos[1]-1)) break;\n                    currentPos[1]--;\n                }\n                break;\n            case \"we\":\n                for(int i=0; i<steps; i++) {\n                    if(currentPos[0]-1<0 || isWall(currentPos[0]-1,currentPos[1])) break;\n                    currentPos[0]--;\n                }\n                break;\n        }\n        return \"(\"+currentPos[0]+\",\"+currentPos[1]+\")\";\n    }\n\n    private boolean isWall(int x,int y) {\n        for(int[] wall : walls) {\n            if(wall[0]==x && wall[1]==y) return true;\n        }\n        return false;\n    }\n}"}, {"source": "bing", "name": "1", "file_name": "Walkable.java", "style": "plain", "version": "balanced", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "2", "file_name": "Exercise0.java", "style": "plain", "version": "balanced", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n    private int x = 3;\n    private int y = 0;\n    private int[][] walls = {{3, 0}, {3, 1}, {3, 2}, {3, 3}, {4, 3}, {5, 3}, {6, 3}, {7, 3}, {7, 2}, {7, 1}, {7, 0}, {1, 4}, {2, 4}, {3, 4}, {4, 4}, {5, 4}, {6, 4}, {7, 4}};\n    private int width = 12;\n    private int height = 8;\n\n    @Override\n    public String walkTo(String walkCommandString) {\n        String[] walkCommand = walkCommandString.substring(1, walkCommandString.length() - 1).split(\",\");\n        String direction = walkCommand[0];\n        int steps = Integer.parseInt(walkCommand[1]);\n\n        switch (direction) {\n            case \"no\":\n                for (int i = y + steps; i <= height; i++) {\n                    if (isWall(x, y + steps - i)) {\n                        y += i - y - steps;\n                        break;\n                    } else if (i == height) {\n                        y += steps;\n                    }\n                }\n                break;\n            case \"ea\":\n                for (int i = x + steps; i <= width; i++) {\n                    if (isWall(x + steps - i, y)) {\n                        x += i - x - steps;\n                        break;\n                    } else if (i == width) {\n                        x += steps;\n                    }\n                }\n                break;\n            case \"so\":\n                for (int i = y - steps; i >= 0; i--) {\n                    if (isWall(x, y - steps + i)) {\n                        y -= y - steps + i;\n                        break;\n                    } else if (i == 0) {\n                        y -= steps;\n                    }\n                }\n                break;\n            case \"we\":\n                for (int i = x - steps; i >= 0; i--) {\n                    if (isWall(x - steps + i, y)) {\n                        x -= x - steps + i;\n                        break;\n                    } else if (i == 0) {\n                        x -= steps;\n                    }\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid direction\");\n        }\n\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    private boolean isWall(int x, int y) {\n        for (int[] wall : walls) {\n            if (wall[0] == x && wall[1] == y) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}"}, {"source": "bing", "name": "2", "file_name": "Walkable.java", "style": "plain", "version": "balanced", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "3", "file_name": "Exercise0.java", "style": "plain", "version": "balanced", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n    private int[][] walls = {{0, 0, 12, 0}, {0, 0, 0, 8}, {12, 0, 12, 8}, {0, 8, 12, 8}, {3, 0, 3, 3}, {4, 3, 7, 3}, {7, 0, 7, 2}, {1, 4, 8, 4}};\n    private int[] robotPosition = {3, 0};\n    private int[] roomSize = {12, 8};\n\n    public Exercise0() {\n    }\n\n    public String walkTo(String walkCommandString) {\n        String[] walkCommand = walkCommandString.substring(1, walkCommandString.length() - 1).split(\",\");\n        String direction = walkCommand[0];\n        int steps = Integer.parseInt(walkCommand[1]);\n\n        int[] newPosition = new int[]{robotPosition[0], robotPosition[1]};\n        switch (direction) {\n            case \"no\":\n                newPosition[1] += steps;\n                break;\n            case \"ea\":\n                newPosition[0] += steps;\n                break;\n            case \"so\":\n                newPosition[1] -= steps;\n                break;\n            case \"we\":\n                newPosition[0] -= steps;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid direction: \" + direction);\n        }\n\n        if (newPosition[0] < 0) {\n            newPosition[0] = 0;\n        } else if (newPosition[0] >= roomSize[0]) {\n            newPosition[0] = roomSize[0] - 1;\n        }\n\n        if (newPosition[1] < 0) {\n            newPosition[1] = 0;\n        } else if (newPosition[1] >= roomSize[1]) {\n            newPosition[1] = roomSize[1] - 1;\n        }\n\n        for (int[] wall : walls) {\n            if ((wall[0] == robotPosition[0] && wall[2] == robotPosition[0]) || (wall[2] == robotPosition[0] && wall[4] == robotPosition[1])) {\n                if ((wall[1] <= robotPosition[1] && robotPosition[1] <= wall[3]) || (wall[3] <= robotPosition[1] && robotPosition[1] <= wall[5])) {\n                    if ((wall[1] <= newPosition[1] && newPosition[1] <= wall[3]) || (wall[3] <= newPosition[1] && newPosition[1] <= wall[5])) {\n                        if ((wall [2]== wall [4]) && (robotPosition [0]!= wall [2])) {\n                            continue;\n                        }\n                        if ((wall [3]== wall [5]) && (robotPosition [1]!= wall [3])) {\n                            continue;\n                        }\n                        return \"(\" + robotPosition [0]+\",\"+robotPosition [1]+\")\";\n                    }\n                }\n            }\n        }\n\n        robotPosition = newPosition;\n\n        return \"(\" + robotPosition [0]+\",\"+robotPosition [1]+\")\";\n    }\n}\n"}, {"source": "bing", "name": "3", "file_name": "Walkable.java", "style": "plain", "version": "balanced", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "4", "file_name": "Exercise0.java", "style": "cc", "version": "balanced", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Exercise0 implements Walkable {\n    private int xCoordinate = 3;\n    private int yCoordinate = 0;\n    private final List<int[]> walls = Arrays.asList(new int[][]{{3,0},{3,1},{3,2},{3,3},{4,3},{5,3},{6,3},{7,3},{7,2},{7,1},{7,0},{1,4},{2,4},{3,4},{4,4},{5,4},{6,4},{7,4}});\n    private final int width = 12;\n    private final int height = 8;\n\n    public String walkTo(String walkCommandString) throws IllegalArgumentException {\n        String[] command = walkCommandString.substring(1, walkCommandString.length() - 1).split(\",\");\n        String direction = command[0];\n        int steps = Integer.parseInt(command[1]);\n        switch (direction) {\n            case \"no\":\n                moveNorth(steps);\n                break;\n            case \"ea\":\n                moveEast(steps);\n                break;\n            case \"so\":\n                moveSouth(steps);\n                break;\n            case \"we\":\n                moveWest(steps);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid direction\");\n        }\n        return \"(\" + xCoordinate + \",\" + yCoordinate + \")\";\n    }\n\n    private void moveNorth(int steps) {\n        for (int i = 1; i <= steps; i++) {\n            if (yCoordinate + i >= height || isWall(xCoordinate,yCoordinate+i)) {\n                yCoordinate += i-1;\n                break;\n            }\n            yCoordinate += 1;\n        }\n    }\n\n    private void moveEast(int steps) {\n        for (int i = 1; i <= steps; i++) {\n            if (xCoordinate + i >= width || isWall(xCoordinate+i,yCoordinate)) {\n                xCoordinate += i-1;\n                break;\n            }\n            xCoordinate += 1;\n        }\n    }\n\n    private void moveSouth(int steps) {\n        for (int i = 1; i <= steps; i++) {\n            if (yCoordinate - i < 0 || isWall(xCoordinate,yCoordinate-i)) {\n                yCoordinate -= i-1;\n                break;\n            }\n            yCoordinate -= 1;\n        }\n    }\n\n    private void moveWest(int steps) {\n        for (int i = 1; i <= steps; i++) {\n            if (xCoordinate - i < 0 || isWall(xCoordinate-i,yCoordinate)) {\n                xCoordinate -= i-1;\n                break;\n            }\n            xCoordinate -= 1;\n        }\n    }\n\n    private boolean isWall(int x,int y) {\n        for (int[] wall : walls) {\n            if (wall[0] == x && wall[1] == y) return true;\n        }\n        return false;\n    }\n}"}, {"source": "bing", "name": "4", "file_name": "Walkable.java", "style": "cc", "version": "balanced", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "5", "file_name": "Exercise0.java", "style": "cc", "version": "balanced", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n\n    private final int[][] walls = {{3, 0, 3, 3}, {4, 3, 7, 3}, {7, 0, 7, 2}, {1, 4, 8, 4}};\n    private final int[] position = {0, 0};\n    private final int[] roomSize = {9, 5};\n\n    public Exercise0() {\n    }\n\n    public String walkTo(String walkCommandString) {\n        String[] command = walkCommandString.substring(1, walkCommandString.length() - 1).split(\",\");\n        int steps = Integer.parseInt(command[1]);\n        switch (command[0]) {\n            case \"no\":\n                return moveNorth(steps);\n            case \"ea\":\n                return moveEast(steps);\n            case \"so\":\n                return moveSouth(steps);\n            case \"we\":\n                return moveWest(steps);\n            default:\n                throw new IllegalArgumentException(\"Invalid direction\");\n        }\n    }\n\n    private String moveNorth(int steps) {\n        for (int i = 1; i <= steps; i++) {\n            if (position[1] + i >= roomSize[1] || isWall(position[0], position[1] + i)) {\n                return \"(\" + position[0] + \", \" + (position[1] + i - 1) + \")\";\n            }\n        }\n        position[1] += steps;\n        return \"(\" + position[0] + \", \" + position[1] + \")\";\n    }\n\n    private String moveEast(int steps) {\n        for (int i = 1; i <= steps; i++) {\n            if (position[0] + i >= roomSize[0] || isWall(position[0] + i, position[1])) {\n                return \"(\" + (position[0] + i - 1) + \", \" + position[1] + \")\";\n            }\n        }\n        position[0] += steps;\n        return \"(\" + position[0] + \", \" + position[1] + \")\";\n    }\n\n    private String moveSouth(int steps) {\n        for (int i = 1; i <= steps; i++) {\n            if (position[1] - i < 0 || isWall(position[0], position[1] - i)) {\n                return \"(\" + position[0] + \", \" + (position[1] - i + 1) + \")\";\n            }\n        }\n        position[1] -= steps;\n        return \"(\" + position[0] + \", \" + position[1] + \")\";\n    }\n\n    private String moveWest(int steps) {\n        for (int i = 1; i <= steps; i++) {\n            if (position[0] - i < 0 || isWall(position[0] - i, position[1])) {\n                return \"(\" + (position[0] - i + 1) + \", \" + position[1] + \")\";\n            }\n        }\n        position[0] -= steps;\n        return \"(\" + position[0] + \", \" + position[1] + \")\";\n    }\n\n    private boolean isWall(int x, int y) {\n        for (int[] wall : walls) {\n            if ((wall[0] == x && wall[1] == y) || (wall[2] == x && wall[3] == y)) {\n                return true;\n            } else if ((wall[2] == x && wall[1] == y) || (wall[0] == x && wall[3] == y)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"}, {"source": "bing", "name": "5", "file_name": "Walkable.java", "style": "cc", "version": "balanced", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "6", "file_name": "Exercise0.java", "style": "cc", "version": "balanced", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n    private final int[][] walls = {{3, 0}, {3, 1}, {3, 2}, {3, 3}, {4, 3}, {5, 3}, {6, 3}, {7, 3}, {7, 2}, {7, 1}, {7, 0}, {1, 4}, {2, 4}, {3, 4}, {4, 4}, {5, 4}, {6, 4}, {7, 4}};\n    private final int[] robotPosition = {3, 0};\n    private final int roomWidth = 12;\n    private final int roomHeight = 8;\n\n    public String walkTo(String walkCommandString) {\n        String[] walkCommand = walkCommandString.substring(1, walkCommandString.length() - 1).split(\",\");\n        String direction = walkCommand[0];\n        int steps = Integer.parseInt(walkCommand[1]);\n        int[] newPosition = calculateNewPosition(direction, steps);\n        if (isWall(newPosition)) {\n            return getRobotPosition();\n        }\n        updateRobotPosition(newPosition);\n        return getRobotPosition();\n    }\n\n    private int[] calculateNewPosition(String direction, int steps) {\n        int[] newPosition = new int[]{robotPosition[0], robotPosition[1]};\n        switch (direction) {\n            case \"no\":\n                newPosition[1] += steps;\n                break;\n            case \"ea\":\n                newPosition[0] += steps;\n                break;\n            case \"so\":\n                newPosition[1] -= steps;\n                break;\n            case \"we\":\n                newPosition[0] -= steps;\n                break;\n        }\n        if (newPosition[0] < 0) {\n            newPosition[0] = 0;\n        } else if (newPosition[0] >= roomWidth) {\n            newPosition[0] = roomWidth - 1;\n        }\n        if (newPosition[1] < 0) {\n            newPosition[1] = 0;\n        } else if (newPosition[1] >= roomHeight) {\n            newPosition[1] = roomHeight - 1;\n        }\n        return newPosition;\n    }\n\n    private boolean isWall(int[] position) {\n        for (int[] wall : walls) {\n            if (position[0] == wall[0] && position[1] == wall[1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void updateRobotPosition(int[] newPosition) {\n        robotPosition[0] = newPosition[0];\n        robotPosition[1] = newPosition[1];\n    }\n\n    private String getRobotPosition() {\n        return \"(\" + robotPosition[0] + \",\" + robotPosition[1] + \")\";\n    }\n}"}, {"source": "bing", "name": "6", "file_name": "Walkable.java", "style": "cc", "version": "balanced", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "6", "file_name": "Exercise0.java", "style": "styled", "version": "balanced", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n    private int[][] walls = {{3, 0}, {3, 1}, {3, 2}, {3, 3}, {4, 3}, {5, 3}, {6, 3}, {7, 3}, {7, 2}, {7, 1}, {7, 0}, {1, 4}, {2, 4}, {3, 4}, {4, 4}, {5, 4}, {6, 4}, {7, 4}, {8, 4}};\n    private int[] robotPosition = {3, 0};\n    private int[] roomSize = {12, 8};\n\n    public String walkTo(String walkCommandString) {\n        String[] walkCommand = walkCommandString.substring(1, walkCommandString.length() - 1).split(\",\");\n        String direction = walkCommand[0];\n        int steps = Integer.parseInt(walkCommand[1]);\n        int[] newPosition = new int[2];\n        newPosition[0] = robotPosition[0];\n        newPosition[1] = robotPosition[1];\n\n        if (direction.equals(\"no\")) {\n            newPosition[1] += steps;\n        } else if (direction.equals(\"ea\")) {\n            newPosition[0] += steps;\n        } else if (direction.equals(\"so\")) {\n            newPosition[1] -= steps;\n        } else if (direction.equals(\"we\")) {\n            newPosition[0] -= steps;\n        } else {\n            return \"Invalid direction\";\n        }\n\n        if (newPosition[0] < 0 || newPosition[0] >= roomSize[0] || newPosition[1] < 0 || newPosition[1] >= roomSize[1]) {\n            return \"(\" + robotPosition[0] + \",\" + robotPosition[1] + \")\";\n        }\n\n        for (int[] wall : walls) {\n            if (newPosition[0] == wall[0] && newPosition[1] == wall[1]) {\n                return \"(\" + robotPosition[0] + \",\" + robotPosition[1] + \")\";\n            }\n        }\n\n        robotPosition = newPosition;\n\n        return \"(\" + robotPosition[0] + \",\" + robotPosition[1] + \")\";\n    }\n}"}, {"source": "bing", "name": "6", "file_name": "Walkable.java", "style": "styled", "version": "balanced", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "1", "file_name": "Exercise0.java", "style": "plain", "version": "concise", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n    private int x = 3;\n    private int y = 0;\n    private int width = 12;\n    private int height = 8;\n    private boolean[][] walls = new boolean[width][height];\n\n    public Exercise0() {\n        for (int i = 0; i <= 3; i++) walls[3][i] = true;\n        for (int i = 4; i <= 7; i++) walls[i][3] = true;\n        for (int i = 0; i <= 2; i++) walls[7][i] = true;\n        for (int i = 1; i <= 8; i++) walls[i][4] = true;\n    }\n\n    @Override\n    public String walkTo(String walkCommandString) {\n        String[] parts = walkCommandString.split(\",\");\n        String direction = parts[0].substring(1);\n        int steps = Integer.parseInt(parts[1].substring(0, parts[1].length() - 1));\n        switch (direction) {\n            case \"no\":\n                while (steps > 0 && y + 1 < height && !walls[x][y + 1]) {\n                    y++;\n                    steps--;\n                }\n                break;\n            case \"ea\":\n                while (steps > 0 && x + 1 < width && !walls[x + 1][y]) {\n                    x++;\n                    steps--;\n                }\n                break;\n            case \"so\":\n                while (steps > 0 && y > 0 && !walls[x][y - 1]) {\n                    y--;\n                    steps--;\n                }\n                break;\n            case \"we\":\n                while (steps > 0 && x > 0 && !walls[x][y]) {\n                    x--;\n                    steps--;\n                }\n                break;\n        }\n        return \"(\" + x + \",\" + y + \")\";\n    }\n}"}, {"source": "bing", "name": "1", "file_name": "Walkable.java", "style": "plain", "version": "concise", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "2", "file_name": "Exercise0.java", "style": "plain", "version": "concise", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n    private int x = 3;\n    private int y = 0;\n    private int width = 12;\n    private int height = 8;\n    private boolean[][] verticalWalls = new boolean[width + 1][height];\n    private boolean[][] horizontalWalls = new boolean[width][height + 1];\n\n    public Exercise0() {\n        for (int i = 0; i <= 3; i++) {\n            verticalWalls[3][i] = true;\n        }\n        for (int i = 4; i <= 7; i++) {\n            horizontalWalls[i][3] = true;\n        }\n        for (int i = 0; i <= 2; i++) {\n            verticalWalls[7][i] = true;\n        }\n        for (int i = 1; i <= 8; i++) {\n            horizontalWalls[i][4] = true;\n        }\n    }\n\n    @Override\n    public String walkTo(String walkCommandString) {\n        String[] parts = walkCommandString.substring(1, walkCommandString.length() - 1).split(\",\");\n        String direction = parts[0];\n        int steps = Integer.parseInt(parts[1]);\n\n        switch (direction) {\n            case \"no\":\n                for (int i = 0; i < steps; i++) {\n                    if (y + 1 >= height || horizontalWalls[x][y + 1]) break;\n                    y++;\n                }\n                break;\n            case \"ea\":\n                for (int i = 0; i < steps; i++) {\n                    if (x + 1 >= width || verticalWalls[x + 1][y]) break;\n                    x++;\n                }\n                break;\n            case \"so\":\n                for (int i = 0; i < steps; i++) {\n                    if (y - 1 < 0 || horizontalWalls[x][y]) break;\n                    y--;\n                }\n                break;\n            case \"we\":\n                for (int i = 0; i < steps; i++) {\n                    if (x - 1 < 0 || verticalWalls[x][y]) break;\n                    x--;\n                }\n                break;\n        }\n\n        return \"(\" + x + \",\" + y + \")\";\n    }\n}"}, {"source": "bing", "name": "2", "file_name": "Walkable.java", "style": "plain", "version": "concise", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "3", "file_name": "Exercise0.java", "style": "cc", "version": "concise", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n    private int robotX;\n    private int robotY;\n    private final int roomWidth = 12;\n    private final int roomHeight = 8;\n    private final boolean[][] walls = new boolean[roomWidth][roomHeight];\n\n    public Exercise0() {\n        robotX = 3;\n        robotY = 0;\n        initializeWalls();\n    }\n\n    private void initializeWalls() {\n        for (int i = 0; i <= 3; i++) walls[3][i] = true;\n        for (int i = 4; i <= 7; i++) walls[i][3] = true;\n        for (int i = 0; i <= 2; i++) walls[7][i] = true;\n        for (int i = 1; i <= 8; i++) walls[i][4] = true;\n    }\n\n    @Override\n    public String walkTo(String walkCommandString) {\n        String direction = extractDirection(walkCommandString);\n        int steps = extractSteps(walkCommandString);\n        moveRobot(direction, steps);\n        return getCurrentPosition();\n    }\n\n    private String extractDirection(String walkCommandString) {\n        String[] parts = walkCommandString.split(\",\");\n        return parts[0].substring(1);\n    }\n\n    private int extractSteps(String walkCommandString) {\n        String[] parts = walkCommandString.split(\",\");\n        return Integer.parseInt(parts[1].substring(0, parts[1].length() - 1));\n    }\n\n    private void moveRobot(String direction, int steps) {\n        switch (direction) {\n            case \"no\":\n                moveNorth(steps);\n                break;\n            case \"ea\":\n                moveEast(steps);\n                break;\n            case \"so\":\n                moveSouth(steps);\n                break;\n            case \"we\":\n                moveWest(steps);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid direction: \" + direction);\n        }\n    }\n\n    private void moveNorth(int steps) {\n        while (steps > 0 && robotY < roomHeight - 1 && !walls[robotX][robotY + 1]) {\n            robotY++;\n            steps--;\n        }\n    }\n\n    private void moveEast(int steps) {\n        while (steps > 0 && robotX < roomWidth - 1 && !walls[robotX + 1][robotY]) {\n            robotX++;\n            steps--;\n        }\n    }\n\n    private void moveSouth(int steps) {\n        while (steps > 0 && robotY > 0 && !walls[robotX][robotY - 1]) {\n            robotY--;\n            steps--;\n        }\n    }\n\n    private void moveWest(int steps) {\n        while (steps > 0 && robotX > 0 && !walls[robotX - 1][robotY]) {\n            robotX--;\n            steps--;\n        }\n    }\n\n    private String getCurrentPosition() {\n        return \"(\" + robotX + \",\" + robotY + \")\";\n    }\n}"}, {"source": "bing", "name": "3", "file_name": "Walkable.java", "style": "cc", "version": "concise", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "4", "file_name": "Exercise0.java", "style": "plain", "version": "concise", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n    private int x = 3;\n    private int y = 0;\n    private int width = 12;\n    private int height = 8;\n    private boolean[][] walls = new boolean[width][height];\n\n    public Exercise0() {\n        // Initialize walls\n        for (int i = 0; i <= 3; i++) {\n            walls[3][i] = true;\n        }\n        for (int i = 4; i <= 7; i++) {\n            walls[i][3] = true;\n        }\n        for (int i = 0; i <= 2; i++) {\n            walls[7][i] = true;\n        }\n        for (int i = 1; i <= 8; i++) {\n            walls[i][4] = true;\n        }\n    }\n\n    public String walkTo(String walkCommandString) {\n        String[] parts = walkCommandString.split(\",\");\n        String direction = parts[0].substring(1);\n        int steps = Integer.parseInt(parts[1].substring(0, parts[1].length() - 1));\n\n        switch (direction) {\n            case \"no\":\n                for (int i = 0; i < steps; i++) {\n                    if (y + 1 >= height || walls[x][y + 1]) break;\n                    y++;\n                }\n                break;\n            case \"ea\":\n                for (int i = 0; i < steps; i++) {\n                    if (x + 1 >= width || walls[x + 1][y]) break;\n                    x++;\n                }\n                break;\n            case \"so\":\n                for (int i = 0; i < steps; i++) {\n                    if (y - 1 < 0 || walls[x][y - 1]) break;\n                    y--;\n                }\n                break;\n            case \"we\":\n                for (int i = 0; i < steps; i++) {\n                    if (x - 1 < 0 || walls[x - 1][y]) break;\n                    x--;\n                }\n                break;\n        }\n\n        return \"(\" + x + \",\" + y + \")\";\n    }\n}"}, {"source": "bing", "name": "4", "file_name": "Walkable.java", "style": "plain", "version": "concise", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "5", "file_name": "Exercise0.java", "style": "cc", "version": "concise", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n    private int robotX = 3;\n    private int robotY = 0;\n    private int roomWidth = 12;\n    private int roomHeight = 8;\n    private boolean[][] verticalWalls = new boolean[roomWidth + 1][roomHeight];\n    private boolean[][] horizontalWalls = new boolean[roomWidth][roomHeight + 1];\n\n    public Exercise0() {\n        initializeWalls();\n    }\n\n    private void initializeWalls() {\n        // Room boundaries\n        for (int i = 0; i < roomHeight; i++) {\n            verticalWalls[0][i] = true;\n            verticalWalls[roomWidth][i] = true;\n        }\n        for (int i = 0; i < roomWidth; i++) {\n            horizontalWalls[i][0] = true;\n            horizontalWalls[i][roomHeight] = true;\n        }\n        // Inner walls\n        for (int i = 0; i <= 3; i++) {\n            verticalWalls[3][i] = true;\n        }\n        for (int i = 4; i <= 7; i++) {\n            horizontalWalls[i][3] = true;\n        }\n        for (int i = 0; i <= 2; i++) {\n            verticalWalls[7][i] = true;\n        }\n        for (int i = 1; i <= 8; i++) {\n            horizontalWalls[i][4] = true;\n        }\n    }\n\n    public String walkTo(String walkCommandString) {\n        String direction = extractDirection(walkCommandString);\n        int steps = extractSteps(walkCommandString);\n\n        moveRobot(direction, steps);\n\n        return \"(\" + robotX + \",\" + robotY + \")\";\n    }\n\n    private String extractDirection(String walkCommandString) {\n        String[] parts = walkCommandString.split(\",\");\n        return parts[0].substring(1);\n    }\n\n    private int extractSteps(String walkCommandString) {\n        String[] parts = walkCommandString.split(\",\");\n        return Integer.parseInt(parts[1].substring(0, parts[1].length() - 1));\n    }\n\n    private void moveRobot(String direction, int steps) {\n        switch (direction) {\n            case \"no\":\n                moveNorth(steps);\n                break;\n            case \"ea\":\n                moveEast(steps);\n                break;\n            case \"so\":\n                moveSouth(steps);\n                break;\n            case \"we\":\n                moveWest(steps);\n                break;\n        }\n    }\n\n    private void moveNorth(int steps) {\n        for (int i = 0; i < steps; i++) {\n            if (horizontalWalls[robotX][robotY + 1]) break;\n            robotY++;\n        }\n    }\n\n    private void moveEast(int steps) {\n        for (int i = 0; i < steps; i++) {\n            if (verticalWalls[robotX + 1][robotY]) break;\n            robotX++;\n        }\n    }\n\n    private void moveSouth(int steps) {\n        for (int i = 0; i < steps; i++) {\n            if (horizontalWalls[robotX][robotY]) break;\n            robotY--;\n        }\n    }\n\n    private void moveWest(int steps) {\n        for (int i = 0; i < steps; i++) {\n            if (verticalWalls[robotX][robotY]) break;\n            robotX--;\n        }\n    }\n}"}, {"source": "bing", "name": "5", "file_name": "Walkable.java", "style": "cc", "version": "concise", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "6", "file_name": "Exercise0.java", "style": "styled", "version": "concise", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n    private int x;\n    private int y;\n    private final int maxX = 12;\n    private final int maxY = 8;\n\n    public Exercise0() {\n        x = 3;\n        y = 0;\n    }\n\n    public String walkTo(String walkCommandString) {\n        String direction = walkCommandString.substring(1,3);\n        int steps = Integer.parseInt(walkCommandString.substring(4, walkCommandString.length()-1));\n        if (direction.equals(\"no\")) {\n            y += steps;\n            if (y >= maxY || (x == 3 && y > 3) || (x >= 4 && x <= 7 && y > 3) || (x == 7 && y > 2) || (x >= 1 && x <= 8 && y > 4)) {\n                if (y >= maxY) {\n                    y = maxY;\n                }\n                if (x == 3 && y > 3) {\n                    y = 3;\n                }\n                if (x >= 4 && x <= 7 && y > 3) {\n                    y = 3;\n                }\n                if (x == 7 && y > 2) {\n                    y = 2;\n                }\n                if (x >=1 && x <=8 && y >4) {\n                    y = 4;\n                }\n            }\n        } else if (direction.equals(\"ea\")) {\n            x += steps;\n            if (x >= maxX || (y <= 3 && x > 3) || (y == 3 && x > 7) || (y <=2 && x >7) || (y ==4 && x >8)) {\n                if (x >= maxX) {\n                    x = maxX;\n                }\n                if (y <=3 && x >3) {\n                    x = 3;\n                }\n                if (y ==3 && x >7) {\n                    x = 7;\n                }\n                if (y <=2 && x >7) {\n                    x = 7;\n                }\n                if (y ==4 && x >8) {\n                    x =8;\n                }\n            }\n        } else if (direction.equals(\"so\")) {\n            y -= steps;\n            if (y <0) {\n                y =0;\n            }\n        } else if (direction.equals(\"we\")) {\n            x -= steps;\n            if (x <0) {\n                x =0;\n            }\n        }\n        return \"(\" + x + \",\" + y + \")\";\n    }\n}"}, {"source": "bing", "name": "6", "file_name": "Walkable.java", "style": "styled", "version": "concise", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "7", "file_name": "Exercise0.java", "style": "styled", "version": "concise", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n    private int x;\n    private int y;\n    private final int maxX = 12;\n    private final int maxY = 8;\n\n    public Exercise0() {\n        x = 3;\n        y = 0;\n    }\n\n    @Override\n    public String walkTo(String walkCommandString) {\n        String direction = walkCommandString.substring(1,3);\n        int steps = Integer.parseInt(walkCommandString.substring(4, walkCommandString.length()-1));\n        if (direction.equals(\"no\")) {\n            y += steps;\n            if (y >= maxY || (x == 3 && y > 3) || (x >= 4 && x <= 7 && y > 3) || (x == 7 && y > 2) || (x >= 1 && x <= 8 && y > 4)) {\n                y = Math.min(maxY, Math.min(y, Math.min((x == 3 ? 3 : y), (x >= 4 && x <= 7 ? 3 : y))));\n                y = Math.min(y, Math.min((x == 7 ? 2 : y), (x >= 1 && x <= 8 ? 4 : y)));\n            }\n        } else if (direction.equals(\"ea\")) {\n            x += steps;\n            if (x >= maxX || (y <= 3 && x > 3) || (y == 3 && x > 7) || (y <= 2 && x > 7) || (y == 4 && x > 8)) {\n                x = Math.min(maxX, Math.min(x, Math.min((y <= 3 ? 3 : x), (y == 3 ? 7 : x))));\n                x = Math.min(x, Math.min((y <=2 ? 7 : x), (y ==4 ? 8 : x)));\n            }\n        } else if (direction.equals(\"so\")) {\n            y -= steps;\n            if (y <0 || (x ==3 && y <0) || (x >=4 && x <=7 && y <0) || (x ==7 && y <0) || (x >=1 && x <=8 && y <0)) {\n                y = Math.max(0, Math.max(y, Math.max((x ==3 ?0 :y), (x >=4 && x <=7 ?0 :y))));\n                y = Math.max(y, Math.max((x ==7 ?0 :y), (x >=1 && x <=8 ?0 :y)));\n            }\n        } else if (direction.equals(\"we\")) {\n            x -= steps;\n            if (x <0 || (y <=3 && x <0) || (y ==3 && x <4) || (y <=2 && x <0) || (y ==4 && x <1)) {\n                x = Math.max(0, Math.max(x, Math.max((y <=3 ?0 :x), (y ==3 ?4 :x))));\n                x = Math.max(x, Math.max((y <=2 ?0 :x), (y ==4 ?1 :x)));\n            }\n        }\n        return \"(\" + x + \",\" + y + \")\";\n    }\n}"}, {"source": "bing", "name": "7", "file_name": "Walkable.java", "style": "styled", "version": "concise", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "8", "file_name": "Exercise0.java", "style": "styled", "version": "concise", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n    private int x;\n    private int y;\n    private final int maxX = 12;\n    private final int maxY = 8;\n\n    public Exercise0() {\n        x = 3;\n        y = 0;\n    }\n\n    public String walkTo(String walkCommandString) {\n        String direction = walkCommandString.substring(1, 3);\n        int steps = Integer.parseInt(walkCommandString.substring(4, walkCommandString.length() - 1));\n        if (direction.equals(\"no\")) {\n            y += steps;\n            if (y >= maxY || (x == 3 && y > 3) || (x >= 4 && x <= 7 && y > 3) || (x == 7 && y > 2) || (x >= 1 && x <= 8 && y > 4)) {\n                if (y >= maxY) {\n                    y = maxY;\n                }\n                if (x == 3 && y > 3) {\n                    y = 3;\n                }\n                if (x >= 4 && x <= 7 && y > 3) {\n                    y = 3;\n                }\n                if (x == 7 && y > 2) {\n                    y = 2;\n                }\n                if (x >= 1 && x <= 8 && y > 4) {\n                    y = 4;\n                }\n            }\n        } else if (direction.equals(\"ea\")) {\n            x += steps;\n            if (x >= maxX || (y <= 3 && x > 3) || (y == 3 && x > 7) || (y <= 2 && x > 7) || (y == 4 && x >8)) {\n                if (x >= maxX) {\n                    x = maxX;\n                }\n                if (y <=3&&x>3){\n                    x=3;\n                }\n                if(y==3&&x>7){\n                    x=7;\n                }\n                if(y<=2&&x>7){\n                    x=7;\n                }\n                if(y==4&&x>8){\n                    x=8;\n                }\n            }\n        } else if(direction.equals(\"so\")){\n            y-=steps;\n            if(y<0||(x==3&&y<0)||(x>=4&&x<=7&&y<0)||(x==7&&y<0)||(x>=1&&x<=8&&y<0)){\n                if(y<0){\n                    y=0;\n                }\n            }\n        }else{\n            x-=steps;\n            if(x<0||(y<=3&&x<0)||(y==3&&x<4)||(y<=2&&x<0)||(y==4&&x<1)){\n                if(x<0){\n                    x=0;\n                }\n            }\n        }\n\n        return \"(\" + x + \",\" + y + \")\";\n    }\n}"}, {"source": "bing", "name": "8", "file_name": "Walkable.java", "style": "styled", "version": "concise", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "9", "file_name": "Exercise0.java", "style": "styled", "version": "concise", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n    private int x;\n    private int y;\n    private int w;\n    private int h;\n    private boolean[][] ws;\n\n    public Exercise0() {\n        x = 3;\n        y = 0;\n        w = 12;\n        h = 8;\n        ws = new boolean[w][h];\n        for (int i = 0; i < 3; i++) {\n            ws[3][i] = true;\n        }\n        for (int i = 4; i < 7; i++) {\n            ws[i][3] = true;\n        }\n        for (int i = 0; i < 2; i++) {\n            ws[7][i] = true;\n        }\n        for (int i = 1; i < 8; i++) {\n            ws[i][4] = true;\n        }\n    }\n\n    @Override\n    public String walkTo(String s) {\n        String[] p = s.split(\",\");\n        String d = p[0].substring(1);\n        int n = Integer.parseInt(p[1].substring(0, p[1].length() - 1));\n        switch (d) {\n            case \"no\":\n                for (int i = 0; i < n; i++) {\n                    if (y + 1 >= h || ws[x][y + 1]) break;\n                    y++;\n                }\n                break;\n            case \"ea\":\n                for (int i = 0; i < n; i++) {\n                    if (x + 1 >= w || ws[x + 1][y]) break;\n                    x++;\n                }\n                break;\n            case \"so\":\n                for (int i = 0; i < n; i++) {\n                    if (y - 1 < 0 || ws[x][y - 1]) break;\n                    y--;\n                }\n                break;\n            case \"we\":\n                for (int i = 0; i < n; i++) {\n                    if (x - 1 < 0 || ws[x - 1][y]) break;\n                    x--;\n                }\n                break;\n        }\n        return \"(\" + x + \",\" + y + \")\";\n    }\n}"}, {"source": "bing", "name": "9", "file_name": "Walkable.java", "style": "styled", "version": "concise", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "10", "file_name": "Exercise0.java", "style": "styled", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n\n    public static final String NORTH = \"no\";\n    public static final String EAST = \"ea\";\n    public static final String SOUTH = \"so\";\n    public static final String WEST = \"we\";\n\n    public static final int ROOM_WIDTH = 12;\n    public static final int ROOM_HEIGHT = 8;\n    public static final int[][] WALLS = {{3,0,3,3}, {4,3,7,3}, {7,0,7,2}, {1,4,8,4}};\n\n    private int x;\n    private int y;\n\n    public Exercise0() {\n        x = 3;\n        y = 0;\n    }\n\n    @Override\n    public String walkTo(String walkCommandString) {\n        walkCommandString = walkCommandString.replace(\"[\", \"\").replace(\"]\", \"\");\n        String[] parts = walkCommandString.split(\",\");\n        String direction = parts[0];\n        int steps = Integer.parseInt(parts[1]);\n\n        switch (direction) {\n            case NORTH:\n                y += moveVertical(steps,true);\n                break;\n            case EAST:\n                x += moveHorizontal(steps,true);\n                break;\n            case SOUTH:\n                y -= moveVertical(steps,false);\n                break;\n            case WEST:\n                x -= moveHorizontal(steps,false);\n                break;\n            default:\n                return null;\n        }\n\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    private int moveVertical(int steps, boolean up) {\n        int target = y + (up ? steps : -steps);\n\n        if (target < 0 || target >= ROOM_HEIGHT) {\n            target = up ? ROOM_HEIGHT - 1 : 0;\n        }\n\n        for (int[] wall : WALLS) {\n            if (wall[0] == wall[2] && wall[0] == x && ((up && wall[1] <= y && wall[3] > y && wall[3] <= target) ||\n                    (!up && wall[1] >= y && wall[1] < y && wall[1] >= target))) {\n                target = up ? wall[3] : wall[1];\n            }\n        }\n\n        return up ? target - y : y - target;\n    }\n\n    private int moveHorizontal(int steps, boolean right) {\n        int target = x + (right ? steps : -steps);\n\n        if (target < 0 || target >= ROOM_WIDTH) {\n            target = right ? ROOM_WIDTH - 1 : 0;\n        }\n\n        for (int[] wall : WALLS) {\n            if (wall[1] == wall[3] && wall[1] == y && ((right && wall[0] <= x && wall[2] > x && wall[2] <= target) ||\n                    (!right && wall[0] >= x && wall[0] < x && wall[0] >= target))) {\n                target = right ? wall[2] : wall[0];\n            }\n        }\n\n        return right ? target - x : x - target;\n    }\n}"}, {"source": "bing", "name": "10", "file_name": "Walkable.java", "style": "styled", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "11", "file_name": "Exercise0.java", "style": "plain", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\n// A class that implements the Walkable interface\npublic class Exercise0 implements Walkable {\n\n    // A nested class that represents a cell in the room\n    public static class Cell {\n        // The x and y coordinates of the cell\n        private int x;\n        private int y;\n\n        // A constructor that takes the x and y coordinates as parameters\n        public Cell(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        // A getter method for the x coordinate\n        public int getX() {\n            return x;\n        }\n\n        // A getter method for the y coordinate\n        public int getY() {\n            return y;\n        }\n\n        // A setter method for the x coordinate\n        public void setX(int x) {\n            this.x = x;\n        }\n\n        // A setter method for the y coordinate\n        public void setY(int y) {\n            this.y = y;\n        }\n\n        // A method that returns a string representation of the cell\n        public String toString() {\n            return \"(\" + x + \",\" + y + \")\";\n        }\n    }\n\n    // A nested class that represents a wall in the room\n    public static class Wall {\n        // The start and end cells of the wall\n        private Cell start;\n        private Cell end;\n\n        // A constructor that takes the start and end cells as parameters\n        public Wall(Cell start, Cell end) {\n            this.start = start;\n            this.end = end;\n        }\n\n        // A getter method for the start cell\n        public Cell getStart() {\n            return start;\n        }\n\n        // A getter method for the end cell\n        public Cell getEnd() {\n            return end;\n        }\n    }\n\n    // The width and height of the room\n    private int width;\n    private int height;\n\n    // The array of walls in the room\n    private Wall[] walls;\n\n    // The current cell of the tidy-up robot\n    private Cell current;\n\n    // A constructor that takes no parameters and uses hardcoded values\n    public Exercise0() {\n        // The width and height of the room are 12 and 8 respectively\n        this.width = 12;\n        this.height = 8;\n\n        // The array of walls in the room has four elements\n        this.walls = new Wall[4];\n\n        // The first wall is between (3,0) and (3,3)\n        this.walls[0] = new Wall(new Cell(3, 0), new Cell(3, 3));\n\n        // The second wall is between (4,3) and (7,3)\n        this.walls[1] = new Wall(new Cell(4, 3), new Cell(7, 3));\n\n        // The third wall is between (7,0) and (7,2)\n        this.walls[2] = new Wall(new Cell(7, 0), new Cell(7, 2));\n\n        // The fourth wall is between (1,4) and (8,4)\n        this.walls[3] = new Wall(new Cell(1, 4), new Cell(8, 4));\n\n        // The current cell of the tidy-up robot is (3,0)\n        this.current = new Cell(3, 0);\n    }\n\n    // A method that implements the walkTo interface\n    public String walkTo(String walkCommandString) {\n\n        // Parse the walk command string into direction and steps\n        String direction = walkCommandString.substring(1, 3);\n        int steps = Integer.parseInt(walkCommandString.substring(4, walkCommandString.length() - 1));\n\n        // Initialize variables for the new x and y coordinates of the robot\n        int newX = current.getX();\n        int newY = current.getY();\n\n        // Switch on the direction and update the new coordinates accordingly\n        switch (direction) {\n            case \"no\":\n                newY += steps; // Move north by adding steps to y coordinate\n                break;\n            case \"ea\":\n                newX += steps; // Move east by adding steps to x coordinate\n                break;\n            case \"so\":\n                newY -= steps; // Move south by subtracting steps from y coordinate\n                break;\n            case \"we\":\n                newX -= steps; // Move west by subtracting steps from x coordinate\n                break;\n            default:\n                return \"Invalid direction\"; // Return an error message if direction is invalid\n        }\n        // Check if the new coordinates are within the room boundaries, and adjust them if not\n        if (newX < 0) {\n            newX = 0; // Cannot move beyond the left boundary\n        }\n        if (newX >= width) {\n            newX = width - 1; // Cannot move beyond the right boundary\n        }\n        if (newY < 0) {\n            newY = 0; // Cannot move beyond the bottom boundary\n        }\n        if (newY >= height) {\n            newY = height - 1; // Cannot move beyond the top boundary\n        }\n\n// Create a new cell object with the new coordinates\n        Cell newCell = new Cell(newX, newY);\n\n// Check if there is a wall between the current cell and the new cell, and adjust them if there is\n        for (Wall wall : walls) {\n\n            // Get the start and end cells of the wall\n            Cell wallStart = wall.getStart();\n            Cell wallEnd = wall.getEnd();\n\n            // Check if the wall is horizontal or vertical\n            boolean horizontal = wallStart.getY() == wallEnd.getY();\n            boolean vertical = wallStart.getX() == wallEnd.getX();\n\n            if (horizontal) {\n                // If horizontal, check if it blocks any movement along y axis\n\n                // Get the minimum and maximum x coordinates of the wall segment\n                int minX = Math.min(wallStart.getX(), wallEnd.getX());\n                int maxX = Math.max(wallStart.getX(), wallEnd.getX());\n\n                // Get the y coordinate of the wall segment\n                int y = wallStart.getY();\n\n                if (current.getY() < y && newCell.getY() >= y && newX >= minX && newX <= maxX) {\n                    newCell.setY(y - 1); // If moving up and hitting a horizontal wall, stop below it\n                }\n                if (current.getY() > y && newCell.getY() <= y && newX >= minX && newX <= maxX) {\n                    newCell.setY(y + 1); // If moving down and hitting a horizontal wall, stop above it\n                }\n\n            } else if (vertical) {\n                // If vertical, check if it blocks any movement along x axis\n\n                // Get the minimum and maximum y coordinates of the wall segment\n                int minY = Math.min(wallStart.getY(), wallEnd.getY());\n                int maxY = Math.max(wallStart.getY(), wallEnd.getY());\n\n                // Get the x coordinate of the wall segment\n                int x = wallStart.getX();\n\n                if (current.getX() < x && newCell.getX() >= x && newY >= minY && newY <= maxY) {\n                    newCell.setX(x - 1); // If moving right and hitting a vertical wall, stop left of it\n                }\n                if (current.getX() > x && newCell.getX() <= x && newY >= minY && newY <= maxY) {\n                    newCell.setX(x + 1); // If moving left and hitting a vertical wall, stop right of it\n                }\n\n            }\n        }\n\n// Update the current cell with the new cell\n        current = newCell;\n\n// Return a string representation of the current cell\n        return current.toString();\n    }\n}"}, {"source": "bing", "name": "11", "file_name": "Walkable.java", "style": "plain", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "12", "file_name": "Exercise0.java", "style": "styled", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n\n    private static final String NORTH = \"no\";\n    private static final String EAST = \"ea\";\n    private static final String SOUTH = \"so\";\n    private static final String WEST = \"we\";\n\n    private static final int WIDTH = 12;\n    private static final int HEIGHT = 8;\n    private static final int[][] WALLS = {{3, 0, 3, 3}, {4, 3, 7, 3}, {7, 0, 7, 2}, {1, 4, 8, 4}};\n\n    private int x;\n    private int y;\n\n    public Exercise0() {\n        x = 3;\n        y = 0;\n    }\n\n    public String walkTo(String c) {\n        c = c.replace(\"[\", \"\").replace(\"]\", \"\");\n        String[] p = c.split(\",\");\n        String d = p[0];\n        int s = Integer.parseInt(p[1]);\n\n        switch (d) {\n            case NORTH:\n                moveNorth(s);\n                break;\n            case EAST:\n                moveEast(s);\n                break;\n            case SOUTH:\n                moveSouth(s);\n                break;\n            case WEST:\n                moveWest(s);\n                break;\n            default:\n                break;\n        }\n\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    private void moveNorth(int s) {\n        for (int i = 0; i < s; i++) {\n            if (y == HEIGHT - 1 || hasWall(x, y + 1)) {\n                break;\n            } else {\n                y++;\n            }\n        }\n    }\n\n    private void moveEast(int s) {\n        for (int i = 0; i < s; i++) {\n            if (x == WIDTH - 1 || hasWall(x + 1, y)) {\n                break;\n            } else {\n                x++;\n            }\n        }\n    }\n\n    private void moveSouth(int s) {\n        for (int i = 0; i < s; i++) {\n            if (y == 0 || hasWall(x, y - 1)) {\n                break;\n            } else {\n                y--;\n            }\n        }\n    }\n\n    private void moveWest(int s) {\n        for (int i = 0; i < s; i++) {\n            if (x == 0 || hasWall(x - 1, y)) {\n                break;\n            } else {\n                x--;\n            }\n        }\n    }\n\n    private boolean hasWall(int x, int y) {\n        for (int[] w : WALLS) {\n            int x1 = w[0];\n            int y1 = w[1];\n            int x2 = w[2];\n            int y2 = w[3];\n            if (x1 == x2 && x == x1 && y >= y1 && y <= y2) {\n                return true;\n            }\n            if (y1 == y2 && y == y1 && x >= x1 && x <= x2) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"}, {"source": "bing", "name": "12", "file_name": "Walkable.java", "style": "styled", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "1", "file_name": "Exercise0.java", "style": "plain", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n\n    // The width and height of the room in cells\n    private static final int ROOM_WIDTH = 12;\n    private static final int ROOM_HEIGHT = 8;\n\n    // The initial x and y coordinates of the robot in cells\n    private static final int INITIAL_X = 3;\n    private static final int INITIAL_Y = 0;\n\n    // The current x and y coordinates of the robot in cells\n    private int x;\n    private int y;\n\n    // A two-dimensional array that represents the room grid\n    // A cell is true if it is blocked by a wall or a boundary, false otherwise\n    private boolean[][] grid;\n\n    // A constructor that initializes the robot and the grid\n    public Exercise0() {\n        // Set the initial position of the robot\n        x = INITIAL_X;\n        y = INITIAL_Y;\n\n        // Create the grid with the given width and height\n        grid = new boolean[ROOM_WIDTH][ROOM_HEIGHT];\n\n        // Mark the boundaries of the room as blocked cells\n        for (int i = 0; i < ROOM_WIDTH; i++) {\n            grid[i][0] = true; // bottom boundary\n            grid[i][ROOM_HEIGHT - 1] = true; // top boundary\n        }\n        for (int j = 0; j < ROOM_HEIGHT; j++) {\n            grid[0][j] = true; // left boundary\n            grid[ROOM_WIDTH - 1][j] = true; // right boundary\n        }\n\n        // Mark the walls as blocked cells\n        for (int j = 0; j <= 3; j++) {\n            grid[3][j] = true; // wall between (3,0) and (3,3)\n        }\n        for (int i = 4; i <= 7; i++) {\n            grid[i][3] = true; // wall between (4,3) and (7,3)\n        }\n        for (int j = 0; j <= 2; j++) {\n            grid[7][j] = true; // wall between (7,0) and (7,2)\n        }\n        for (int i = 1; i <= 8; i++) {\n            grid[i][4] = true; // wall between (1,4) and (8,4)\n        }\n    }\n\n    // A method that implements the Walkable interface\n    public String walkTo(String walkCommandString) {\n        // Parse the walk command string into direction and steps\n        String direction = walkCommandString.substring(1, 3); // e.g. \"no\"\n        int steps = Integer.parseInt(walkCommandString.substring(4, walkCommandString.length() - 1)); // e.g. 2\n\n        // Move the robot according to the direction and steps\n        switch (direction) {\n            case \"no\": // north\n                for (int i = 0; i < steps; i++) {\n                    if (y < ROOM_HEIGHT - 1 && !grid[x][y + 1]) { // check if the robot is not at the top boundary and the next cell is not blocked\n                        y++; // move one cell up\n                    } else {\n                        break; // stop moving if at the boundary or blocked by a wall\n                    }\n                }\n                break;\n            case \"ea\": // east\n                for (int i = 0; i < steps; i++) {\n                    if (x < ROOM_WIDTH - 1 && !grid[x + 1][y]) { // check if the robot is not at the right boundary and the next cell is not blocked\n                        x++; // move one cell right\n                    } else {\n                        break; // stop moving if at the boundary or blocked by a wall\n                    }\n                }\n                break;\n            case \"so\": // south\n                for (int i = 0; i < steps; i++) {\n                    if (y > 0 && !grid[x][y - 1]) { // check if the robot is not at the bottom boundary and the next cell is not blocked\n                        y--; // move one cell down\n                    } else {\n                        break; // stop moving if at the boundary or blocked by a wall\n                    }\n                }\n                break;\n            case \"we\": // west\n                for (int i = 0; i < steps; i++) {\n                    if (x > 0 && !grid[x - 1][y]) { // check if the robot is not at the left boundary and the next cell is not blocked\n                        x--; // move one cell left\n                    } else {\n                        break; // stop moving if at the boundary or blocked by a wall\n                    }\n                }\n                break;\n            default: // invalid direction\n                throw new IllegalArgumentException(\"Invalid direction: \" + direction);\n        }\n\n        // Return the current position of the robot as a string\n        return \"(\" + x + \",\" + y + \")\";\n    }\n}\n\n"}, {"source": "bing", "name": "1", "file_name": "Walkable.java", "style": "plain", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "2", "file_name": "Exercise0.java", "style": "plain", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\n// A class that represents a tidy-up robot that can move in a room with walls\npublic class Exercise0 implements Walkable {\n\n    // Constants for the directions\n    private static final String NORTH = \"no\";\n    private static final String EAST = \"ea\";\n    private static final String SOUTH = \"so\";\n    private static final String WEST = \"we\";\n\n    // Constants for the room size and walls\n    private static final int ROOM_WIDTH = 12;\n    private static final int ROOM_HEIGHT = 8;\n    private static final int[][] WALLS = {{3, 0, 3, 3}, {4, 3, 7, 3}, {7, 0, 7, 2}, {1, 4, 8, 4}};\n\n    // Variables for the robot position\n    private int x;\n    private int y;\n\n    // Constructor that sets the initial position of the robot\n    public Exercise0() {\n        x = 3;\n        y = 0;\n    }\n\n    // A method that moves the robot according to a command string and returns its final position\n    public String walkTo(String walkCommandString) {\n        // Parse the command string and extract the direction and steps\n        String direction = walkCommandString.substring(1, 3);\n        int steps = Integer.parseInt(walkCommandString.substring(4, walkCommandString.length() - 1));\n\n        // Move the robot according to the direction and steps using a for loop\n        for (int i = 0; i < steps; i++) {\n            // Check if the robot can move from its current position\n            if (isWall(x, y) || isBoundary(x, y)) {\n                // The robot cannot move\n                break;\n            }\n\n            // Increment or decrement the position by one depending on the direction\n            switch (direction) {\n                case NORTH:\n                    y++;\n                    break;\n                case EAST:\n                    x++;\n                    break;\n                case SOUTH:\n                    y--;\n                    break;\n                case WEST:\n                    x--;\n                    break;\n                default:\n                    // Invalid direction\n                    return null;\n            }\n\n            // Check if the robot has hit a wall or a room boundary and adjust its position accordingly\n            if (isWall(x, y)) {\n                // The robot has hit a wall\n                switch (direction) {\n                    case NORTH:\n                        y--;\n                        break;\n                    case EAST:\n                        x--;\n                        break;\n                    case SOUTH:\n                        y++;\n                        break;\n                    case WEST:\n                        x++;\n                        break;\n                }\n            }\n\n            if (isBoundary(x, y)) {\n                // The robot has hit a room boundary\n                switch (direction) {\n                    case NORTH:\n                        y = ROOM_HEIGHT - 1;\n                        break;\n                    case EAST:\n                        x = ROOM_WIDTH - 1;\n                        break;\n                    case SOUTH:\n                        y = 0;\n                        break;\n                    case WEST:\n                        x = 0;\n                        break;\n                }\n            }\n        }\n\n        // Return the final position of the robot as a string\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    // A helper method that checks if a given position is a wall\n    private boolean isWall(int x, int y) {\n        for (int[] wall : WALLS) {\n            if ((x == wall[0] || x == wall[2]) && y >= wall[1] && y <= wall[3]) {\n                // The position is on a vertical wall\n                return true;\n            }\n            if ((y == wall[1] || y == wall[3]) && x >= wall[0] && x <= wall[2]) {\n                // The position is on a horizontal wall\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // A helper method that checks if a given position is a room boundary\n    private boolean isBoundary(int x, int y) {\n        return x < 0 || x >= ROOM_WIDTH || y < 0 || y >= ROOM_HEIGHT;\n    }\n}"}, {"source": "bing", "name": "2", "file_name": "Walkable.java", "style": "plain", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "3", "file_name": "Exercise0.java", "style": "plain", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\n// A class that represents a tidy-up robot that can walk in a room with walls\npublic class Exercise0 implements Walkable {\n\n    // Constants for directions\n    private static final String NORTH = \"no\";\n    private static final String EAST = \"ea\";\n    private static final String SOUTH = \"so\";\n    private static final String WEST = \"we\";\n\n    // Constants for room size and walls\n    private static final int ROOM_WIDTH = 12;\n    private static final int ROOM_HEIGHT = 8;\n    private static final boolean[][] WALLS = new boolean[ROOM_WIDTH + 1][ROOM_HEIGHT + 1]; // a 2D array that stores whether there is a wall on each grid line\n\n    static {\n        // Initialize the walls according to the personal map\n        for (int x = 3; x <= 7; x++) {\n            WALLS[x][3] = true; // wall between (3,0)-(3,3) and (4,3)-(7,3)\n        }\n        for (int y = 0; y <= 4; y++) {\n            WALLS[3][y] = true; // wall between (3,0)-(3,3)\n            WALLS[7][y] = true; // wall between (7,0)-(7,2)\n        }\n        for (int x = 1; x <= 8; x++) {\n            WALLS[x][4] = true; // wall between (1,4)-(8,4)\n        }\n    }\n\n    // Instance variables for robot position\n    private int x; // the x-coordinate of the robot\n    private int y; // the y-coordinate of the robot\n\n    // Constructor that sets the initial position of the robot according to the personal map\n    public Exercise0() {\n        this.x = 3;\n        this.y = 0;\n    }\n\n    // A method that moves the robot according to a walk command string and returns its coordinate\n    public String walkTo(String walkCommandString) {\n        // Parse the walk command string into direction and steps\n        String direction = walkCommandString.substring(1, 3); // extract the direction part\n        int steps = Integer.parseInt(walkCommandString.substring(4, walkCommandString.length() - 1)); // extract and convert the steps part\n\n        // Move the robot according to the direction and steps, stopping at walls or boundaries\n        switch (direction) {\n            case NORTH:\n                while (steps > 0 && y < ROOM_HEIGHT - 1 && !WALLS[x][y + 1]) { // while there are steps left and no wall or boundary above\n                    y++; // move one cell up\n                    steps--; // decrease one step\n                }\n                break;\n            case EAST:\n                while (steps > 0 && x < ROOM_WIDTH - 1 && !WALLS[x + 1][y]) { // while there are steps left and no wall or boundary to the right\n                    x++; // move one cell right\n                    steps--; // decrease one step\n                }\n                break;\n            case SOUTH:\n                while (steps > 0 && y > 0 && !WALLS[x][y - 1]) { // while there are steps left and no wall or boundary below\n                    y--; // move one cell down\n                    steps--; // decrease one step\n                }\n                break;\n            case WEST:\n                while (steps > 0 && x > 0 && !WALLS[x][y]) { // while there are steps left and no wall or boundary to the left\n                    x--; // move one cell left\n                    steps--; // decrease one step\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid direction: \" + direction); // throw an exception if the direction is not valid\n        }\n\n        // Return the coordinate of the robot after walking as a string\n        return \"(\" + x + \",\" + y + \")\";\n    }\n}"}, {"source": "bing", "name": "3", "file_name": "Walkable.java", "style": "plain", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "4", "file_name": "Exercise0.java", "style": "plain", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\n// Define the class that implements the Walkable interface\npublic class Exercise0 implements Walkable {\n\n    // Define the constants for the room size and the directions\n    private static final int ROOM_WIDTH = 12;\n    private static final int ROOM_HEIGHT = 8;\n    private static final String NORTH = \"no\";\n    private static final String EAST = \"ea\";\n    private static final String SOUTH = \"so\";\n    private static final String WEST = \"we\";\n\n    // Define the arrays that represent the left and bottom walls in the room\n    // A cell is true if it has a wall on its left or bottom side\n    private static final boolean[][] LEFT_WALLS = new boolean[ROOM_WIDTH][ROOM_HEIGHT];\n    private static final boolean[][] BOTTOM_WALLS = new boolean[ROOM_WIDTH][ROOM_HEIGHT];\n\n    static {\n        // Mark the cells that have a wall on their left side\n        for (int y = 0; y <= 3; y++) {\n            LEFT_WALLS[3][y] = true;\n        }\n        for (int y = 0; y <= 2; y++) {\n            LEFT_WALLS[7][y] = true;\n        }\n        // Mark the cells that have a wall on their bottom side\n        for (int x = 4; x <= 7; x++) {\n            BOTTOM_WALLS[x][3] = true;\n        }\n        for (int x = 1; x <= 8; x++) {\n            BOTTOM_WALLS[x][4] = true;\n        }\n    }\n\n\n    // Define the fields for the robot's position\n    private int robotX;\n    private int robotY;\n\n    // Define the constructor that sets the robot's initial position\n    public Exercise0() {\n        robotX = 3;\n        robotY = 0;\n    }\n\n    // Implement the walkTo method that moves the robot according to the command\n    @Override\n    public String walkTo(String walkCommandString) {\n        // Parse the command string and extract the direction and the steps\n        String direction = parseDirection(walkCommandString);\n        int steps = parseSteps(walkCommandString);\n\n        // Move the robot according to the direction and the steps, stopping at walls or boundaries\n        switch (direction) {\n            case NORTH: // Move north\n                moveNorth(steps);\n                break;\n            case EAST: // Move east\n                moveEast(steps);\n                break;\n            case SOUTH: // Move south\n                moveSouth(steps);\n                break;\n            case WEST: // Move west\n                moveWest(steps);\n                break;\n            default: // Invalid direction\n                throw new IllegalArgumentException(\"Invalid direction: \" + direction);\n        }\n\n        // Return the robot's position as a string in the format \"(x,y)\"\n        return \"(\" + robotX + \",\" + robotY + \")\";\n    }\n\n    // Parse the command string and extract the direction part\n    private String parseDirection(String walkCommandString) {\n        walkCommandString = walkCommandString.trim();\n        if (!walkCommandString.startsWith(\"[\") || !walkCommandString.endsWith(\"]\")) {\n            throw new IllegalArgumentException(\"Invalid command format\");\n        }\n        walkCommandString = walkCommandString.substring(1, walkCommandString.length() - 1);\n        String[] parts = walkCommandString.split(\",\");\n        if (parts.length != 2) {\n            throw new IllegalArgumentException(\"Invalid command format\");\n        }\n        return parts[0].trim().toLowerCase();\n    }\n\n    // Parse the command string and extract the steps part\n    private int parseSteps(String walkCommandString) {\n        walkCommandString = walkCommandString.trim();\n        if (!walkCommandString.startsWith(\"[\") || !walkCommandString.endsWith(\"]\")) {\n            throw new IllegalArgumentException(\"Invalid command format\");\n        }\n        walkCommandString = walkCommandString.substring(1, walkCommandString.length() - 1);\n        String[] parts = walkCommandString.split(\",\");\n        if (parts.length != 2) {\n            throw new IllegalArgumentException(\"Invalid command format\");\n        }\n        return Integer.parseInt(parts[1].trim());\n    }\n\n    // Move the robot north by a given number of steps\n    private void moveNorth(int steps) {\n        for (int i = 0; i < steps; i++) {\n            // Check if there is a wall or a boundary above the robot\n            if (robotY == ROOM_HEIGHT - 1 || BOTTOM_WALLS[robotX][robotY + 1]) {\n                break; // Stop moving\n            }\n            robotY++; // Move one cell up\n        }\n    }\n\n    // Move the robot east by a given number of steps\n    private void moveEast(int steps) {\n        for (int i = 0; i < steps; i++) {\n            // Check if there is a wall or a boundary on the right of the robot\n            if (robotX == ROOM_WIDTH - 1 || LEFT_WALLS[robotX + 1][robotY]) {\n                break; // Stop moving\n            }\n            robotX++; // Move one cell right\n        }\n    }\n\n    // Move the robot south by a given number of steps\n    private void moveSouth(int steps) {\n        for (int i = 0; i < steps; i++) {\n            // Check if there is a wall or a boundary below the robot\n            if (robotY == 0 || BOTTOM_WALLS[robotX][robotY]) {\n                break; // Stop moving\n            }\n            robotY--; // Move one cell down\n        }\n    }\n\n    // Move the robot west by a given number of steps\n    private void moveWest(int steps) {\n        for (int i = 0; i < steps; i++) {\n            // Check if there is a wall or a boundary on the left of the robot\n            if (robotX == 0 || LEFT_WALLS[robotX][robotY]) {\n                break; // Stop moving\n            }\n            robotX--; // Move one cell left\n        }\n    }\n}"}, {"source": "bing", "name": "4", "file_name": "Walkable.java", "style": "plain", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "5", "file_name": "Exercise0.java", "style": "plain", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\n// A class that represents a tidy-up robot that can move in a room with walls\npublic class Exercise0 implements Walkable {\n\n    // Constants for the directions\n    private static final String NORTH = \"no\";\n    private static final String EAST = \"ea\";\n    private static final String SOUTH = \"so\";\n    private static final String WEST = \"we\";\n\n    // Constants for the room size and walls\n    private static final int ROOM_WIDTH = 12;\n    private static final int ROOM_HEIGHT = 8;\n    private static final int[][] WALLS = {{3, 0, 3, 3}, {4, 3, 7, 3}, {7, 0, 7, 2}, {1, 4, 8, 4}};\n\n    // Variables for the robot position\n    private int x;\n    private int y;\n\n    // Constructor that sets the initial position of the robot\n    public Exercise0() {\n        x = 3;\n        y = 0;\n    }\n\n    // A method that implements the walkTo interface\n    public String walkTo(String walkCommandString) {\n        // Parse the command string and extract the direction and steps\n        walkCommandString = walkCommandString.replace(\"[\", \"\").replace(\"]\", \"\");\n        String[] parts = walkCommandString.split(\",\");\n        String direction = parts[0];\n        int steps = Integer.parseInt(parts[1]);\n\n        // Move the robot according to the direction and steps\n        switch (direction) {\n            case NORTH:\n                moveNorth(steps);\n                break;\n            case EAST:\n                moveEast(steps);\n                break;\n            case SOUTH:\n                moveSouth(steps);\n                break;\n            case WEST:\n                moveWest(steps);\n                break;\n            default:\n                // Invalid direction\n                break;\n        }\n\n        // Return the current position of the robot as a string\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    // A helper method that moves the robot north by a given number of steps\n    private void moveNorth(int steps) {\n        // Loop through each step and check if there is a wall or boundary ahead\n        for (int i = 0; i < steps; i++) {\n            // Check if the robot is at the top boundary of the room\n            if (y == ROOM_HEIGHT - 1) {\n                // Stop moving\n                break;\n            }\n            // Check if there is a wall above the robot\n            boolean wallAbove = false;\n            for (int[] wall : WALLS) {\n                // A wall is above the robot if it has the same x coordinate and its lower y coordinate is equal to the robot's upper y coordinate\n                if (wall[0] == x && wall[1] == y + 1) {\n                    wallAbove = true;\n                    break;\n                }\n            }\n            if (wallAbove) {\n                // Stop moving\n                break;\n            }\n            // Move one step north\n            y++;\n        }\n    }\n\n    // A helper method that moves the robot east by a given number of steps\n    private void moveEast(int steps) {\n        // Loop through each step and check if there is a wall or boundary ahead\n        for (int i = 0; i < steps; i++) {\n            // Check if the robot is at the right boundary of the room\n            if (x == ROOM_WIDTH - 1) {\n                // Stop moving\n                break;\n            }\n            // Check if there is a wall to the right of the robot\n            boolean wallRight = false;\n            for (int[] wall : WALLS) {\n                // A wall is to the right of the robot if it has the same y coordinate and its left x coordinate is equal to the robot's right x coordinate\n                if (wall[1] == y && wall[0] == x + 1) {\n                    wallRight = true;\n                    break;\n                }\n            }\n            if (wallRight) {\n                // Stop moving\n                break;\n            }\n            // Move one step east\n            x++;\n        }\n    }\n\n    // A helper method that moves the robot south by a given number of steps\n    private void moveSouth(int steps) {\n        // Loop through each step and check if there is a wall or boundary ahead\n        for (int i = 0; i < steps; i++) {\n            // Check if the robot is at the bottom boundary of the room\n            if (y == 0) {\n                // Stop moving\n                break;\n            }\n            // Check if there is a wall below the robot\n            boolean wallBelow = false;\n            for (int[] wall : WALLS) {\n                // A wall is below the robot if it has the same x coordinate and its upper y coordinate is equal to the robot's lower y coordinate\n                if (wall[0] == x && wall[3] == y) {\n                    wallBelow = true;\n                    break;\n                }\n            }\n            if (wallBelow) {\n                // Stop moving\n                break;\n            }\n            // Move one step south\n            y--;\n        }\n    }\n\n    // A helper method that moves the robot west by a given number of steps\n    private void moveWest(int steps) {\n        // Loop through each step and check if there is a wall or boundary ahead\n        for (int i = 0; i < steps; i++) {\n            // Check if the robot is at the left boundary of the room\n            if (x == 0) {\n                // Stop moving\n                break;\n            }\n            // Check if there is a wall to the left of the robot\n            boolean wallLeft = false;\n            for (int[] wall : WALLS) {\n                // A wall is to the left of the robot if it has the same y coordinate and its right x coordinate is equal to the robot's left x coordinate\n                if (wall[1] == y && wall[2] == x) {\n                    wallLeft = true;\n                    break;\n                }\n            }\n            if (wallLeft) {\n                // Stop moving\n                break;\n            }\n            // Move one step west\n            x--;\n        }\n    }\n}\n"}, {"source": "bing", "name": "5", "file_name": "Walkable.java", "style": "plain", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "6", "file_name": "Exercise0.java", "style": "cc", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\n// A class that implements the Walkable interface\npublic class Exercise0 implements Walkable {\n\n    // Constants for the size of the room\n    public static final int ROOM_WIDTH = 12;\n    public static final int ROOM_HEIGHT = 8;\n\n    // Constants for the directions\n    public static final String NORTH = \"no\";\n    public static final String EAST = \"ea\";\n    public static final String SOUTH = \"so\";\n    public static final String WEST = \"we\";\n\n    // A nested class that represents a wall\n    private static class Wall {\n        // The coordinates of the start and end points of the wall\n        private int startX;\n        private int startY;\n        private int endX;\n        private int endY;\n\n        // A constructor that takes the coordinates as parameters\n        public Wall(int startX, int startY, int endX, int endY) {\n            this.startX = startX;\n            this.startY = startY;\n            this.endX = endX;\n            this.endY = endY;\n        }\n\n        // A method that checks if a wall is horizontal or vertical\n        public boolean isHorizontal() {\n            return startY == endY;\n        }\n\n        // A method that checks if a wall is blocking a given coordinate in a given direction\n        public boolean isBlocking(int x, int y, String direction) {\n            // If the wall is horizontal\n            if (isHorizontal()) {\n                // Check if the coordinate is on the same row as the wall\n                if (y == startY) {\n                    // Check if the coordinate is strictly between the start and end points of the wall\n                    if (x > startX && x < endX) {\n                        // Check if the direction is north or south\n                        if (direction.equals(NORTH) || direction.equals(SOUTH)) {\n                            // The wall is blocking\n                            return true;\n                        }\n                    }\n                }\n            } else { // If the wall is vertical\n                // Check if the coordinate is on the same column as the wall\n                if (x == startX) {\n                    // Check if the coordinate is strictly between the start and end points of the wall\n                    if (y > startY && y < endY) {\n                        // Check if the direction is east or west\n                        if (direction.equals(EAST) || direction.equals(WEST)) {\n                            // The wall is blocking\n                            return true;\n                        }\n                    }\n                }\n            }\n            // The wall is not blocking\n            return false;\n        }\n    }\n\n    // An array of walls in the room\n    private Wall[] walls;\n\n    // The current position of the robot\n    private int x;\n    private int y;\n\n    // A constructor that initializes the walls and the position of the robot\n    public Exercise0() {\n        walls = new Wall[4];\n        walls[0] = new Wall(3,0,3,3);\n        walls[1] = new Wall(4,3,7,3);\n        walls[2] = new Wall(7,0,7,2);\n        walls[3] = new Wall(1,4,8,4);\n        x = 3;\n        y = 0;\n    }\n\n    // A method that implements the walkTo method from the Walkable interface\n    @Override\n    public String walkTo(String walkCommandString) {\n        try {\n            // Parse the command string and extract the direction and steps\n            String direction = walkCommandString.substring(1,3);\n            int steps = Integer.parseInt(walkCommandString.substring(4,5));\n\n            // Move the robot according to the direction and steps\n            switch (direction) {\n                case NORTH:\n                    // Move the robot north until it reaches the room boundary or a wall\n                    for (int i = 0; i < steps; i++) {\n                        // Check if the next cell is within the room boundary\n                        if (y + 1 < ROOM_HEIGHT) {\n                            // Check if any wall is blocking the next cell\n                            boolean blocked = false;\n                            for (Wall wall : walls) {\n                                if (wall.isBlocking(x, y + 1, direction)) {\n                                    blocked = true;\n                                    break;\n                                }\n                            }\n                            // If not blocked, move to the next cell\n                            if (!blocked) {\n                                y++;\n                            } else {\n                                // If blocked, stop moving\n                                break;\n                            }\n                        } else {\n                            // If out of the room boundary, stop moving\n                            break;\n                        }\n                    }\n                    break;\n                case EAST:\n                    // Move the robot east until it reaches the room boundary or a wall\n                    for (int i = 0; i < steps; i++) {\n                        // Check if the next cell is within the room boundary\n                        if (x + 1 < ROOM_WIDTH) {\n                            // Check if any wall is blocking the next cell\n                            boolean blocked = false;\n                            for (Wall wall : walls) {\n                                if (wall.isBlocking(x + 1, y, direction)) {\n                                    blocked = true;\n                                    break;\n                                }\n                            }\n                            // If not blocked, move to the next cell\n                            if (!blocked) {\n                                x++;\n                            } else {\n                                // If blocked, stop moving\n                                break;\n                            }\n                        } else {\n                            // If out of the room boundary, stop moving\n                            break;\n                        }\n                    }\n                    break;\n                case SOUTH:\n                    // Move the robot south until it reaches the room boundary or a wall\n                    for (int i = 0; i < steps; i++) {\n                        // Check if the next cell is within the room boundary\n                        if (y - 1 > 0) {\n                            // Check if any wall is blocking the next cell\n                            boolean blocked = false;\n                            for (Wall wall : walls) {\n                                if (wall.isBlocking(x, y - 1, direction)) {\n                                    blocked = true;\n                                    break;\n                                }\n                            }\n                            // If not blocked, move to the next cell\n                            if (!blocked) {\n                                y--;\n                            } else {\n                                // If blocked, stop moving\n                                break;\n                            }\n                        } else {\n                            // If out of the room boundary, stop moving\n                            break;\n                        }\n                    }\n                    break;\n                case WEST:\n                    // Move the robot west until it reaches the room boundary or a wall\n                    for (int i = 0; i < steps; i++) {\n                        // Check if the next cell is within the room boundary\n                        if (x - 1 > 0) {\n                            // Check if any wall is blocking the next cell\n                            boolean blocked = false;\n                            for (Wall wall : walls) {\n                                if (wall.isBlocking(x - 1, y, direction)) {\n                                    blocked = true;\n                                    break;\n                                }\n                            }\n                            // If not blocked, move to the next cell\n                            if (!blocked) {\n                                x--;\n                            } else {\n                                // If blocked, stop moving\n                                break;\n                            }\n                        } else {\n                            // If out of the room boundary, stop moving\n                            break;\n                        }\n                    }\n                    break;\n                default:\n                    // If the direction is invalid, throw an exception\n                    throw new IllegalArgumentException(\"Invalid direction: \" + direction);\n            }\n\n            // Return the current position of the robot as a string\n            return \"(\" + x + \",\" + y + \")\";\n        } catch (Exception e) {\n            // If any error occurs, return the error message as a string\n            return e.getMessage();\n        }\n    }\n}"}, {"source": "bing", "name": "6", "file_name": "Walkable.java", "style": "cc", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "7", "file_name": "Exercise0.java", "style": "cc", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\n// A class that represents a robot that can walk in a room with walls\npublic class Exercise0 implements Walkable {\n\n    // Constants for the room size and wall locations\n    public static final int ROOM_WIDTH = 12;\n    public static final int ROOM_HEIGHT = 8;\n    public static final int[][] WALLS = {{3,0,3,3}, {4,3,7,3}, {7,0,7,2}, {1,4,8,4}};\n\n    // Fields for the robot's position and direction\n    private int x; // x-coordinate of the robot\n    private int y; // y-coordinate of the robot\n    private String dir; // direction of the robot (no, ea, so, we)\n\n    // Constructor that sets the initial position and direction of the robot\n    public Exercise0() {\n        x = 3;\n        y = 0;\n        dir = \"no\";\n    }\n\n    // Method that takes a walk command string and returns the final position of the robot\n    public String walkTo(String walkCommandString) {\n        updateDirection(walkCommandString);\n        moveRobot(walkCommandString);\n        return getPosition();\n    }\n\n    // Method that updates the robot's direction based on the input\n    private void updateDirection(String walkCommandString) {\n        dir = parseDirection(walkCommandString);\n    }\n\n    // Method that moves the robot as many steps as possible without hitting a wall or boundary\n    private void moveRobot(String walkCommandString) {\n        int steps = parseSteps(walkCommandString);\n        while (steps > 0 && isValidMove()) {\n            updatePosition();\n            steps--;\n        }\n    }\n\n    // Method that returns the final position of the robot as a string in the format \"(x,y)\"\n    private String getPosition() {\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    // Method that parses the direction from the walk command string\n    private String parseDirection(String walkCommandString) {\n        walkCommandString = removeBrackets(walkCommandString);\n        String[] parts = splitByComma(walkCommandString);\n        return parts[0];\n    }\n\n    // Method that parses the steps from the walk command string\n    private int parseSteps(String walkCommandString) {\n        walkCommandString = removeBrackets(walkCommandString);\n        String[] parts = splitByComma(walkCommandString);\n        return Integer.parseInt(parts[1]);\n    }\n\n    // Method that removes brackets from a string\n    private String removeBrackets(String s) {\n        return s.replace(\"[\", \"\").replace(\"]\", \"\");\n    }\n\n    // Method that splits a string by comma\n    private String[] splitByComma(String s) {\n        return s.split(\",\");\n    }\n\n    // Method that checks if the next move is valid based on the current position and direction\n    private boolean isValidMove() {\n        return !isBoundaryCrossed() && !isWallCrossed();\n    }\n\n    // Method that updates the position based on the direction\n    private void updatePosition() {\n        switch (dir) {\n            case \"no\":\n                y++;\n                break;\n            case \"ea\":\n                x++;\n                break;\n            case \"so\":\n                y--;\n                break;\n            case \"we\":\n                x--;\n                break;\n        }\n    }\n\n    // Method that checks if the next move would cross a room boundary\n    private boolean isBoundaryCrossed() {\n        return (x == 0 && dir.equals(\"we\")) ||\n                (x == ROOM_WIDTH - 1 && dir.equals(\"ea\")) ||\n                (y == 0 && dir.equals(\"so\")) ||\n                (y == ROOM_HEIGHT - 1 && dir.equals(\"no\"));\n    }\n\n    // Method that checks if the next move would cross a wall\n    private boolean isWallCrossed() {\n        for (int[] wall : WALLS) {\n            if (isVerticalWall(wall) && isSideOfWall(wall)) return true;\n            if (isHorizontalWall(wall) && isAboveOrBelowWall(wall)) return true;\n        }\n        return false;\n    }\n\n    // Method that checks if a wall is vertical\n    private boolean isVerticalWall(int[] wall) {\n        int x1 = wall[0];\n        int x2 = wall[2];\n        return x1 == x2;\n    }\n\n    // Method that checks if a wall is horizontal\n    private boolean isHorizontalWall(int[] wall) {\n        int y1 = wall[1];\n        int y2 = wall[3];\n        return y1 == y2;\n    }\n\n    // Method that checks if the robot is on the side of a vertical wall\n    private boolean isSideOfWall(int[] wall) {\n        int x1 = wall[0];\n        int y1 = wall[1];\n        int y2 = wall[3];\n        return (dir.equals(\"ea\") && x == x1 - 1 && y >= y1 && y <= y2) ||\n                (dir.equals(\"we\") && x == x1 && y >= y1 && y <= y2);\n    }\n\n    // Method that checks if the robot is above or below a horizontal wall\n    private boolean isAboveOrBelowWall(int[] wall) {\n        int x1 = wall[0];\n        int x2 = wall[2];\n        int y1 = wall[1];\n        return (dir.equals(\"no\") && y == y1 - 1 && x >= x1 && x <= x2) ||\n                (dir.equals(\"so\") && y == y1 && x >= x1 && x <= x2);\n    }\n}\n\n"}, {"source": "bing", "name": "7", "file_name": "Walkable.java", "style": "cc", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "8", "file_name": "Exercise0.java", "style": "styled", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Exercise0 implements Walkable {\n\n    // The size of the room\n    private static final int WIDTH = 12;\n    private static final int HEIGHT = 8;\n\n    // The starting location of the robot\n    private int x = 3;\n    private int y = 0;\n\n    // The walls in the room\n    private List<Wall> walls = Arrays.asList(\n            new Wall(3, 0, 3, 3),\n            new Wall(4, 3, 7, 3),\n            new Wall(7, 0, 7, 2),\n            new Wall(1, 4, 8, 4)\n    );\n\n    // The directions for the robot\n    private enum Direction {\n        NO, EA, SO, WE\n    }\n\n    // A helper class to represent a wall\n    private static class Wall {\n        int x1;\n        int y1;\n        int x2;\n        int y2;\n\n        public Wall(int x1, int y1, int x2, int y2) {\n            this.x1 = x1;\n            this.y1 = y1;\n            this.x2 = x2;\n            this.y2 = y2;\n        }\n    }\n\n    // The method to move the robot according to a command\n    @Override\n    public String walkTo(String walkCommandString) {\n        // Parse the command string\n        walkCommandString = walkCommandString.trim();\n        if (!walkCommandString.startsWith(\"[\") || !walkCommandString.endsWith(\"]\")) {\n            System.out.println(\"Invalid command format\");\n            return null;\n        }\n        walkCommandString = walkCommandString.substring(1, walkCommandString.length() - 1);\n        String[] parts = walkCommandString.split(\",\");\n        if (parts.length != 2) {\n            System.out.println(\"Invalid command format\");\n            return null;\n        }\n        Direction direction = Direction.valueOf(parts[0].toUpperCase());\n        int steps = Integer.parseInt(parts[1]);\n\n        // Move the robot according to the direction and steps\n        if (direction == Direction.NO) {\n            moveNorth(steps);\n        } else if (direction == Direction.EA) {\n            moveEast(steps);\n        } else if (direction == Direction.SO) {\n            moveSouth(steps);\n        } else if (direction == Direction.WE) {\n            moveWest(steps);\n        } else {\n            System.out.println(\"Invalid direction\");\n            return null;\n        }\n\n        // Return the current location of the robot\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    // A helper method to move the robot north\n    private void moveNorth(int steps) {\n        // Check if there is a wall or a boundary above the robot\n        for (int i = 0; i < walls.size(); i++) {\n            Wall wall = walls.get(i);\n            if (wall.x1 == wall.x2 && wall.x1 == x && wall.y1 <= y && wall.y2 >= y + steps) {\n                // The wall blocks the robot from moving north\n                steps = wall.y1 - y - 1;\n                break;\n            }\n        }\n        if (y + steps >= HEIGHT) {\n            // The boundary blocks the robot from moving north\n            steps = HEIGHT - y - 1;\n        }\n        // Update the y coordinate of the robot\n        y = y + steps;\n    }\n\n    // A helper method to move the robot east\n    private void moveEast(int steps) {\n        // Check if there is a wall or a boundary to the right of the robot\n        for (int i = 0; i < walls.size(); i++) {\n            Wall wall = walls.get(i);\n            if (wall.y1 == wall.y2 && wall.y1 == y && wall.x1 <= x && wall.x2 >= x + steps) {\n                // The wall blocks the robot from moving east\n                steps = wall.x1 - x - 1;\n                break;\n            }\n        }\n        if (x + steps >= WIDTH) {\n            // The boundary blocks the robot from moving east\n            steps = WIDTH - x - 1;\n        }\n        // Update the x coordinate of the robot\n        x = x + steps;\n    }\n\n    // A helper method to move the robot south\n    private void moveSouth(int steps) {\n        // Check if there is a wall or a boundary below the robot\n        for (int i = 0; i < walls.size(); i++) {\n            Wall wall = walls.get(i);\n            if (wall.x1 == wall.x2 && wall.x1 == x && wall.y1 <= y - steps && wall.y2 >= y) {\n                // The wall blocks the robot from moving south\n                steps = y - wall.y2 - 1;\n                break;\n            }\n        }\n        if (y - steps < 0) {\n            // The boundary blocks the robot from moving south\n            steps = y;\n        }\n        // Update the y coordinate of the robot\n        y = y - steps;\n    }\n\n    // A helper method to move the robot west\n    private void moveWest(int steps) {\n        // Check if there is a wall or a boundary to the left of the robot\n        for (int i = 0; i < walls.size(); i++) {\n            Wall wall = walls.get(i);\n            if (wall.y1 == wall.y2 && wall.y1 == y && wall.x1 <= x - steps && wall.x2 >= x) {\n                // The wall blocks the robot from moving west\n                steps = x - wall.x2 - 1;\n                break;\n            }\n        }\n        if (x - steps < 0) {\n            // The boundary blocks the robot from moving west\n            steps = x;\n        }\n        // Update the x coordinate of the robot\n        x = x - steps;\n    }\n\n}\n"}, {"source": "bing", "name": "8", "file_name": "Walkable.java", "style": "styled", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bing", "name": "9", "file_name": "Exercise0.java", "style": "styled", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n\n    private int x;\n    private int y;\n    private int width;\n    private int height;\n    private int[][] walls;\n\n    public Exercise0() {\n        x = 3;\n        y = 0;\n        width = 12;\n        height = 8;\n        walls = new int[][]{{3,0,3,3}, {4,3,7,3}, {7,0,7,2}, {1,4,8,4}};\n    }\n\n    @Override\n    public String walkTo(String walkCommandString) {\n        walkCommandString = walkCommandString.replace(\"[\", \"\").replace(\"]\", \"\");\n        String[] parts = walkCommandString.split(\",\");\n        String direction = parts[0];\n        int steps = Integer.parseInt(parts[1]);\n\n        if (direction.equals(\"no\")) {\n            for (int i = 0; i < steps; i++) {\n                boolean blocked = false;\n                if (y == height - 1) {\n                    blocked = true;\n                } else {\n                    for (int j = 0; j < walls.length; j++) {\n                        if (walls[j][0] == walls[j][2] && walls[j][0] == x && walls[j][1] <= y && walls[j][3] > y) {\n                            blocked = true;\n                            break;\n                        }\n                    }\n                }\n                if (!blocked) {\n                    y++;\n                } else {\n                    break;\n                }\n            }\n        } else if (direction.equals(\"ea\")) {\n            for (int i = 0; i < steps; i++) {\n                boolean blocked = false;\n                if (x == width - 1) {\n                    blocked = true;\n                } else {\n                    for (int j = 0; j < walls.length; j++) {\n                        if (walls[j][1] == walls[j][3] && walls[j][1] == y && walls[j][0] <= x && walls[j][2] > x) {\n                            blocked = true;\n                            break;\n                        }\n                    }\n                }\n                if (!blocked) {\n                    x++;\n                } else {\n                    break;\n                }\n            }\n        } else if (direction.equals(\"so\")) {\n            for (int i = 0; i < steps; i++) {\n                boolean blocked = false;\n                if (y == 0) {\n                    blocked = true;\n                } else {\n                    for (int j = 0; j < walls.length; j++) {\n                        if (walls[j][0] == walls[j][2] && walls[j][0] == x && walls[j][1] >= y && walls[j][1] < y) {\n                            blocked = true;\n                            break;\n                        }\n                    }\n                }\n                if (!blocked) {\n                    y--;\n                } else {\n                    break;\n                }\n            }\n        } else if (direction.equals(\"we\")) {\n            for (int i = 0; i < steps; i++) {\n                boolean blocked = false;\n                if (x == 0) {\n                    blocked = true;\n                } else {\n                    for (int j = 0; j < walls.length; j++) {\n                        if (walls[j][1] == walls[j][3] && walls[j][1] == y && walls[j][0] >= x && walls[j][0] < x) {\n                            blocked = true;\n                            break;\n                        }\n                    }\n                }\n                if (!blocked) {\n                    x--;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            return null;\n        }\n\n        return \"(\" + x + \",\" + y + \")\";\n    }\n}"}, {"source": "bing", "name": "9", "file_name": "Walkable.java", "style": "styled", "version": "creative", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "bard", "name": "10", "file_name": "Exercise0.java", "style": "styled", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n\n    private static final int START_X = 7;\n    private static final int START_Y = 7;\n    private static final int WIDTH = 11;\n    private static final int HEIGHT = 8;\n    private static final int[][] BARRIERS = {{2, 1}, {10, 1}, {2, 6}, {7, 6}, {10, 8}};\n\n    private int x = START_X;\n    private int y = START_Y;\n\n    public Exercise0() {\n        // Nothing here\n    }\n\n    @Override\n    public String move(String moveCommandString) {\n        // Parse the command string\n        String[] tokens = moveCommandString.substring(1, moveCommandString.length() - 1).split(\",\");\n        String direction = tokens[0];\n        int steps = Integer.parseInt(tokens[1]);\n\n        // Move the device\n        switch (direction) {\n            case \"no\":\n                for (int i = 0; i < steps; i++) {\n                    if (y - 1 < 0 || isBarrier(x, y - 1)) {\n                        break;\n                    }\n                    y--;\n                }\n                if (y < 0) {\n                    y = 0;\n                }\n                break;\n            case \"ea\":\n                for (int i = 0; i < steps; i++) {\n                    if (x + 1 >= WIDTH || isBarrier(x + 1, y)) {\n                        break;\n                    }\n                    x++;\n                }\n                break;\n            case \"so\":\n                for (int i = 0; i < steps; i++) {\n                    if (y + 1 >= HEIGHT || isBarrier(x, y + 1)) {\n                        break;\n                    }\n                    y++;\n                }\n                break;\n            case \"we\":\n                for (int i = 0; i < steps; i++) {\n                    if (x - 1 < 0 || isBarrier(x - 1, y)) {\n                        break;\n                    }\n                    x--;\n                }\n                break;\n        }\n\n        // Return the new location of the device\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    private boolean isBarrier(int x, int y) {\n        for (int[] barrier : BARRIERS) {\n            if (barrier[0] == x && barrier[1] == y) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"}, {"source": "bard", "name": "10", "file_name": "Moveable.java", "style": "styled", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "bard", "name": "11", "file_name": "Exercise0.java", "style": "styled", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable{\n    private static final int WIDTH = 11;\n    private static final int HEIGHT = 8;\n    private static final int START_X = 7;\n    private static final int START_Y = 7;\n    private static final int[] BARRIERS_X = {2, 10};\n    private static final int[] BARRIERS_Y = {1, 6, 7};\n\n    private int x;\n    private int y;\n\n    public Exercise0(){\n        this.x=START_X;\n        this.y=START_Y;\n    }\n\n    @Override\n    public String move(String moveCommandString){\n        String[] parts = moveCommandString.substring(1, moveCommandString.length()-1).split(\",\");\n        String direction = parts[0];\n        int steps = Integer.parseInt(parts[1]);\n\n        for(int i=0; i<steps; i++){\n            switch(direction){\n                case \"no\":\n                    if(y-1<0 || isBarrier(x, y-1)){\n                        break;\n                    }\n                    y--;\n                    break;\n                case \"ea\":\n                    if(x+1>=WIDTH || isBarrier(x+1, y)){\n                        break;\n                    }\n                    x++;\n                    break;\n                case \"so\":\n                    if(y+1>=HEIGHT || isBarrier(x, y+1)){\n                        break;\n                    }\n                    y++;\n                    break;\n                case \"we\":\n                    if(x-1<0 || isBarrier(x-1, y)){\n                        break;\n                    }\n                    x--;\n                    break;\n            }\n        }\n\n        return \"(\"+x+\",\"+y+\")\";\n    }\n\n    private boolean isBarrier(int x, int y){\n        for(int i=0; i<BARRIERS_X.length; i++){\n            if(x==BARRIERS_X[i]){\n                if(y<=BARRIERS_Y[i] || y>=BARRIERS_Y[i+1]){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}"}, {"source": "bard", "name": "11", "file_name": "Moveable.java", "style": "styled", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "bard", "name": "12", "file_name": "Exercise0.java", "style": "styled", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n    private static final int W = 11;\n    private static final int H = 8;\n    private static final int Sx = 7;\n    private static final int Sy = 7;\n    private static final int[][] B = {{2, 1, 10, 1}, {2, 1, 2, 6}, {2, 6, 7, 6}, {10, 1, 10, 8}};\n    private int x = Sx;\n    private int y = Sy;\n    public Exercise0() {}\n    @Override\n    public String move(String moveCommandString) {\n        String[] tokens = moveCommandString.substring(1, moveCommandString.length() - 1).split(\",\");\n        String d = tokens[0];\n        int s = Integer.parseInt(tokens[1]);\n        if (d.equals(\"no\")) {\n            for (int i = 0; i < s; i++) {\n                if (y - 1 < 0 || isBarrier(x, y - 1)) {\n                    break;\n                }\n                y--;\n            }\n        } else if (d.equals(\"ea\")) {\n            for (int i = 0; i < s; i++) {\n                if (x + 1 >= W || isBarrier(x + 1, y)) {\n                    break;\n                }\n                x++;\n            }\n        } else if (d.equals(\"so\")) {\n            for (int i = 0; i < s; i++) {\n                if (y + 1 >= H || isBarrier(x, y + 1)) {\n                    break;\n                }\n                y++;\n            }\n        } else if (d.equals(\"we\")) {\n            for (int i = 0; i < s; i++) {\n                if (x - 1 < 0 || isBarrier(x - 1, y)) {\n                    break;\n                }\n                x--;\n            }\n        }\n        return \"(\" + x + \",\" + y + \")\";\n    }\n    private boolean isBarrier(int x, int y) {\n        for (int[] barrier : B) {\n            if (x >= barrier[0] && x <= barrier[2] && y >= barrier[1] && y <= barrier[3]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"}, {"source": "bard", "name": "12", "file_name": "Moveable.java", "style": "styled", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "bard", "name": "13", "file_name": "Exercise0.java", "style": "cc", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.Arrays;\n\npublic class Exercise0 implements Moveable {\n\n    private static final int SPACE_WIDTH = 11;\n    private static final int SPACE_HEIGHT = 8;\n    private static final int START_X = 7;\n    private static final int START_Y = 7;\n    private static final int[][] BARRIERS = {{2, 1, 10, 1}, {2, 1, 2, 6}, {2, 6, 7, 6}, {10, 1, 10, 8}};\n\n    private int x;\n    private int y;\n\n    public Exercise0() {\n        this.x = START_X;\n        this.y = START_Y;\n    }\n\n    @Override\n    public String move(String moveCommandString) {\n        // Parse the move command string.\n        String[] parts = moveCommandString.substring(1, moveCommandString.length() - 1).split(\",\");\n        String direction = parts[0];\n        int steps = Integer.parseInt(parts[1]);\n\n        // Check if the direction is valid.\n        if (!isValidDirection(direction)) {\n            throw new IllegalArgumentException(\"Invalid direction: \" + direction);\n        }\n\n        // Check if the steps are valid.\n        if (steps < 1) {\n            throw new IllegalArgumentException(\"Invalid steps: \" + steps);\n        }\n\n        // Move the cleaning device.\n        for (int i = 0; i < steps; i++) {\n            // Check if the cleaning device will hit a barrier.\n            if (isBarrier(x, y + (direction.equals(\"no\") ? -1 : direction.equals(\"so\") ? 1 : 0))) {\n                break;\n            }\n\n            // Move the cleaning device.\n            if (direction.equals(\"no\")) {\n                y--;\n            } else if (direction.equals(\"ea\")) {\n                x++;\n            } else if (direction.equals(\"so\")) {\n                y++;\n            } else if (direction.equals(\"we\")) {\n                x--;\n            }\n        }\n\n        // Return the new coordinates of the cleaning device.\n        return \"(\" + x + \", \" + y + \")\";\n    }\n\n    // Check if the given direction is valid.\n    private boolean isValidDirection(String direction) {\n        return Arrays.asList(\"no\", \"ea\", \"so\", \"we\").contains(direction);\n    }\n\n    // Check if the given coordinates are within the bounds of the space.\n    private boolean isWithinBounds(int x, int y) {\n        return 0 <= x && x < SPACE_WIDTH && 0 <= y && y < SPACE_HEIGHT;\n    }\n\n    // Check if the given coordinates are within a barrier.\n    private boolean isBarrier(int x, int y) {\n        for (int[] barrier : BARRIERS) {\n            if (isWithinBounds(x, y) && x >= barrier[0] && x <= barrier[2] && y >= barrier[1] && y <= barrier[3]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"}, {"source": "bard", "name": "13", "file_name": "Moveable.java", "style": "cc", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "bard", "name": "14", "file_name": "Exercise0.java", "style": "cc", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n\n    private static final int WIDTH = 11;\n    private static final int HEIGHT = 8;\n    private static final int START_X = 7;\n    private static final int START_Y = 7;\n\n    private static final int[][] BARRIERS = {\n            {2, 1, 10, 1},\n            {2, 1, 2, 6},\n            {2, 6, 7, 6},\n            {10, 1, 10, 8}\n    };\n\n    private int x;\n    private int y;\n\n    public Exercise0() {\n        this.x = START_X;\n        this.y = START_Y;\n    }\n\n    @Override\n    public String move(String moveCommandString) {\n        // Parse the move command string.\n        String[] tokens = moveCommandString.substring(1, moveCommandString.length() - 1).split(\",\");\n        String direction = tokens[0];\n        int steps = Integer.parseInt(tokens[1]);\n\n        // Check if the direction is valid.\n        if (!isValidDirection(direction)) {\n            throw new IllegalArgumentException(\"Invalid direction: \" + direction);\n        }\n\n        // Move the cleaning device in the specified direction.\n        for (int i = 0; i < steps; i++) {\n            if (!moveInDirection(direction)) {\n                break;\n            }\n        }\n\n        // Return the new coordinates of the cleaning device.\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    private boolean moveInDirection(String direction) {\n        switch (direction) {\n            case \"no\":\n                if (isBarrier(x, y - 1)) {\n                    return false;\n                }\n                y--;\n                break;\n            case \"ea\":\n                if (isBarrier(x + 1, y)) {\n                    return false;\n                }\n                x++;\n                break;\n            case \"so\":\n                if (isBarrier(x, y + 1)) {\n                    return false;\n                }\n                y++;\n                break;\n            case \"we\":\n                if (isBarrier(x - 1, y)) {\n                    return false;\n                }\n                x--;\n                break;\n            default:\n                return false;\n        }\n\n        return true;\n    }\n\n    private boolean isValidDirection(String direction) {\n        return direction.equals(\"no\") || direction.equals(\"ea\") || direction.equals(\"so\") || direction.equals(\"we\");\n    }\n\n    private boolean isBarrier(int x, int y) {\n        for (int[] barrier : BARRIERS) {\n            if (x >= barrier[0] && x <= barrier[2] && y >= barrier[1] && y <= barrier[3]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}"}, {"source": "bard", "name": "14", "file_name": "Moveable.java", "style": "cc", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "bard", "name": "15", "file_name": "Exercise0.java", "style": "cc", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n\n    private static final String INVALID_DIRECTION_MESSAGE = \"Invalid direction: \";\n    private static final String INVALID_STEPS_MESSAGE = \"Invalid number of steps: \";\n\n    private int x = 7;\n    private int y = 7;\n    private int width = 11;\n    private int height = 8;\n    private String[] barriers = {\"(2,1)-(10,1)\", \"(2,1)-(2,6)\", \"(2,6)-(7,6)\", \"(10,1)-(10,8)\"};\n\n    public String move(String moveCommandString) {\n        // Check if the command string is valid.\n        if (!moveCommandString.startsWith(\"[\") || !moveCommandString.endsWith(\"]\")) {\n            throw new IllegalArgumentException(\"Invalid move command string: \" + moveCommandString);\n        }\n\n        // Parse the command string into its components.\n        String[] parts = moveCommandString.substring(1, moveCommandString.length() - 1).split(\",\");\n        String direction = parts[0];\n        int steps = Integer.parseInt(parts[1]);\n\n        // Check if the direction is valid.\n        if (!isValidDirection(direction)) {\n            throw new IllegalArgumentException(INVALID_DIRECTION_MESSAGE + direction);\n        }\n\n        // Check if the number of steps is valid.\n        if (steps < 1) {\n            throw new IllegalArgumentException(INVALID_STEPS_MESSAGE + steps);\n        }\n\n        // Move the cleaning device.\n        for (int i = 0; i < steps; i++) {\n            switch (direction) {\n                case \"no\":\n                    y--;\n                    break;\n                case \"ea\":\n                    x++;\n                    break;\n                case \"so\":\n                    y++;\n                    break;\n                case \"we\":\n                    x--;\n                    break;\n                default:\n                    throw new IllegalStateException(\"Unknown direction: \" + direction);\n            }\n\n            // Check if the cleaning device has hit a barrier.\n            if (isBarrier(x, y)) {\n                break;\n            }\n        }\n\n        // Return the new coordinates of the cleaning device.\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    private boolean isValidDirection(String direction) {\n        return direction.equals(\"no\") || direction.equals(\"ea\") || direction.equals(\"so\") || direction.equals(\"we\");\n    }\n\n    private boolean isBarrier(int x, int y) {\n        for (String barrier : barriers) {\n            String[] coords = barrier.split(\"-\");\n            int x1 = Integer.parseInt(coords[0].substring(1, coords[0].length() - 1));\n            int y1 = Integer.parseInt(coords[1].substring(1, coords[1].length() - 1));\n            int x2 = Integer.parseInt(coords[2].substring(1, coords[2].length() - 1));\n            int y2 = Integer.parseInt(coords[3].substring(1, coords[3].length() - 1));\n\n            if (x >= x1 && x <= x2 && y >= y1 && y <= y2) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}"}, {"source": "bard", "name": "15", "file_name": "Moveable.java", "style": "cc", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "bard", "name": "16", "file_name": "Exercise0.java", "style": "cc", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Exercise0 implements Moveable {\n\n    private static final String DIRECTION_NO = \"no\";\n    private static final String DIRECTION_EA = \"ea\";\n    private static final String DIRECTION_SO = \"so\";\n    private static final String DIRECTION_WE = \"we\";\n\n    private int x = 7;\n    private int y = 7;\n    private int width = 11;\n    private int height = 8;\n    private List<Barrier> barriers = Arrays.asList(\n            new Barrier(2, 1, 10, 1),\n            new Barrier(2, 1, 2, 6),\n            new Barrier(2, 6, 7, 6),\n            new Barrier(10, 1, 10, 8)\n    );\n\n    public String move(String moveCommandString) {\n        String[] parts = moveCommandString.substring(1, moveCommandString.length() - 1).split(\",\");\n        String direction = parts[0];\n        int steps = Integer.parseInt(parts[1]);\n\n        try {\n            switch (direction) {\n                case DIRECTION_NO:\n                    for (int i = 0; i < steps; i++) {\n                        if (y - 1 < 0 || isBarrier(x, y - 1)) {\n                            break;\n                        }\n                        y--;\n                    }\n                    break;\n                case DIRECTION_EA:\n                    for (int i = 0; i < steps; i++) {\n                        if (x + 1 >= width || isBarrier(x + 1, y)) {\n                            break;\n                        }\n                        x++;\n                    }\n                    break;\n                case DIRECTION_SO:\n                    for (int i = 0; i < steps; i++) {\n                        if (y + 1 >= height || isBarrier(x, y + 1)) {\n                            break;\n                        }\n                        y++;\n                    }\n                    break;\n                case DIRECTION_WE:\n                    for (int i = 0; i < steps; i++) {\n                        if (x - 1 < 0 || isBarrier(x - 1, y)) {\n                            break;\n                        }\n                        x--;\n                    }\n                    break;\n            }\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Invalid move command\", e);\n        }\n\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    private boolean isBarrier(int x, int y) {\n        for (Barrier barrier : barriers) {\n            if (barrier.contains(x, y)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static class Barrier {\n        private int x1;\n        private int y1;\n        private int x2;\n        private int y2;\n\n        public Barrier(int x1, int y1, int x2, int y2) {\n            this.x1 = x1;\n            this.y1 = y1;\n            this.x2 = x2;\n            this.y2 = y2;\n        }\n\n        public boolean contains(int x, int y) {\n            return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n        }\n    }\n}"}, {"source": "bard", "name": "16", "file_name": "Moveable.java", "style": "cc", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "bard", "name": "17", "file_name": "Exercise0.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Exercise0 implements Moveable {\n\n    private static final int ROWS = 8;\n    private static final int COLUMNS = 11;\n\n    private static final List<List<Boolean>> BARRIERS = new ArrayList<>();\n    static {\n        for (int i = 0; i < ROWS; i++) {\n            List<Boolean> row = new ArrayList<>();\n            for (int j = 0; j < COLUMNS; j++) {\n                row.add(false);\n            }\n            BARRIERS.add(row);\n        }\n        BARRIERS.get(1).set(0, true);\n        BARRIERS.get(1).set(1, true);\n        BARRIERS.get(1).set(2, true);\n        BARRIERS.get(1).set(3, true);\n        BARRIERS.get(1).set(4, true);\n        BARRIERS.get(1).set(5, true);\n        BARRIERS.get(1).set(6, true);\n        BARRIERS.get(1).set(7, true);\n        BARRIERS.get(1).set(8, true);\n        BARRIERS.get(2).set(0, true);\n        BARRIERS.get(2).set(6, true);\n        BARRIERS.get(7).set(0, true);\n        BARRIERS.get(7).set(8, true);\n    }\n\n    private int x;\n    private int y;\n\n    public Exercise0() {\n        this.x = 7;\n        this.y = 7;\n    }\n\n    @Override\n    public String move(String moveCommandString) {\n        String[] commandParts = moveCommandString.substring(1, moveCommandString.length() - 1).split(\",\");\n        String direction = commandParts[0];\n        int steps = Integer.parseInt(commandParts[1]);\n\n        int newX = x;\n        int newY = y;\n        switch (direction) {\n            case \"no\":\n                newY -= steps;\n                break;\n            case \"ea\":\n                newX += steps;\n                break;\n            case \"so\":\n                newY += steps;\n                break;\n            case \"we\":\n                newX -= steps;\n                break;\n        }\n\n        while (newX < 0 || newX >= COLUMNS || newY < 0 || newY >= ROWS || BARRIERS.get(newY).get(newX)) {\n            steps--;\n            if (steps == 0) {\n                break;\n            }\n            if (direction == \"no\") {\n                newY++;\n            } else if (direction == \"ea\") {\n                newX++;\n            } else if (direction == \"so\") {\n                newY--;\n            } else if (direction == \"we\") {\n                newX--;\n            }\n        }\n\n        if (steps > 0) {\n            x = newX;\n            y = newY;\n        }\n\n        return String.format(\"(%d,%d)\", x, y);\n    }\n}"}, {"source": "bard", "name": "17", "file_name": "Moveable.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "bard", "name": "1", "file_name": "Exercise0.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n\n    private int x = 7;\n    private int y = 7;\n    private int width = 11;\n    private int height = 8;\n    private String[] barriers = {\"(2,1)-(10,1)\", \"(2,1)-(2,6)\", \"(2,6)-(7,6)\", \"(10,1)-(10,8)\"};\n\n    @Override\n    public String move(String moveCommandString) {\n        String[] parts = moveCommandString.substring(1, moveCommandString.length() - 1).split(\",\");\n        String direction = parts[0];\n        int steps = Integer.parseInt(parts[1]);\n\n        if (direction.equals(\"no\")) {\n            for (int i = 0; i < steps; i++) {\n                if (y > 0 && !isBarrier(x, y - 1)) {\n                    y--;\n                } else {\n                    break;\n                }\n            }\n        } else if (direction.equals(\"ea\")) {\n            for (int i = 0; i < steps; i++) {\n                if (x < width - 1 && !isBarrier(x + 1, y)) {\n                    x++;\n                } else {\n                    break;\n                }\n            }\n        } else if (direction.equals(\"so\")) {\n            for (int i = 0; i < steps; i++) {\n                if (y < height - 1 && !isBarrier(x, y + 1)) {\n                    y++;\n                } else {\n                    break;\n                }\n            }\n        } else if (direction.equals(\"we\")) {\n            for (int i = 0; i < steps; i++) {\n                if (x > 0 && !isBarrier(x - 1, y)) {\n                    x--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    private boolean isBarrier(int x, int y) {\n        for (String barrier : barriers) {\n            String[] parts = barrier.replace(\"(\", \"\").replace(\")\", \"\").replace(\",\", \"\").split(\"-\");\n            int x1 = Integer.parseInt(parts[0].substring(1, parts[0].length()));\n            int y1 = Integer.parseInt(parts[0].substring(parts[0].length() - 1));\n            int x2 = Integer.parseInt(parts[1].substring(1, parts[1].length()));\n            int y2 = Integer.parseInt(parts[1].substring(parts[1].length() - 1));\n            if (x >= x1 && x <= x2 && y >= y1 && y <= y2) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"}, {"source": "bard", "name": "1", "file_name": "Moveable.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "bard", "name": "2", "file_name": "Exercise0.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n\n    private int x = 7;\n    private int y = 7;\n    private int width = 11;\n    private int height = 8;\n    private int[][] barriers = {{2, 1, 10, 1}, {2, 1, 2, 6}, {2, 6, 7, 6}, {10, 1, 10, 8}};\n\n    @Override\n    public String move(String moveCommandString) {\n        String[] parts = moveCommandString.substring(1, moveCommandString.length() - 1).split(\",\");\n        String direction = parts[0];\n        int steps = Integer.parseInt(parts[1]);\n\n        if (direction.equals(\"no\")) {\n            for (int i = 0; i < steps; i++) {\n                if (y - 1 < 0 || isBarrier(x, y - 1)) {\n                    break;\n                }\n                y--;\n            }\n        } else if (direction.equals(\"ea\")) {\n            for (int i = 0; i < steps; i++) {\n                if (x + 1 >= width || isBarrier(x + 1, y)) {\n                    break;\n                }\n                x++;\n            }\n        } else if (direction.equals(\"so\")) {\n            for (int i = 0; i < steps; i++) {\n                if (y + 1 >= height || isBarrier(x, y + 1)) {\n                    break;\n                }\n                y++;\n            }\n        } else if (direction.equals(\"we\")) {\n            for (int i = 0; i < steps; i++) {\n                if (x - 1 < 0 || isBarrier(x - 1, y)) {\n                    break;\n                }\n                x--;\n            }\n        }\n\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    private boolean isBarrier(int x, int y) {\n        for (int[] barrier : barriers) {\n            if (x >= barrier[0] && x <= barrier[2] && y >= barrier[1] && y <= barrier[3]) {\n                return true;\n            }\n        }\n\n        // Check if the next position would be inside a barrier.\n        int nextX = x + (direction.equals(\"ea\") ? 1 : (direction.equals(\"we\") ? -1 : 0));\n        int nextY = y + (direction.equals(\"no\") ? -1 : (direction.equals(\"so\") ? 1 : 0));\n        if (nextX >= 0 && nextX < width && nextY >= 0 && nextY < height) {\n            for (int[] barrier : barriers) {\n                if (nextX >= barrier[0] && nextX <= barrier[2] && nextY >= barrier[1] && nextY <= barrier[3]) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n}"}, {"source": "bard", "name": "2", "file_name": "Moveable.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "bard", "name": "3", "file_name": "Exercise0.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n\n    private static final int START_X = 7;\n    private static final int START_Y = 7;\n    private static final int WIDTH = 11;\n    private static final int HEIGHT = 8;\n    private static final int[][] BARRIERS = {{2, 1}, {2, 6}, {7, 6}, {10, 1}, {10, 8}};\n\n    private int x;\n    private int y;\n\n    public Exercise0() {\n        this.x = START_X;\n        this.y = START_Y;\n    }\n\n    @Override\n    public String move(String moveCommandString) {\n        String[] tokens = moveCommandString.replaceAll(\"\\\\[|\\\\]\", \"\").split(\",\");\n        String direction = tokens[0];\n        int steps = Integer.parseInt(tokens[1]);\n\n        for (int i = 0; i < steps; i++) {\n            switch (direction) {\n                case \"no\":\n                    if (y - 1 >= 0 && !isBarrier(x, y - 1)) {\n                        y--;\n                    } else {\n                        break;\n                    }\n                    break;\n                case \"ea\":\n                    if (x + 1 < WIDTH && !isBarrier(x + 1, y)) {\n                        x++;\n                    } else {\n                        break;\n                    }\n                    break;\n                case \"so\":\n                    if (y + 1 < HEIGHT && !isBarrier(x, y + 1)) {\n                        y++;\n                    } else {\n                        break;\n                    }\n                    break;\n                case \"we\":\n                    if (x - 1 >= 0 && !isBarrier(x - 1, y)) {\n                        x--;\n                    } else {\n                        break;\n                    }\n                    break;\n            }\n        }\n\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    private boolean isBarrier(int x, int y) {\n        for (int[] barrier : BARRIERS) {\n            if (barrier[0] == x && barrier[1] == y) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"}, {"source": "bard", "name": "3", "file_name": "Moveable.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "bard", "name": "4", "file_name": "Barrier.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Barrier {\n\n    private int x1;\n    private int y1;\n    private int x2;\n    private int y2;\n\n    public Barrier(int x1, int y1, int x2, int y2) {\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n\n    public int getX1() {\n        return x1;\n    }\n\n    public int getY1() {\n        return y1;\n    }\n\n    public int getX2() {\n        return x2;\n    }\n\n    public int getY2() {\n        return y2;\n    }\n\n    public boolean intersects(int x, int y) {\n        return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n    }\n\n    public int getX() {\n        return (x1 + x2) / 2;\n    }\n\n    public int getY() {\n        return (y1 + y2) / 2;\n    }\n\n}"}, {"source": "bard", "name": "4", "file_name": "Exercise0.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Exercise0 implements Moveable {\n\n    private static final int START_X = 7;\n    private static final int START_Y = 7;\n    private static final int WIDTH = 11;\n    private static final int HEIGHT = 8;\n    private static final List<Barrier> BARRIERS = Arrays.asList(\n            new Barrier(0, 1, 10, 1),\n            new Barrier(0, 1, 2, 6),\n            new Barrier(2, 6, 7, 6),\n            new Barrier(10, 1, 10, 8)\n    );\n\n    private int x;\n    private int y;\n    private int width;\n    private int height;\n    private List<Barrier> barriers;\n\n    public Exercise0() {\n        this(START_X, START_Y, WIDTH, HEIGHT, BARRIERS);\n    }\n\n    public Exercise0(int x, int y, int width, int height, List<Barrier> barriers) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.barriers = barriers;\n    }\n\n    @Override\n    public String move(String moveCommandString) {\n        String[] parts = moveCommandString.split(\",\");\n        String direction = parts[0];\n        int steps = Integer.parseInt(parts[1]);\n\n        if (direction.equals(\"no\")) {\n            y -= steps;\n        } else if (direction.equals(\"ea\")) {\n            x += steps;\n        } else if (direction.equals(\"so\")) {\n            y += steps;\n        } else if (direction.equals(\"we\")) {\n            x -= steps;\n        }\n\n        if (x < 0) {\n            x = 0;\n        } else if (x >= width) {\n            x = width - 1;\n        }\n\n        if (y < 0) {\n            y = 0;\n        } else if (y >= height) {\n            y = height - 1;\n        }\n\n        for (Barrier barrier : barriers) {\n            if (barrier.intersects(x, y)) {\n                x = barrier.getX();\n                y = barrier.getY();\n            }\n        }\n\n        return \"(\" + x + \",\" + y + \")\";\n    }\n}"}, {"source": "bard", "name": "4", "file_name": "Moveable.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "bard", "name": "5", "file_name": "Exercise0.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Exercise0 implements Moveable {\n\n    private int x = 7;\n    private int y = 7;\n    private int width = 11;\n    private int height = 8;\n    private List<java.awt.Point> barriers = new ArrayList<>();\n\n    public Exercise0() {\n        barriers.add(new java.awt.Point(2, 1));\n        barriers.add(new java.awt.Point(10, 1));\n        barriers.add(new java.awt.Point(2, 6));\n        barriers.add(new java.awt.Point(7, 6));\n        barriers.add(new java.awt.Point(10, 8));\n    }\n\n    @Override\n    public String move(String moveCommandString) {\n        String[] tokens = moveCommandString.split(\",\");\n        String direction = tokens[0];\n        int steps = Integer.parseInt(tokens[1]);\n\n        Point newPosition;\n        switch (direction) {\n            case \"no\":\n                newPosition = new Point(x, y - steps);\n                break;\n            case \"ea\":\n                newPosition = new Point(x + steps, y);\n                break;\n            case \"so\":\n                newPosition = new Point(x, y + steps);\n                break;\n            case \"we\":\n                newPosition = new Point(x - steps, y);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid direction: \" + direction);\n        }\n\n        if (isWithinBounds(newPosition) && !isBlocked(newPosition)) {\n            x = newPosition.x;\n            y = newPosition.y;\n            return \"(\" + x + \",\" + y + \")\";\n        } else {\n            return \"Cannot move to \" + newPosition + \".\";\n        }\n    }\n\n    private boolean isWithinBounds(Point point) {\n        return point.x >= 0 && point.x < width && point.y >= 0 && point.y < height;\n    }\n\n    private boolean isBlocked(Point point) {\n        for (Point barrier : barriers) {\n            if (barrier.x == point.x && barrier.y == point.y) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"}, {"source": "bard", "name": "5", "file_name": "Moveable.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "bard", "name": "6", "file_name": "Exercise0.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n\n    private int x = 7;\n    private int y = 7;\n    private int width = 11;\n    private int height = 8;\n    private int[][] barriers = {\n            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 1, 1, 1, 0, 0, 0},\n            {0, 0, 0, 1, 1, 1, 1, 1, 0, 0},\n            {0, 0, 0, 1, 1, 1, 1, 1, 0, 0},\n            {0, 0, 0, 0, 1, 1, 1, 0, 0, 0},\n            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n    };\n\n    public Exercise0() {\n    }\n\n    @Override\n    public String move(String moveCommandString) {\n        String[] parts = moveCommandString.substring(1, moveCommandString.length() - 1).split(\",\");\n        String direction = parts[0];\n        int steps = Integer.parseInt(parts[1]);\n\n        if (direction.equals(\"no\")) {\n            for (int i = 0; i < steps; i++) {\n                if (y - 1 < 0 || barriers[x][y - 1] == 1) {\n                    break;\n                }\n                y--;\n            }\n        } else if (direction.equals(\"ea\")) {\n            for (int i = 0; i < steps; i++) {\n                if (x + 1 >= width || barriers[x + 1][y] == 1) {\n                    break;\n                }\n                x++;\n            }\n        } else if (direction.equals(\"so\")) {\n            for (int i = 0; i < steps; i++) {\n                if (y + 1 >= height || barriers[x][y + 1] == 1) {\n                    break;\n                }\n                y++;\n            }\n        } else if (direction.equals(\"we\")) {\n            for (int i = 0; i < steps; i++) {\n                if (x - 1 < 0 || barriers[x - 1][y] == 1) {\n                    break;\n                }\n                x--;\n            }\n        }\n\n        return \"(\" + x + \",\" + y + \")\";\n    }\n}"}, {"source": "bard", "name": "6", "file_name": "Moveable.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "bard", "name": "7", "file_name": "Exercise0.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n\n    private static final int WIDTH = 11;\n    private static final int HEIGHT = 8;\n    private static final int START_X = 7;\n    private static final int START_Y = 7;\n    private static final int[][] BARRIERS = {{2, 1}, {10, 1}, {2, 6}, {7, 6}, {10, 8}};\n\n    private int x;\n    private int y;\n\n    public Exercise0() {\n        this.x = START_X;\n        this.y = START_Y;\n    }\n\n    @Override\n    public String move(String moveCommandString) {\n        String[] parts = moveCommandString.substring(1, moveCommandString.length() - 1).split(\",\");\n        String direction = parts[0];\n        int steps = Integer.parseInt(parts[1]);\n\n        for (int i = 0; i < steps; i++) {\n            if (direction.equals(\"no\")) {\n                if (y > 0 && y - i < HEIGHT - 1 && !isBarrier(x, y - 1)) {\n                    y--;\n                } else {\n                    break;\n                }\n            } else if (direction.equals(\"ea\")) {\n                if (x < WIDTH - 1 && x + i < WIDTH - 1 && !isBarrier(x + 1, y)) {\n                    x++;\n                } else {\n                    break;\n                }\n            } else if (direction.equals(\"so\")) {\n                if (y < HEIGHT - 1 && y + i < HEIGHT - 1 && !isBarrier(x, y + 1)) {\n                    y++;\n                } else {\n                    break;\n                }\n            } else if (direction.equals(\"we\")) {\n                if (x > 0 && x - i > 0 && !isBarrier(x - 1, y)) {\n                    x--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    private boolean isBarrier(int x, int y) {\n        for (int[] barrier : BARRIERS) {\n            if (x == barrier[0] && y == barrier[1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"}, {"source": "bard", "name": "7", "file_name": "Moveable.java", "style": "plain", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "bard", "name": "8", "file_name": "Exercise0.java", "style": "styled", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n\n        private int x = 7;\n        private int y = 7;\n        private int width = 11;\n        private int height = 8;\n        private String[] barriers = {\"(2,1)-(10,1)\", \"(2,1)-(2,6)\", \"(2,6)-(7,6)\", \"(10,1)-(10,8)\"};\n\n        @Override\n        public String move(String moveCommandString) {\n                // Parse the move command string\n                String[] tokens = moveCommandString.substring(1, moveCommandString.length() - 1).split(\",\");\n                String direction = tokens[0];\n                int steps = Integer.parseInt(tokens[1]);\n\n                // Check if the move is valid\n                if (!isValidMove(direction, steps)) {\n                        return null;\n                }\n\n                // Move the cleaning device\n                switch (direction) {\n                        case \"no\":\n                                for (int i = 0; i < steps; i++) {\n                                        y--;\n                                }\n                                break;\n                        case \"ea\":\n                                for (int i = 0; i < steps; i++) {\n                                        x++;\n                                }\n                                break;\n                        case \"so\":\n                                for (int i = 0; i < steps; i++) {\n                                        y++;\n                                }\n                                break;\n                        case \"we\":\n                                for (int i = 0; i < steps; i++) {\n                                        x--;\n                                }\n                                break;\n                }\n\n                // Return the new location of the cleaning device\n                return \"(\" + x + \",\" + y + \")\";\n        }\n\n        private boolean isValidMove(String direction, int steps) {\n                // Check if the direction is valid\n                if (!direction.equals(\"no\") && !direction.equals(\"ea\") && !direction.equals(\"so\") && !direction.equals(\"we\")) {\n                        return false;\n                }\n\n                // Check if the number of steps is valid\n                if (steps < 1) {\n                        return false;\n                }\n\n                // Check if the move will hit a barrier\n                for (String barrier : barriers) {\n                        String[] coords = barrier.split(\"-\");\n                        int x1 = Integer.parseInt(coords[0].substring(1, coords[0].length()));\n                        int y1 = Integer.parseInt(coords[0].substring(coords[0].length() - 1));\n                        int x2 = Integer.parseInt(coords[1].substring(1, coords[1].length()));\n                        int y2 = Integer.parseInt(coords[1].substring(coords[1].length() - 1));\n                        if (x >= x1 && x <= x2 && y >= y1 && y <= y2) {\n                                return false;\n                        }\n                }\n\n                // The move is valid\n                return true;\n        }\n}"}, {"source": "bard", "name": "8", "file_name": "Moveable.java", "style": "styled", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "bard", "name": "9", "file_name": "Exercise0.java", "style": "styled", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.awt.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Exercise0 implements Moveable {\n\n    private int x = 7;\n    private int y = 7;\n    private int width = 11;\n    private int height = 8;\n    private List<Point> barriers = new ArrayList<>();\n\n    private Point currentLocation;\n\n    public Exercise0() {\n        barriers.add(new Point(2, 1));\n        barriers.add(new Point(10, 1));\n        barriers.add(new Point(2, 6));\n        barriers.add(new Point(7, 6));\n        barriers.add(new Point(10, 8));\n    }\n\n    @Override\n    public String move(String moveCommandString) {\n        // Get the direction and number of steps from the move command string.\n        String[] tokens = moveCommandString.split(\",\");\n        String direction = tokens[0];\n        int steps = Integer.parseInt(tokens[1]);\n\n        // Check if the destination is blocked.\n        Point destination = null;\n        switch (direction) {\n            case \"no\":\n                destination = new Point(x, y - steps);\n                break;\n            case \"ea\":\n                destination = new Point(x + steps, y);\n                break;\n            case \"so\":\n                destination = new Point(x, y + steps);\n                break;\n            case \"we\":\n                destination = new Point(x - steps, y);\n                break;\n        }\n\n        if (isBlocked(destination)) {\n            // If the destination is blocked, find the closest unblocked destination.\n            int dx = destination.x - currentLocation.x;\n            int dy = destination.y - currentLocation.y;\n\n            for (int i = 1; i <= steps; i++) {\n                Point candidate = new Point(currentLocation.x + i * dx, currentLocation.y + i * dy);\n                if (!isBlocked(candidate)) {\n                    destination = candidate;\n                    break;\n                }\n            }\n        }\n\n        // Move the cleaning device to the destination.\n        currentLocation = destination;\n        x = destination.x;\n        y = destination.y;\n\n        // Return the new location of the cleaning device.\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    private boolean isBlocked(Point point) {\n        // Check if the point is outside the space or if it is blocked by a barrier.\n        return point.x < 0 || point.x >= width || point.y < 0 || point.y >= height || barriers.contains(point);\n    }\n\n    private Point getUnblockedDestination(Point currentLocation, Point destination, int steps) {\n        // Get the difference between the current location and the destination.\n        int dx = destination.x - currentLocation.x;\n        int dy = destination.y - currentLocation.y;\n\n        // For each step, check if the next point is unblocked.\n        for (int i = 1; i <= steps; i++) {\n            Point candidate = new Point(currentLocation.x + i * dx, currentLocation.y + i * dy);\n            if (!isBlocked(candidate)) {\n                return candidate;\n            }\n        }\n\n        // If all the steps are blocked, return the current location.\n        return currentLocation;\n    }\n}"}, {"source": "bard", "name": "9", "file_name": "Moveable.java", "style": "styled", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "student", "name": "student1", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n    int x = 7;\n    int y = 7;\n\n    private final Wegberechnung weg = new Wegberechnung();\n\n    @Override\n    public String walkTo(String walkCommandString) {\n\n        System.out.println(walkCommandString);\n\n        String str = walkCommandString.substring(4, walkCommandString.length() - 1);\n        int number = Integer.parseInt(str);\n\n        switch (walkCommandString.charAt(1)) {\n\n            //Mauern zwischen y1-y6 und x2; y1-y11 und x10 |\n            case 'e':\n                x = weg.punktberechnungEast(x, y, number);\n                break;\n\n            case 'w':\n                x = weg.punktberechnungWest(x, y, number);\n                break;\n\n            //Mauern zwischen x2-x10 und y1; x2-x7 und y6 -\n            case 'n':\n                y = weg.punktberechnungNorth(x, y, number);\n                break;\n\n            case 's':\n                y = weg.punktberechnungSouth(x, y, number);\n                break;\n\n            default:\n                return \"Kollege. Wei\u00dft du, was eine Himmelsrichtung ist?\";\n        }\n\n        return \"(\" + x + \",\" + y + \")\";\n    }\n}"}, {"source": "student", "name": "student1", "file_name": "Mauern.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Mauern {\n\n    public List<String> mauernX() {\n\n        List<String> listx = new ArrayList<>();\n        listx.add(\"y1-5,x2\");\n        listx.add(\"y1-10,x10\");\n        return listx;\n    }\n\n    public List<String> mauernY() {\n\n        List<String> listy = new ArrayList<>();\n        listy.add(\"x2-9,y1\");\n        listy.add(\"x2-6,y6\");\n        return listy;\n    }\n\n}\n"}, {"source": "student", "name": "student1", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "student", "name": "student1", "file_name": "Wegberechnung.java", "code": "package thkoeln.st.st2praktikum.exercise;\nimport java.util.List;\nimport static java.lang.System.out;\n\npublic class Wegberechnung {\n\n    private final Mauern mauer = new Mauern();\n    List<String> mauernx = mauer.mauernX();\n    List<String> mauerny = mauer.mauernY();\n\n    public int punktberechnungEast(int x, int y, int number) {\n\n        outerloop:\n        for (int i = 0; i < number; i++) {\n            out.println(\"(\" + x + \",\" + y + \")\");\n            for (String s : this.mauernx) {\n\n                String strx1 = s.substring(1, s.lastIndexOf(\"-\"));\n                String strx2 = s.substring(s.lastIndexOf('-') + 1, s.lastIndexOf(','));\n                String strx3 = s.substring(s.lastIndexOf('x') + 1);\n\n                if (y >= Integer.parseInt(strx1) && y <= Integer.parseInt(strx2) && x == Integer.parseInt(strx3) - 1)\n                    break outerloop;\n\n            }\n            if (x == 10)\n                break;\n            x++;\n        }\n        return x;\n    }\n\n    public int punktberechnungWest(int x, int y, int number) {\n\n        outerloop:\n        for (int i = 0; i < number; i++) {\n            out.println(\"(\" + x + \",\" + y + \")\");\n            for (String s : this.mauernx) {\n\n                String strx1 = s.substring(1, s.lastIndexOf(\"-\"));\n                String strx2 = s.substring(s.lastIndexOf('-') + 1, s.lastIndexOf(','));\n                String strx3 = s.substring(s.lastIndexOf('x') + 1);\n\n                if (y >= Integer.parseInt(strx1) && y <= Integer.parseInt(strx2) && x == Integer.parseInt(strx3))\n                    break outerloop;\n\n            }\n            if (x == 0)\n                break;\n            x--;\n        }\n        return x;\n    }\n\n    public int punktberechnungNorth(int x, int y, int number) {\n\n        outerloop:\n        for (int i = 0; i < number; i++) {\n            out.println(\"(\" + x + \",\" + y + \")\");\n            for (String border : this.mauerny) {\n\n                String stry1 = border.substring(1, border.lastIndexOf(\"-\"));\n                String stry2 = border.substring(border.lastIndexOf('-') + 1, border.lastIndexOf(','));\n                String stry3 = border.substring(border.lastIndexOf('y') + 1);\n\n                if (x >= Integer.parseInt(stry1) && x <= Integer.parseInt(stry2) && y == Integer.parseInt(stry3) - 1)\n                    break outerloop;\n            }\n            if (y == 7)\n                break;\n            y++;\n        }\n        return y;\n    }\n\n    public int punktberechnungSouth(int x, int y, int number) {\n\n        outerloop:\n        for (int i = 0; i < number; i++) {\n            out.println(\"(\" + x + \",\" + y + \")\");\n            for (String border : this.mauerny) {\n\n                String stry1 = border.substring(1, border.lastIndexOf(\"-\"));\n                String stry2 = border.substring(border.lastIndexOf('-') + 1, border.lastIndexOf(','));\n                String stry3 = border.substring(border.lastIndexOf('y') + 1);\n\n                if (x >= Integer.parseInt(stry1) && x <= Integer.parseInt(stry2) && y == Integer.parseInt(stry3))\n                    break outerloop;\n            }\n            if (y == 0)\n                break;\n            y--;\n        }\n        return y;\n    }\n}"}, {"source": "student", "name": "student100", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport javassist.compiler.ast.Pair;\n\nimport java.awt.*;\n\npublic class Exercise0 implements Walkable {\n\n    String Robotposition = new String(\"0,2\");\n\n    @Override\n    public String walk(String walkCommandString) {\n        int xMax = 11;\n        int yMax = 8;\n        boolean stop = false;\n\n\n        String[] wallpositions = {\"3,0\",\"3,1\",\"3,2\",\"5,0\",\"5,1\",\"5,2\",\"5,3\",\"4,5\",\"5,5\",\"6,5\",\"7,5\",\n                                  \"7,6\",\"7,7\",\"7,8\" };\n\n        if(walkCommandString.charAt(1)== 'n') {\n            StringBuilder intXRobotPosition = new StringBuilder();\n            StringBuilder intYRobotPosition = new StringBuilder();\n            StringBuilder integerString = new StringBuilder();\n            StringBuilder intXwallposition = new StringBuilder();\n            StringBuilder intYwallposition = new StringBuilder();\n            for(int i=4; i<walkCommandString.length()-1; i++){\n                integerString.append(walkCommandString.charAt(i));\n            }\n            int steps = Integer.parseInt(integerString.toString());\n            if(Robotposition.charAt(2) != ',') {\n                for (int i = 2; i < Robotposition.length(); i++) {\n                    intYRobotPosition.append(Robotposition.charAt(i));\n                }\n            }\n            if(Robotposition.charAt(2) == ',') {\n                for (int i = 3; i < Robotposition.length(); i++) {\n                    intYRobotPosition.append(Robotposition.charAt(i));\n                }\n            }\n            int RobotYPosition = Integer.parseInt(intYRobotPosition.toString());\n            if(Robotposition.charAt(1) == ',') {\n                intXRobotPosition.append(Robotposition.charAt(0));\n            } else {\n                intXRobotPosition.append(Robotposition.charAt(0));\n                intXRobotPosition.append(Robotposition.charAt(1));\n            }\n            int RobotXPosition = Integer.parseInt(intXRobotPosition.toString());\n\n\n\n            for(int j=1; j<=steps; j++) {\n                int X2Wallposition = 0;\n               for (int i=8; i<=10;i++) {\n                   char int2Xwallposition = wallpositions[i].charAt(0);\n                   int Xwallposition = Integer.parseInt(String.valueOf(int2Xwallposition));\n                   char int2Ywallposition = wallpositions[i].charAt(2);\n                   int Ywallposition = Integer.parseInt(String.valueOf(int2Ywallposition));\n                   if (Ywallposition == RobotYPosition + 1 && Xwallposition == RobotXPosition+1) {\n                       X2Wallposition = RobotXPosition - 1;\n                   }\n               }\n                if(X2Wallposition==0) {\n                    int temp = RobotYPosition + 1;\n                    if (temp <= yMax) {\n                        RobotYPosition += 1;\n                    } else {\n                        break;\n                    }\n                }\n            }\n            Robotposition = RobotXPosition+\",\"+RobotYPosition;\n        }\n        //Osten\n        if(walkCommandString.charAt(1)== 'e') {\n            StringBuilder intXRobotPosition = new StringBuilder();\n            StringBuilder intYRobotPosition = new StringBuilder();\n            StringBuilder integerString = new StringBuilder();\n            for(int i=4; i<walkCommandString.length()-1; i++){\n                integerString.append(walkCommandString.charAt(i));\n            }\n            int steps = Integer.parseInt(integerString.toString());\n\n            if(Robotposition.charAt(2) != ',') {\n                for (int i = 2; i < Robotposition.length(); i++) {\n                    intYRobotPosition.append(Robotposition.charAt(i));\n                }\n            }\n            if(Robotposition.charAt(2) == ',') {\n                for (int i = 3; i < Robotposition.length(); i++) {\n                    intYRobotPosition.append(Robotposition.charAt(i));\n                }\n            }\n            int RobotYPosition = Integer.parseInt(intYRobotPosition.toString());\n            if(Robotposition.charAt(1) == ',') {\n                intXRobotPosition.append(Robotposition.charAt(0));\n            } else {\n                intXRobotPosition.append(Robotposition.charAt(0));\n                intXRobotPosition.append(Robotposition.charAt(1));\n            }\n\n            int RobotXPosition = Integer.parseInt(intXRobotPosition.toString());\n            int X2Wallposition = 0;\n            for(int j=1; j<=steps; j++) {\n\n               for (int i = 0; i <= wallpositions.length-1; i++) {\n                   char int2Xwallposition = wallpositions[i].charAt(0);\n                   int Xwallposition = Integer.parseInt(String.valueOf(int2Xwallposition));\n                   char int2Ywallposition = wallpositions[i].charAt(2);\n                   int Ywallposition = Integer.parseInt(String.valueOf(int2Ywallposition));\n                   if (Ywallposition == RobotYPosition && Xwallposition == RobotXPosition + 1 ||\n                   Ywallposition == RobotYPosition && Xwallposition == RobotXPosition + 1) {\n                       RobotXPosition = Xwallposition-1;\n                       X2Wallposition = RobotXPosition;\n\n                   }\n               }\n                        if(X2Wallposition==0) {\n                            int temp = RobotXPosition + 1;\n                            if (temp <= xMax) {\n                                RobotXPosition += 1;\n                            } else {\n                                break;\n\n                            }\n                        }\n                }\n\n\n            Robotposition = RobotXPosition+\",\"+RobotYPosition;\n\n        }\n        //S\u00fcden\n        if(walkCommandString.charAt(1)== 's') {\n            StringBuilder intXRobotPosition = new StringBuilder();\n            StringBuilder intYRobotPosition = new StringBuilder();\n            StringBuilder integerString = new StringBuilder();\n            for(int i=4; i<walkCommandString.length()-1; i++){\n                integerString.append(walkCommandString.charAt(i));\n            }\n            int steps = Integer.parseInt(integerString.toString());\n            if(Robotposition.charAt(2) != ',') {\n                for (int i = 2; i < Robotposition.length(); i++) {\n                    intYRobotPosition.append(Robotposition.charAt(i));\n                }\n            }\n            if(Robotposition.charAt(2) == ',') {\n                for (int i = 3; i < Robotposition.length(); i++) {\n                    intYRobotPosition.append(Robotposition.charAt(i));\n                }\n            }\n            int RobotYPosition = Integer.parseInt(intYRobotPosition.toString());\n            if(Robotposition.charAt(1) == ',') {\n                intXRobotPosition.append(Robotposition.charAt(0));\n            } else {\n                intXRobotPosition.append(Robotposition.charAt(0));\n                intXRobotPosition.append(Robotposition.charAt(1));\n            }\n            int RobotXPosition = Integer.parseInt(intXRobotPosition.toString());\n\n            for(int j=1; j<=steps; j++) {\n                int X2Wallposition = 0;\n                for (int i = 8; i <= 10; i++) {\n                    char int2Xwallposition = wallpositions[i].charAt(0);\n                    int Xwallposition = Integer.parseInt(String.valueOf(int2Xwallposition));\n                    char int2Ywallposition = wallpositions[i].charAt(2);\n                    int Ywallposition = Integer.parseInt(String.valueOf(int2Ywallposition));\n\n                    if (Ywallposition == RobotYPosition + 1 && Xwallposition == RobotXPosition + 1) {\n                        X2Wallposition = RobotXPosition - 1;\n                        break;\n                    }\n\n                }\n                if(X2Wallposition==0) {\n                    int temp = RobotYPosition - 1;\n                    if (temp >= 0) {\n                        RobotYPosition -= 1;\n                    } else {\n                        break;\n                    }\n                }\n\n            }\n            Robotposition = RobotXPosition+\",\"+RobotYPosition;\n\n        }\n        //Westen\n        if(walkCommandString.charAt(1)== 'w') {\n\n            StringBuilder intXRobotPosition = new StringBuilder();\n            StringBuilder intYRobotPosition = new StringBuilder();\n            StringBuilder integerString = new StringBuilder();\n            for(int i=4; i<walkCommandString.length()-1; i++){\n                integerString.append(walkCommandString.charAt(i));\n            }\n            int steps = Integer.parseInt(integerString.toString());\n            if(Robotposition.charAt(2) != ',') {\n                for (int i = 2; i < Robotposition.length(); i++) {\n                    intYRobotPosition.append(Robotposition.charAt(i));\n                }\n            }\n            if(Robotposition.charAt(2) == ',') {\n                for (int i = 3; i < Robotposition.length(); i++) {\n                    intYRobotPosition.append(Robotposition.charAt(i));\n                }\n            }\n\n            int RobotYPosition = Integer.parseInt(intYRobotPosition.toString());\n            if(Robotposition.charAt(1) == ',') {\n                intXRobotPosition.append(Robotposition.charAt(0));\n            } else {\n                intXRobotPosition.append(Robotposition.charAt(0));\n                intXRobotPosition.append(Robotposition.charAt(1));\n            }\n            int RobotXPosition = Integer.parseInt(intXRobotPosition.toString());\n            int X2Wallposition = 0;\n            for(int j=1; j<=steps; j++) {\n\n                for (int i = 0; i <= wallpositions.length - 1; i++) {\n                    char int2Xwallposition = wallpositions[i].charAt(0);\n                    int Xwallposition = Integer.parseInt(String.valueOf(int2Xwallposition));\n                    char int2Ywallposition = wallpositions[i].charAt(2);\n                    int Ywallposition = Integer.parseInt(String.valueOf(int2Ywallposition));\n                    if (Ywallposition == RobotYPosition && Xwallposition == RobotXPosition - 1 ||\n                            Ywallposition == RobotYPosition && Xwallposition == RobotXPosition - 1) {\n                        RobotXPosition = Xwallposition;\n                        X2Wallposition = RobotXPosition;\n                        RobotYPosition = Ywallposition;\n\n                    }\n                }\n                if (X2Wallposition==0) {\n                    int temp = RobotXPosition - 1;\n                    if (temp >= 0) {\n                        RobotXPosition -= 1;\n                    } else {\n                        break;\n                    }\n                }\n            }\n            Robotposition = RobotXPosition+\",\"+RobotYPosition;\n\n        }\n        return \"(\"+Robotposition+\")\";\n\n    }\n}\n"}, {"source": "student", "name": "student100", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walk(String walkCommandString);\n}\n"}, {"source": "student", "name": "student102", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n\n    int x=8,y=3;\n\n\n\n\n    @Override\n    public String goTo(String goCommandString) {\n\n        char direction=goCommandString.charAt(1);\n        int value=Integer.parseInt(goCommandString.substring(4,5));\n        //System.out.println(\"debut \"+direction+\" val \"+value);\n        System.out.println(\"direction : \"+direction+\" value : \"+value);\n        if(direction=='e') {\n            //first red line\n            if( x<=3 && 1<=y && y<=6){\n                if( (x+value)>3)\n                    x=3;\n                else\n                    x += value;\n            }\n            //second red line\n            if( 4<=x && x<=5 && 2<=y && y<=4){\n                if( (x+value)>5)\n                    x=5;\n                else\n                    x += value;\n                System.out.println(\"hello word\");\n            }\n            //the another case\n            if(6<=x){\n                x+=value;\n            }\n            if( x<=4 && (y==0 || 7<=y) ){\n                x+=value;\n            }\n            if( 4<=x && x<=5 && (y==1 || y>4)){\n                    x += value;\n            }\n        }\n        if(direction=='w') {\n            //first red line west\n            if( 4<=x && x<=6 && 1<=y && y<=7){\n                if( (x-value)<4)\n                    x=4;\n                else\n                    x -= value;\n            }\n            //second red line west\n            if( 6<=x  && 2<=y && y<=4){\n                if( (x-value)<6)\n                    x = 6;\n                else\n                    x -= value;\n            }\n            //The another case\n            if(4<=x && (y==1 || (5<=y && y<=6)  )){\n                if( (x-value)<4) {\n                    x = 4;\n                }\n                else\n                    x-=value;\n            }\n            if(y == 0 || y > 6){\n                x-=value;\n            }\n        }\n        if(direction=='n') {\n            //bottom red line nord\n            if( 6<=x && x<=8 && (y==1 || y==0) ){\n                if( (y+value)>1  )\n                    y=1;\n                else\n                    y += value;\n            }\n            //top red line nord\n            if(6<=x && x<=8 && (1<y && y<5) ){\n                if( (y+value)>4 )\n                    y=4;\n                else\n                    y+=value;\n            }\n            if(x<4 || x==4 || x==5 || 9<=x)\n                y+=value;\n            if(6<=x && x<=8 && 5<=y)\n                y+=value;\n        }\n        if(direction=='s') {\n            //bottom red line\n            if(6<=x && x<=8 && 2<=y && y<=4){\n                if( (y-value)<2 )\n                    y=2;\n                else\n                    y-=value;\n            }\n            //top red line\n            if(6<=x && x<=8 && 5<=y){\n                if( (x-value)<5 ){\n                    y=5;\n                }\n                else\n                    y -= value;\n            }\n            //another case\n            if(x<4 || x==4 || x==5 || 9<=x)\n                y-=value;\n            if(6<=x && x<=8 && y<=1)\n                y-=value;\n        }\n        System.out.println(\"x: \"+x+\" y= \"+y);\n        return \"(\"+x+\",\"+y+\")\";\n    }\n    private boolean check(int firstX,int firstY){\n\n        return true;\n    }\n}\n"}, {"source": "student", "name": "student102", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n\n    String goTo(String goCommandString);\n}\n"}, {"source": "student", "name": "student103", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\n\npublic class Exercise0 implements Moveable {\n\n    //x sit von 0 bis 7\n    private int achseX = 9;\n    //y ist von 0 bis 11\n    private int achseY = 13;\n\n    private int achseXminus1 = achseX-1;\n    private int achseYminus1 = achseY-1;\n\n    private int feld[][] = new int[achseY][achseX];\n\n\n    private int position[] = {5,3};\n\n\n    @Override\n    public String moveTo(String moveCommandString) {\n\n        felden();\n\n        //Extrahieren der Richtung\n        // String richtung = (moveCommandString.substring(1, 3));\n        String richtung = (moveCommandString.substring((moveCommandString.indexOf('[') + 1), (moveCommandString.indexOf(','))));\n        // Extrahieren der Bewegungseinheiten\n        // bewegungseinheiten = Integer.parseInt(moveCommandString.substring(4, 5));\n       int  bewegungseinheiten = Integer.parseInt(moveCommandString.substring((moveCommandString.indexOf(',') + 1), (moveCommandString.indexOf(']'))));\n\n\n        //Kontrollkram, sp\u00e4ter weg\n        /*\n        System.out.println(\"Position  Zeile: \" + position[0]);\n        System.out.println(\"Position  Spalte: \" + position[1]);\n        System.out.println(\"Position Richtung: \" + richtung);\n        System.out.println(\"Position Bewegungseinheiten: \" + bewegungseinheiten);\n         */\n\n        switch (richtung){\n\n\n            case \"no\": {\n\n                /*\n                bewegen nach norden\n\n                -------\n                1.1 pr\u00fcfen, ob ich bereits oben bin\n                1.2 bewegung ist inhalt von position[1] um eine zeile erh\u00f6ht\n                vergleich das mit dem grid, ob da mauer ist\n                wenn ja nicht bewegen\n                wenn nein bewegen\n                ------\n\n                 */\n\n                do{\n\n                //check ob in oberster Zeile also position[1] == 7\n                //statt break auch einfach ien return machen, geht auch\n                if (position[1] == 7) break;\n\n               //     System.out.println(\"Wert position0: \"+position[0]+\" Wert postion1 +1:  \"+(position[1]+1));\n\n                    int temp_feldwert = feld[position[0]][(position[1]+1)];\n                 //   System.out.println(\"Wert temp_feld: \"+temp_feldwert);\n\n\n                    int posplus2=position[1]+2;\n                    if(posplus2>=7) posplus2=7;\n                    int temp_feldwert2 = feld[position[0]][posplus2];\n\n                //    System.out.println(\"Wert temp_feld2: \"+temp_feldwert2);\n\n                    int posplus3=position[1]+1;\n                    if(posplus3>=7) posplus3=7;\n                    int temp_feldwert3 = feld[position[0]+1][posplus3];\n\n                  //  System.out.println(\"Wert temp_feld3: \"+temp_feldwert3);\n\n                if(temp_feldwert==0 ||((temp_feldwert==1 && temp_feldwert2==1)&&(temp_feldwert3==0))){\n                    position[1]=position[1]+1;\n                }else break;\n\n\n                bewegungseinheiten--;\n            } while(bewegungseinheiten>0);\n\n            }break;\n\n\n            //--------------------------------------------------------------------------------\n            //--------------------------------------------------------------------------------\n            //--------------------------------------------------------------------------------\n            //--------------------------------------------------------------------------------\n\n\n            case \"ea\":{\n\n                do{\n\n                    //statt break auch einfach ien return machen, geht auch\n                    if (position[0] == 11) break;\n\n                //    System.out.println(\"Wert position0 +1:   \"+(position[0]+1)+\" Wert postion1: \"+(position[1]));\n\n                    int temp_feldwert = feld[position[0]+1][(position[1])];\n              //      System.out.println(\"Wert temp_feld: \"+temp_feldwert);\n\n                    int posplus2=position[0]+2;\n                    if(posplus2>=11) posplus2=10;\n                    int temp_feldwert2 = feld[posplus2][(position[1])];\n\n              //      System.out.println(\"Wert temp_feld2: \"+temp_feldwert2);\n\n                    if(temp_feldwert==0 || (temp_feldwert==1 && temp_feldwert2==1) ){\n                        position[0]=position[0]+1;\n                    }else break;\n\n\n                    bewegungseinheiten--;\n                } while(bewegungseinheiten>0);\n\n\n\n            }break;\n\n            //--------------------------------------------------------------------------------\n            //--------------------------------------------------------------------------------\n            //--------------------------------------------------------------------------------\n            //--------------------------------------------------------------------------------\n\n\n            case \"we\":{\n\n                do{\n\n                    //statt break auch einfach ien return machen, geht auch\n                    if (position[0] == 0) break;\n\n                //    System.out.println(\"Wert position0 -1:   \"+(position[0]-1)+\" Wert postion1: \"+(position[1]));\n\n                    int temp_feldwert = feld[position[0]-1][(position[1])];\n\n               //     System.out.println(\"Wert temp_feld: \"+temp_feldwert);\n\n\n                    int posplus2=position[0]-2;\n                    if(posplus2<=0) posplus2=0;\n                    int temp_feldwert2 = feld[posplus2][(position[1])];\n\n                   // System.out.println(\"Wert temp_feld2: \"+temp_feldwert2);\n\n                    int posplus3=position[1]-1;\n                    if(posplus3<=0) posplus3=0;\n                    int temp_feldwert3 = feld[position[0]-1][posplus3];\n\n                   // System.out.println(\"Wert temp_feld3: \"+temp_feldwert3);\n\n\n                    boolean temp1 =temp_feldwert==0;\n                    boolean temp2 =(temp_feldwert==1 && temp_feldwert2==1);\n                    boolean temp3 =temp_feldwert2==0;\n                    boolean temp4=(temp_feldwert==1&&temp_feldwert3==1);\n\n                    if((temp1 || temp2) || temp4 || temp3){\n                        if(temp3 && temp4) {\n                            position[0]=position[0]-1;\n                            break;\n                        }\n\n                        position[0]=position[0]-1;\n                    }else break;\n\n                    bewegungseinheiten--;\n                } while(bewegungseinheiten>0);\n\n            }break;\n\n\n            //--------------------------------------------------------------------------------\n            //--------------------------------------------------------------------------------\n            //--------------------------------------------------------------------------------\n            //--------------------------------------------------------------------------------\n\n\n\n            case \"so\":{\n\n                do{\n\n                    if (position[1] == 0) break;\n\n           //         System.out.println(\"Wert position0: \"+position[0]+\" Wert postion1 -1:  \"+(position[1]-1));\n\n                    int temp_feldwert = feld[position[0]][(position[1]-1)];\n\n                  //  System.out.println(\"Wert temp_feld: \"+temp_feldwert);\n\n                    if(temp_feldwert==0){\n                        position[1]=position[1]-1;\n                    }else break;\n\n                    bewegungseinheiten--;\n                } while(bewegungseinheiten>0);\n\n            }break;\n\n\n            default:{\n                System.out.println(\"Keine richtige Richtung zum richten, \\ndamit ist das Richten der Richtung nicht m\u00f6glich\");\n            }break;\n\n        }\n        return (\"(\"+position[0]+\",\"+position[1]+\")\");\n    }\n\n\n\n    public void felden(){\n\n        for (int x = 0; x < achseY; x++) {\n            for (int y = 0; y < achseX; y++) {\n                feld[x][y]=0;\n\n                //Wand Zeilen nur Norden S\u00fcden abfragen als Horizontal\n                //  wand1 = \"(1,6)-(5,6)\";\n                // wand2 = \"(3,3)-(8,3)\";\n\n                //Wand Spalten Nur Osten Westen abfragen also Vertikal\n                // wand3 = \"(6,2)-(6,7)\";\n                //  wand4 = \"(4,1)-(4,2)\";\n\n\n                //Wand1\n                if((y==6)&&((x>=1)&&(x<=5))) feld[x][y]=1;\n                //Wande2\n                if((y==3)&&((x>=3)&&(x<=8))) feld[x][y]=1;\n\n\n                //Wand3\n                if((x==6)&&((y>=2)&&(y<=7))) feld[x][y]=1;\n                //Wand4\n                if((x==4)&&((y>=1)&&(y<=2))) feld[x][y]=1;\n            }\n        }\n    }\n}\n"}, {"source": "student", "name": "student103", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String moveTo(String moveCommandString);\n}\n"}, {"source": "student", "name": "student104", "file_name": "Dot.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Dot\n{\n    private Field here;\n\n    public Dot(Field f)\n    {\n        here=f;\n    }\n\n    public Field getHere() {\n        return here;\n    }\n\n    public void setHere(Field here) {\n        this.here = here;\n    }\n}\n"}, {"source": "student", "name": "student104", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble\n{\n    private Dot dot;\n    private Field[][] field;\n    private Wall[] walls;\n\n    public Exercise0()\n    {\n        walls=new Wall[8];\n        walls[0]=new Wall(3,0,3,2);\n        walls[1]=new Wall(0,2,2,2);\n        walls[2]=new Wall(1,3,9,3);\n        walls[3]=new Wall(9,3,9,7);\n        walls[4]=new Wall(0,0,11,0);\n        walls[5]=new Wall(0,0,0,8);\n        walls[6]=new Wall(11,0,11,8);\n        walls[7]=new Wall(0,8,11,8);\n\n        field=new Field[11][8];\n        for (int a=0; a<11; a++)\n        {\n            for (int b=0; b<8; b++)\n            {\n                field[a][b]=new Field(a,b);\n            }\n        }\n\n        for (Wall w:walls)\n        {\n            if(w.getStartY()==w.getEndY())\n            {\n                System.out.println(\"Horizontal wall\");\n                for (int i = w.getStartX(); i < w.getEndX(); i++)\n                {\n                    if(w.getStartY()!=8)\n                    {\n                        field[i][w.getStartY()].setWalls(true, 0);\n                        System.out.println(\"Field \"+i+\"/\"+w.getStartY()+\" marked with upper wall\");\n                    }\n                    if(w.getStartY()-1!=-1)\n                    {\n                        field[i][w.getStartY()-1].setWalls(true, 2);\n                        System.out.println(\"Field \"+i+\"/\"+(w.getStartY()-1)+\" marked with lower wall\");\n                    }\n                }\n            }\n            else\n            {\n                System.out.println(\"Vertical wall\");\n                for (int i = w.getStartY(); i < w.getEndY(); i++)\n                {\n                    if(w.getStartX()!=11)\n                    {\n                        field[w.getStartX()][i].setWalls(true, 3);\n                        System.out.println(\"Field \"+w.getStartX()+\"/\"+i+\" marked with left wall\");\n                    }\n                    if(w.getStartX()>0)\n                    {\n                        field[w.getStartX()-1][i].setWalls(true, 1);\n                        System.out.println(\"Field \"+(w.getStartX()-1)+\"/\"+i+\" marked with right wall\");\n                    }\n                }\n            }\n        }\n        dot=new Dot(field[1][1]);\n    }\n\n    public void step(String dir)\n    {\n        System.out.println(\"Dot at \"+dot.getHere().getX()+\"/\"+dot.getHere().getY());\n        if (!dot.getHere().getWall(dir))\n        {\n            System.out.println(\"No obstacle at \"+dir);\n            switch (dir)\n            {\n                case \"no\":\n                    System.out.println(\"Moving no now.\");\n                    dot.setHere(field[dot.getHere().getX()][dot.getHere().getY()-1]);\n                    break;\n                case \"ea\":\n                    System.out.println(\"Moving ea now.\");\n                    dot.setHere(field[dot.getHere().getX()+1][dot.getHere().getY()]);\n                    break;\n                case \"so\":\n                    System.out.println(\"Moving so now.\");\n                    dot.setHere(field[dot.getHere().getX()][dot.getHere().getY()+1]);\n                    break;\n                case \"we\":\n                    System.out.println(\"Moving we now.\");\n                    dot.setHere(field[dot.getHere().getX()-1][dot.getHere().getY()]);\n                    break;\n            }\n            System.out.println(\"Dot at \"+dot.getHere().getX()+\"/\"+dot.getHere().getY());\n        }\n        else\n        {\n            System.out.println(\"Obstacle detected at \"+dir+\". Not moving.\");\n        }\n    }\n\n\n    @Override\n    public String go(String goCommandString) {\n        String s = goCommandString.substring(1, goCommandString.length() - 1);\n        String[] input = s.split(\",\");\n\n        String dir = input[0];\n        int steps = Integer.parseInt(input[1]);\n\n        for (int i = 0; i < steps; i++)\n        {\n            step(dir);\n        }\n\n        System.out.println(\"Dot finally at \"+dot.getHere().getX()+\"/\"+dot.getHere().getY());\n        int x=dot.getHere().getX();\n        int flipY=7-dot.getHere().getY();\n        System.out.println(\"Position converted to \"+x+\"/\"+flipY);\n\n        return \"(\" + x + \",\" + flipY + \")\" ;\n    }\n}\n"}, {"source": "student", "name": "student104", "file_name": "Field.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Field\n{\n    private boolean obstacle;\n    private boolean[] walls;\n    private int x;\n    private int y;\n\n    public Field(int a, int b)\n    {\n        x=a;\n        y=b;\n        obstacle = false;\n\n        walls=new boolean[4];\n\n        walls[0]=false;\n        walls[1]=false;\n        walls[2]=false;\n        walls[3]=false;\n\n    }\n\n    public boolean isObstacle() {\n        return obstacle;\n    }\n\n    public void setObstacle(boolean obstacle) {\n        this.obstacle = obstacle;\n    }\n\n    public boolean getWall(String dir) {\n        switch (dir)\n        {\n            case \"no\":\n                return walls[0];\n            case \"ea\":\n                return walls[1];\n            case \"so\":\n                return walls[2];\n            case \"we\":\n                return walls[3];\n            default:\n                return true;\n        }\n    }\n\n    public void setWalls(boolean state, int dir) {\n        walls[dir]=state;\n        if (state=true)\n        {\n            obstacle=true;\n        }\n        //if state false check for other walls\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n}\n"}, {"source": "student", "name": "student104", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String go(String goCommandString);\n}\n"}, {"source": "student", "name": "student104", "file_name": "Wall.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Wall\n{\n    private int startX;\n    private int startY;\n    private int endX;\n    private int endY;\n\n    public Wall(int a, int b, int c, int d)\n    {\n        startX=a;\n        startY=b;\n        endX=c;\n        endY=d;\n    }\n\n    public int getStartX() {\n        return startX;\n    }\n\n    public int getStartY() {\n        return startY;\n    }\n\n    public int getEndX() {\n        return endX;\n    }\n\n    public int getEndY() {\n        return endY;\n    }\n}\n"}, {"source": "student", "name": "student105", "file_name": "Barrier.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Barrier {\n\n    Point p1;\n    Point p2;\n    Direction direction;\n\n    public Barrier(Point p1, Point p2) {\n        if (p1.x == p2.x) {\n            this.direction = Direction.NORTH;\n        } else {\n            this.direction = Direction.EAST;\n        }\n        this.p1 = p1;\n        this.p2 = p2;\n    }\n\n    public boolean collides(Command c) {\n        Direction moveDirection = c.direction;\n\n        // Cannot collide if moving parallel to the barrier\n        if (isParallel(direction, moveDirection)) {\n            return false;\n        }\n\n        switch (moveDirection) {\n            case EAST: if (c.to.x == p1.x && c.to.y >= p1.y && c.to.y < p2.y) return true;           break;\n            case WEST: if (c.from.x == p1.x && c.to.y >= p1.y && c.to.y < p2.y) return true;         break;\n            case NORTH: if (c.to.y == p1.y && c.to.x >= p1.x && c.to.x < p2.x) return true;          break;\n            case SOUTH: if (c.from.y == p1.y && c.to.x >= p1.x && c.to.x < p2.x) return true;        break;\n        }\n\n        return false;\n    }\n\n    private boolean isParallel(Direction barrierDirection, Direction moveDirection) {\n        if (barrierDirection == Direction.EAST && ( moveDirection == Direction.EAST ||moveDirection == Direction.WEST))\n            return true;\n        else return barrierDirection == Direction.NORTH && (moveDirection == Direction.NORTH || moveDirection == Direction.SOUTH);\n    }\n\n}\n"}, {"source": "student", "name": "student105", "file_name": "Command.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Command {\n    Point from;\n    Point to;\n    Direction direction;\n\n    public Command(Point from, Point to) {\n        this.from = from;\n        this.to = to;\n\n        if (to.x > from.x) {\n            direction = Direction.EAST;\n        } else if (to.x < from.x) {\n            direction = Direction.WEST;\n        } else if (to.y > from.y) {\n            direction = Direction.NORTH;\n        } else if (to.y < from.y) {\n            direction = Direction.SOUTH;\n        } else {\n            throw new RuntimeException(\"Not a valid move\");\n        }\n    }\n}\n"}, {"source": "student", "name": "student105", "file_name": "Direction.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic enum Direction {\n    NORTH, EAST, SOUTH, WEST\n}\n"}, {"source": "student", "name": "student105", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Exercise0 implements Moveable {\n\n    final int DECK_WIDTH = 11;\n    final int DECK_HEIGHT = 7;\n\n    ArrayList<Barrier> barriers = new ArrayList<>();\n\n    Point position;\n\n    public Exercise0() {\n        barriers.add(new Barrier(new Point(1, 4), new Point(8, 4)));\n        barriers.add(new Barrier(new Point(4, 3), new Point(7, 3)));\n        barriers.add(new Barrier(new Point(3, 0), new Point(3, 3)));\n        barriers.add(new Barrier(new Point(7, 0), new Point(7, 2)));\n        position = new Point(3, 0);\n        System.out.println(\"reset position\");\n    }\n\n    @Override\n    public String moveTo(String moveCommandString) {\n        Command command = parseCommandString(moveCommandString);\n        ArrayList<Command> commands = getSingleSteps(command);\n        Point endPos = null;\n        for (Command c : commands) {\n            for (Barrier b : barriers) {\n                if (b.collides(c)) {\n                    endPos = c.from;\n                }\n            }\n        }\n        if (endPos == null) endPos = command.to;\n        position = endPos;\n        return endPos.toString();\n    }\n\n    private Command parseCommandString(String moveCommandString) {\n        Pattern p = Pattern.compile(\"\\\\[([a-z]{2}),([\\\\d]*)\\\\]\");\n        Matcher matcher = p.matcher(moveCommandString);\n\n        Command c;\n        if (matcher.matches()) {\n            String directionString = matcher.group(1).toLowerCase();\n            int length = Integer.parseInt(matcher.group(2));\n\n            if (directionString.startsWith(\"n\")) {\n                c = new Command(position, new Point(position.x, position.y + length));\n            } else if (directionString.startsWith(\"s\")) {\n                c = new Command(position, new Point(position.x, position.y - length));\n            } else if (directionString.startsWith(\"e\")) {\n                c = new Command(position, new Point(position.x + length, position.y));\n            } else if (directionString.startsWith(\"w\")) {\n                c = new Command(position, new Point(position.x - length, position.y));\n            } else {\n                throw new RuntimeException(\"Could not parse command direction: \" + directionString);\n            }\n        } else {\n            throw new RuntimeException(\"Could not parse commandString: \" + moveCommandString);\n        }\n\n        if (c.to.x > DECK_WIDTH) {\n            c.to.x = DECK_WIDTH;\n        } else if (c.to.x < 0) {\n            c.to.x = 0;\n        }\n        if (c.to.y > DECK_HEIGHT) {\n            c.to.y = DECK_HEIGHT;\n        } else if (c.to.y < 0) {\n            c.to.y = 0;\n        }\n\n        return c;\n    }\n\n    private ArrayList<Command> getSingleSteps(Command c) {\n        ArrayList<Command> commands = new ArrayList<>(11);\n        switch (c.direction) {\n            case NORTH:\n                for (int i = c.from.y; i < c.to.y; i++) {\n                    commands.add(new Command(new Point(c.from.x, i), new Point(c.to.x, i + 1)));\n                }\n                break;\n            case SOUTH:\n                for (int i = c.from.y; i >= c.to.y; i--) {\n                    commands.add(new Command(new Point(c.from.x, i), new Point(c.from.x, i - 1)));\n                }\n                break;\n            case EAST:\n                for (int i = c.from.x; i < c.to.x; i++) {\n                    commands.add(new Command(new Point(i, c.from.y), new Point(i + 1, c.to.y)));\n                }\n                break;\n            case WEST:\n                for (int i = c.from.x; i >= c.to.x; i--) {\n                    commands.add(new Command(new Point(i, c.from.y), new Point(i - 1, c.from.y)));\n                }\n                break;\n        }\n        return commands;\n    }\n}\n"}, {"source": "student", "name": "student105", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String moveTo(String moveCommandString);\n}\n"}, {"source": "student", "name": "student105", "file_name": "Point.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Point {\n    public int x;\n    public int y;\n\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + x + \",\" + y + \")\";\n    }\n}\n"}, {"source": "student", "name": "student106", "file_name": "Direction.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic enum Direction {\n    no,ea,so,we;\n}\n"}, {"source": "student", "name": "student106", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n    Grid myMap= new Grid();\n\n    @Override\n    public String move(String moveCommandString) {\n       int lastX = myMap.getX();\n       int lastY = myMap.getY();\n\n        //check format [Direction,number]\n        if (checkFormatMoveComandString(moveCommandString)) {\n            //Seperate the parts of the command into the Direction and the number of tiles to move\n            String[] commands = moveCommandString.replace(\"[\", \"\").replace(\"]\", \"\").split(\",\");\n\n            //turn the Sting into a Direction\n            Direction direc = Direction.valueOf(commands[0]);\n\n            int number = Integer.parseInt(commands[1]);\n\n            //now move accordingly:\n            switch (direc){\n                case no: myMap.setY(myMap.getY()+number); break;\n                case ea: myMap.setX(myMap.getX()+number); break;\n                case so: myMap.setY(myMap.getY()-number); break;\n                case we: myMap.setX(myMap.getX()-number); break;\n            }\n\n            myMap.checkForWallsInTheWay(direc,lastX,lastY);\n        }\n        return myMap.getPosition();\n    }\n\n    private boolean checkFormatMoveComandString (String moveCommandString){\n        // TODO: checkFormatMoveComandString\n        return true;\n    }\n}\n"}, {"source": "student", "name": "student106", "file_name": "Grid.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Grid {\n    //coordinates\n    private int x=1;\n    private int y=6;\n\n    //boardes of the field\n    final int maxX=11;\n    final int maxY=8;\n\n    //contains a list with walls. A wall is a list of coordinats\n    // Von welcher Himmerlrichtung laufe ich dr\u00fcber?\n    // Nachher standort berrechnen und dann vgl. ob eine Mauer dazwischen ist.\n    final int[] wallHorizontalSo1 = {0,1,5}; //von x bis x bei y\n    final int[] wallHorizontalNo1 = {0,1,6}; //von x bis x bei y\n    final int[] wallHorizontalSo2 = {1,8,4}; //von x bis x bei y\n    final int[] wallHorizontalNo2 = {1,8,5}; //von x bis x bei y\n\n    final int[] wallVerticalEa1 = {1,4,9}; //von y bis y bei x\n    final int[] wallVerticalWe1 = {1,4,8}; //von y bis y bei x\n    final int[] wallVerticalEa2 = {6,7,3}; //von y bis y bei x\n    final int[] wallVerticalWe2 = {6,7,2}; //von y bis y bei x\n\n    public void setX(int x) {\n        if (x<0) this.x=0;\n        else if (x>=maxX) this.x=10;\n        else this.x = x;\n    }\n\n    public void setY(int y) {\n        if (y<0) this.y=0;\n        else if (y>=maxY) this.y=7;\n        else this.y = y;\n    }\n\n    public int getX() {\n        return this.x;\n    }\n\n    public int getY() {\n        return this.y;\n    }\n\n    public void checkForWallsInTheWay(Direction direc, int lastX, int lastY){\n            switch (direc){\n                case no:\n                    //check if X could hit a wall\n                    if (this.x>=wallHorizontalNo1[0] && this.x<=wallHorizontalNo1[1]){\n                        //if Yes check if wall is between old and new Y\n                        if (lastY<wallHorizontalNo1[2] && this.y>=wallHorizontalNo1[2]){\n                            //if Yes correct position\n                            setY(wallHorizontalNo1[2]-1);\n                        }\n                    }\n                    //check if X could hit a wall\n                    if (this.x>=wallHorizontalNo2[0] && this.x<=wallHorizontalNo2[1]){\n                        //if Yes check if wall is between old and new Y\n                        if (lastY<wallHorizontalNo2[2] && this.y>=wallHorizontalNo2[2]){\n                            //if Yes correct position\n                            setY(wallHorizontalNo2[2]-1);\n                        }\n                    }\n                case ea:\n                    //check if Y could hit a wall\n                    if (this.y>=wallVerticalEa1[0] && this.y<=wallVerticalEa1[1]){\n                        //if Yes check if wall is between old and new X\n                        if (lastX<wallVerticalEa1[2] && this.x>=wallVerticalEa1[2]){\n                            //if Yes correct position\n                            setX(wallVerticalEa1[2]+1);\n                        }\n                    }\n                    //check if Y could hit a wall\n                    if (this.y>=wallVerticalEa2[0] && this.y<=wallVerticalEa2[1]){\n                        //if Yes check if wall is between old and new X\n                        if (lastX<wallVerticalEa2[2] && this.x>=wallVerticalEa2[2]){\n                            //if Yes correct position\n                            setX(wallVerticalEa2[2]-1);\n                        }\n                    }\n                case so:\n                    //check if X could hit a wall\n                    if (this.x>=wallHorizontalSo1[0] && this.x<=wallHorizontalSo1[1]){\n                        //if Yes check if wall is between old and new Y\n                        if (this.y<=wallHorizontalSo1[2] && lastY>wallHorizontalSo1[2]){\n                            //if Yes correct position\n                            setY(wallHorizontalSo1[2]+1);\n                        }\n                    }\n                    //check if X could hit a wall\n                    if (this.x>=wallHorizontalSo2[0] && this.x<=wallHorizontalSo2[1]){\n                        //if Yes check if wall is between old and new Y\n                        if (this.y<=wallHorizontalSo2[2] && lastY>wallHorizontalSo2[2]){\n                            //if Yes correct position\n                            setY(wallHorizontalSo2[2]+1);\n                        }\n                    }\n                case we:\n                    //check if Y could hit a wall\n                    if (this.y>=wallVerticalWe1[0] && this.y<=wallVerticalWe1[1]){\n                        //if Yes check if wall is between old and new X\n                        if (this.x<=wallVerticalWe1[2] && lastX>wallVerticalWe1[2]){\n                            //if Yes correct position\n                            setX(wallVerticalWe1[2]+1);\n                        }\n                    }\n                    //check if Y could hit a wall\n                    if (this.y>=wallVerticalWe2[0] && this.y<=wallVerticalWe2[1]){\n                        //if Yes check if wall is between old and new X\n                        if (this.x<=wallVerticalWe2[2] && lastX>wallVerticalWe2[2]){\n                            //if Yes correct position\n                            setX(wallVerticalWe2[2]+1);\n                        }\n                    }\n\n            }\n    }\n\n    public String getPosition() {\n        return (\"(\" + x + \",\" + y + \")\");\n    }\n}\n"}, {"source": "student", "name": "student106", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "student", "name": "student107", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * TODO Basic Object \u2714\n * TODO Command Parser \u2714\n * TODO Movement Detection \u2714\n * TODO Apply Movement \u2714\n * TODO Collision detection \u2714\n *\n * TODO OPTIONAL STUFF\n *\n**/\n\npublic class Exercise0 implements Moveable {\n\n\n    private Coordinate robotcoordinate;\n    private List<Obstacle> obstacles = new ArrayList<Obstacle>();\n    private int areax;\n    private int areay;\n\n\n\n    public Exercise0() {\n        //START POINT\n        this.robotcoordinate = new Coordinate(7,7);\n        //DIMENSION | Obstacle\n        this.areax = 11;\n        this.areay = 8;\n\n        this.genobstacle(new Coordinate(2,6) , new Command(\"ea\", 5));\n        this.genobstacle(new Coordinate(2,1) , new Command(\"no\", 5));\n        this.genobstacle(new Coordinate(2,1) , new Command(\"ea\", 8));\n        this.genobstacle(new Coordinate(10,1) , new Command(\"no\", 7));\n    }\n\n    public Exercise0(int x , int y){\n    this();\n    this.robotcoordinate = new Coordinate(x,y);\n    }\n\n    public void genobstacle(Coordinate cord){\n        this.obstacles.add(new Obstacle(new Command(\"static\" , 0 ) , cord));\n\n    }\n\n    public void genobstacle(Coordinate cordstart , Command command ){\n        Coordinate tmpCoordinate = new Coordinate(cordstart.getX(), cordstart.getY());\n\n            this.obstacles.add(new Obstacle(command , cordstart));\n        }\n\n\n    //COMMAND : [DIRECTION,DISTANCE]\n    @Override\n    public String move(String moveCommandString) {\n\n        Command command = this.commandparser(moveCommandString);\n        boolean breakpoint = false;\n        Coordinate tmpCoordinate = new Coordinate(robotcoordinate.getX(), robotcoordinate.getY());\n        Coordinate saved = new Coordinate(tmpCoordinate.getX(), tmpCoordinate.getY());;\n        String commanddir = command.getDirection();\n        for(int i = command.getDistance(); i>= 0 & !breakpoint ; i-- ){\n            saved.setX(tmpCoordinate.getX());\n            saved.setY(tmpCoordinate.getY());\n            switch (command.getDirection()){\n                case \"no\":\n                    tmpCoordinate.setY(tmpCoordinate.getY() + 1);\n                    break;\n                case \"ea\":\n                    tmpCoordinate.setX(tmpCoordinate.getX() + 1);\n                    break;\n                case \"so\":\n                    tmpCoordinate.setY(tmpCoordinate.getY() - 1);\n                    break;\n                case \"we\":\n                    tmpCoordinate.setX(tmpCoordinate.getX() - 1);\n                    break;\n            }\n            //Check if it touches border | only when coordinate is in the area\n            if(tmpCoordinate.getX() >= 0 & tmpCoordinate.getX() < this.areax & tmpCoordinate.getY() >= 0 & tmpCoordinate.getY() < this.areay){\n                //Check if Coordinate is not colliding with any obstacle\n\n                for (Obstacle c: this.obstacles\n                     ) {\n                    //horizontal border | moving down (south) |\n                    if((c.command.getDirection().equals(\"we\") || c.command.getDirection().equals(\"ea\")) && (commanddir.equals(\"so\") || commanddir.equals(\"no\")) ){\n//                        System.out.println(\"    Checking WE | EA\");\n                        for(int j = c.command.getDistance(); j >= 0 ; j--){\n                            //west movement\n                            if(c.command.getDirection().equals(\"we\")){\n                                //not startpoint\n//                                System.out.println(\"        Checking WE\");\n                                if(j != 0){\n                                    if(c.anchor.getX() - j == tmpCoordinate.getX() && ((c.anchor.getY() == tmpCoordinate.getY() && commanddir.equals(\"no\")) || (c.anchor.getY()-1 == tmpCoordinate.getY() && commanddir.equals(\"so\"))) ){\n//                                        System.out.println(\"            Collision\");\n                                        breakpoint = true;\n                                    }\n                                }\n                            }\n                            //east movement\n                            else if(c.command.getDirection().equals(\"ea\")){\n                                //not endpoint\n//                                System.out.println(\"        Checking EA\");\n                                if(j != c.command.getDistance()){\n                                    if(c.anchor.getX() + j == tmpCoordinate.getX() && ((c.anchor.getY() == tmpCoordinate.getY() && commanddir.equals(\"no\")) || (c.anchor.getY()-1 == tmpCoordinate.getY() && commanddir.equals(\"so\")))){\n//                                        System.out.println(\"            Collision\");\n                                        breakpoint = true;\n                                    }\n                                }\n                            }\n                        }\n                    }else if((c.command.getDirection().equals(\"no\") || c.command.getDirection().equals(\"so\")) && (commanddir.equals(\"ea\") || commanddir.equals(\"we\")) ){\n\n//                        System.out.println(\"    Checking NO | SO\");\n                        for(int j = c.command.getDistance(); j >= 0 ; j--){\n\n                            //no movement\n                            if(c.command.getDirection().equals(\"so\")){\n                                //not startpoint\n//                                System.out.println(\"        Checking SO\");\n                                if(j != 0){\n                                    if(c.anchor.getY() - j == tmpCoordinate.getY() && ((c.anchor.getX()  == tmpCoordinate.getX() && commanddir.equals(\"ea\")) || (c.anchor.getX()-1 == tmpCoordinate.getX() && commanddir.equals(\"we\"))) ){\n                                        breakpoint = true;\n                                    }\n                                }\n                            }\n                            //so movement\n                            else if(c.command.getDirection().equals(\"no\")){\n                                //not endpoint\n//                                System.out.println(\"        Checking NO\");\n                                if(j != c.command.getDistance()){\n                                    if(c.anchor.getY() + j == tmpCoordinate.getY() && ((c.anchor.getX() == tmpCoordinate.getX() && commanddir.equals(\"ea\")) || (c.anchor.getX()-1 == tmpCoordinate.getX() && commanddir.equals(\"we\")))){\n                                        breakpoint = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                }\n            }else {\n//                System.out.println(\"    border collision\");\n                breakpoint = true;\n\n            }\n\n        }\n\n    this.robotcoordinate.setX(saved.getX());\n    this.robotcoordinate.setY(saved.getY());\n        return \"(\" + this.robotcoordinate.getX() + \",\" +this.robotcoordinate.getY() + \")\"\n;\n        //throw new UnsupportedOperationException();\n\n\n    }\n\n    private Command commandparser(String commandstring) {\n\n        String direction;\n        int distance;\n\n        String[] values= commandstring.replace(\"[\",\"\").replace(\"]\",\"\").split(\",\");\n        System.out.println(values[0]);\n        System.out.println(values[1]);\n        direction = values[0];\n        distance = Integer.parseInt(values[1]);\n\n        return new Command(direction,distance);\n    }\n\n\n    private class Obstacle{\n\n        private Command command;\n        private Coordinate anchor;\n\n        Obstacle(){\n            this.command = null;\n            this.command = null;\n        }\n\n        Obstacle(Command command , Coordinate anchor){\n            this.command = command;\n            this.anchor = anchor;\n        }\n\n        public Coordinate endcord(){\n            switch (this.command.getDirection()){\n                case \"static\":\n                    return this.anchor;\n                case \"no\":\n                    return new Coordinate(this.anchor.getX(),+this.anchor.getY()+this.command.distance);\n                case \"ea\":\n                    return new Coordinate(this.anchor.getX()+this.command.distance,this.anchor.getY());\n\n                case \"we\":\n                    return new Coordinate(this.anchor.getX()-this.command.distance,this.anchor.getY());\n\n                case \"so\":\n                    return new Coordinate(this.anchor.getX(),+this.anchor.getY()-this.command.distance);\n                default:\n                    return null;\n            }\n        }\n\n        public Command getCommand() {\n            return command;\n        }\n\n        public Coordinate getAnchor() {\n            return anchor;\n        }\n\n        public void setAnchor(Coordinate anchor) {\n            this.anchor = anchor;\n        }\n\n        public void setCommand(Command command) {\n            this.command = command;\n        }\n    }\n\n\n\n\n\n    private class Command {\n        private String direction;\n        private int distance;\n\n        public int getDistance() {\n            return distance;\n        }\n\n        public String getDirection() {\n            return direction;\n        }\n\n        public Command(){\n\n        }\n        public Command(String direction , int distance){\n            this.direction = direction;\n            this.distance = distance;\n        }\n    }\n\n\n\n    private class Line {\n\n        private Coordinate start;\n        private Coordinate end;\n        public Line(){\n\n        }\n\n        public Line(Coordinate start , Coordinate end){\n            this.start = start;\n            this.end = end;\n        }\n\n        public Coordinate getStart() {\n            return this.start;\n        }\n\n        public Coordinate getEnd() {\n            return this.end;\n        }\n\n        @Override\n\n        public String toString() {\n            return this.start.toString() +\"-\"+this.end.toString();\n        }\n\n\n\n    }\n\n\n    private class Coordinate {\n        private int x;\n        private int y;\n\n        public Coordinate(){\n            this.x = 0;\n            this.y = 0;\n        }\n\n        public Coordinate(int x , int y){\n            this.x = x;\n            this.y = y;\n        }\n\n        public int getX() {\n            return this.x;\n        }\n        public int getY() {\n            return this.y;\n        }\n\n        public void setX(int x) {\n            this.x = x;\n        }\n\n        public void setY(int y) {\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return \"(\" + x + \",\" + y + \")\";\n        }\n    }\n\n\n    public void test(){\n\n    }\n\n}\n"}, {"source": "student", "name": "student107", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "student", "name": "student108", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n    int[] position;\n    Field field;\n    public Exercise0() {\n        this.position = new int[]{8,3};\n        this.field = new Field(12, 9, 4);\n        field.addWall(new Wall(3, 1, 3, 7));\n        field.addWall(new Wall(6, 1, 9, 1));\n        field.addWall(new Wall(5, 2, 5, 5));\n        field.addWall(new Wall(6, 4, 9, 4));\n    }\n\n    public void moveViaDirection(String direction, int length) {\n        switch(direction) {\n            case \"no\":\n                moveInSteps(length, 1, 0, 1);\n                break;\n            case \"ea\":\n                moveInSteps(length, 1, 1, 0);\n                break;\n            case \"so\":\n                moveInSteps(length, -1, 0, -1);\n                break;\n            case \"we\":\n                moveInSteps(length, -1, -1, 0);\n                break;\n            default:\n        }\n    }\n\n    public boolean moveInSteps(int stepLength, int toAdd, int stepToX, int stepToY) {\n        int positionIndex = 0;\n        if (stepToY != 0) { positionIndex = 1; }\n        if (stepLength < 0) {toAdd = toAdd * -1; }\n        for (int i = 0; i < Math.abs(stepLength); i++) {\n            if (field.isStepClear(this.position[0], this.position[1], this.position[0] + stepToX, this.position[1] + stepToY)) {\n                this.position[positionIndex] += toAdd;\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public String[] splitToArgs(String moveCommandString) {\n        String s = moveCommandString.substring(1, moveCommandString.length()-1);\n        String[] arr = s.split(\",\");\n        return arr;\n    }\n\n    @Override\n    public String move(String moveCommandString) {\n        String[] arr = splitToArgs(moveCommandString);\n        moveViaDirection(arr[0], Integer.parseInt(arr[1]));\n        return \"(\" + this.position[0] + \",\" + this.position[1] + \")\";\n    }\n}\n"}, {"source": "student", "name": "student108", "file_name": "Field.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Field {\n    Wall[] walls;\n    int numWallsInserted = 0;\n    int sizeX;\n    int sizeY;\n\n    public Field(int sizeX, int sizeY, int countWalls) {\n        walls = new Wall[countWalls];\n        this.sizeX = sizeX;\n        this.sizeY = sizeY;\n    }\n\n    public void addWall(Wall wall) {\n        walls[numWallsInserted] = wall;\n        numWallsInserted++;\n    }\n    public Boolean isTargetWithinFieldLimits(int targetX, int targetY) {\n        if (targetX > this.sizeX || targetX < 0 || targetY > this.sizeY || targetY < 0) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    public Boolean isStepClear(int stepStartX, int stepStartY, int stepEndX, int stepEndY) {\n        if (!this.isTargetWithinFieldLimits(stepEndX, stepEndY)) { return false; }\n        for (int i=0; i<walls.length; i++) {\n            if (walls[i].isStepBlocked(stepStartX, stepStartY, stepEndX, stepEndY)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}, {"source": "student", "name": "student108", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "student", "name": "student108", "file_name": "Wall.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Wall {\n    int startX;\n    int startY;\n    int endX;\n    int endY;\n    int length;\n    int[][] forbiddenSteps;\n\n    public Wall(int startX, int startY, int endX, int endY) {\n        //Sicherstellen dass der startwert immer der kleinere Wert ist\n        if (startX > endX) {\n            int tempX = startX;\n            startX = endX;\n            endX = tempX;\n        }\n        if (startY > endY) {\n            int tempY = startY;\n            startY = endY;\n            endY = tempY;\n        }\n        // Startwerte setzen\n        this.startX = startX;\n        this.startY = startY;\n        this.endX = endX;\n        this.endY = endY;\n        //Potentielle Verbotene Schritte speichern\n        if (startX - endX != 0) {\n            this.length = endX-startX;\n            addForbiddenStep(1, 0, 1, 0, 0, 1);\n        } else {\n            this.length = endY-startY;\n            addForbiddenStep(0, 1, 0, 1, 1, 0);\n        }\n    }\n\n    private void addForbiddenStep(int startXMultiplier, int startYMultiplier, int endXMultiplier, int endYMultiplier, int endXAddition, int endYAddition) {\n        forbiddenSteps = new int[this.length][];\n        for (int i=0; i<forbiddenSteps.length; i++) {\n            forbiddenSteps[i] = new int[4];\n            forbiddenSteps[i][0] = startX + (startXMultiplier * i);\n            forbiddenSteps[i][1] = startY + (startYMultiplier * i);\n            forbiddenSteps[i][2] = startX + endXAddition + (endXMultiplier * i);\n            forbiddenSteps[i][3] = startY + endYAddition + (endYMultiplier * i);\n        }\n    }\n\n    public Boolean isStepBlocked(int stepStartX, int stepStartY, int stepEndX, int stepEndY) {\n        for ( int i=0; i<forbiddenSteps.length; i++ ) {\n            if (forbiddenSteps[i][0] == stepStartX && forbiddenSteps[i][1] == stepStartY && forbiddenSteps[i][2] == stepEndX && forbiddenSteps[i][3] == stepEndY ||\n                    forbiddenSteps[i][0] == stepEndX && forbiddenSteps[i][1] == stepEndY && forbiddenSteps[i][2] == stepStartX && forbiddenSteps[i][3] == stepStartY) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}, {"source": "student", "name": "student109", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport javax.sound.midi.SysexMessage;\n\npublic class Exercise0 implements GoAble {\n\n    public String start = \"(1,7)\";\n    public String weiter = null;\n\n    @Override\n    public String go(String goCommandString) {\n        String startf[] = null;\n        if (weiter == null) {\n            startf = start.split(\",\");\n            startf[0] = startf[0].replace(\"(\", \" \").trim();\n            startf[1] = startf[1].replace(\")\", \" \").trim();\n        }else {\n            startf = weiter.split(\",\");\n            startf[0] = startf[0].replace(\"(\", \" \").trim();\n            startf[1] = startf[1].replace(\")\", \" \").trim();\n        }\n\n\n        boolean feldno[][] = new boolean[12][9];\n        boolean feldea[][] = new boolean[12][9];\n        boolean feldso[][] = new boolean[12][9];\n        boolean feldwe[][] = new boolean[12][9];\n\n        feldea[2][8] = true;feldwe[0][0] = true;feldno[0][8] = true;feldso[0][0] = true;\n        feldea[2][7] = true;feldwe[0][1] = true;feldno[1][8] = true;feldso[1][0] = true;\n        feldea[2][6] = true;feldwe[0][2] = true;feldno[2][8] = true;feldso[2][0] = true;\n        feldea[2][5] = true;feldwe[0][3] = true;feldno[3][8] = true;feldso[3][0] = true;\n        feldea[2][4] = true;feldwe[0][4] = true;feldno[4][8] = true;feldso[4][0] = true;\n        feldea[2][3] = true;feldwe[0][5] = true;feldno[5][8] = true;feldso[5][0] = true;\n                            feldwe[0][6] = true;feldno[6][8] = true;feldso[6][0] = true;\n        feldea[4][1] = true;feldwe[0][7] = true;feldno[7][8] = true;feldso[7][0] = true;\n        feldea[4][0] = true;feldwe[0][8] = true;feldno[8][8] = true;feldso[8][0] = true;\n        feldea[5][1] = true;feldwe[3][8] = true;feldno[9][8] = true;feldso[9][0] = true;\n        feldea[5][0] = true;feldwe[3][8] = true;feldno[10][8] = true;feldso[10][0] = true;\n        feldea[5][2] = true;feldwe[3][8] = true;feldno[11][8] = true;feldso[11][0] = true;\n        feldea[5][3] = true;feldwe[3][8] = true;feldno[3][2] = true;feldso[3][3] = true;\n        feldea[11][0] = true;feldwe[3][8] = true;feldno[4][2] = true;feldso[3][4] = true;\n        feldea[11][1] = true;feldwe[3][7] = true;\n        feldea[11][2] = true;feldwe[3][6] = true;\n        feldea[11][3] = true;feldwe[3][5] = true;\n        feldea[11][4] = true;feldwe[3][4] = true;\n        feldea[11][5] = true;feldwe[3][3] = true;\n        feldea[11][6] = true;feldwe[6][0] = true;\n        feldea[11][7] = true;feldwe[6][1] = true;\n        feldea[11][8] = true;feldwe[6][1] = true;\n                             feldwe[7][0] = true;\n                             feldwe[7][1] = true;\n                             feldwe[7][2] = true;\n                             feldwe[7][3] = true;\n\n\n\n\n        String tmp[] = goCommandString.split(\",\");\n        tmp[0] = tmp[0].replace(\"[\", \" \").trim();\n        tmp[1] = tmp[1].replace(\"]\", \" \").trim();\n\n        int temps = Integer.parseInt(tmp[1]);\n        int i = Integer.parseInt(startf[0]);\n        int j = Integer.parseInt(startf[1]);\n\n\n        while (true) {\n            if (tmp[0].equals(\"no\")) {\n                if (temps >= 1 && j++ <= feldno[0].length && feldno[i][j] == false) {\n                    temps--;\n                }\n                else {\n                    break;\n                }\n            }\n            if (tmp[0].equals(\"ea\")) {\n                if (temps >= 1 && i++ <= feldea.length  && feldea[i][j] == false) {\n                    temps--;\n                }\n                else {\n                    break;\n                }\n            }\n            if (tmp[0].equals(\"so\")) {\n                if (temps > 0 && j-- > 0  && feldso[i][j] == false)  {\n                    temps--;\n                }\n                else {\n                    break;\n                }\n            }\n            if (tmp[0].equals(\"we\")) {\n\n                if (temps > 0 && i-- > 0  && feldwe[i][j] == false) {\n                    temps --;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        weiter = \"(\"+ String.valueOf(i) + \",\" + String.valueOf(j) + \")\";\n        return \"(\"+ String.valueOf(i) + \",\" + String.valueOf(j) + \")\";\n    }\n}\n"}, {"source": "student", "name": "student109", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String go(String goCommandString);\n}\n"}, {"source": "student", "name": "student11", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n\n    //check if border is in direction, if not move one step in that direction\n    //command is: \"[direction, steps]\"\n    //check if moving out of field, x,y != -1 & x <= 11, y <= 8\n    int x = 4;\n    int y = 0;\n    int [][]borders = {{1,0,3},{0,0,4},{1,1,3},{0,1,4},{1,2,3},{0,2,4},{1,3,3},{0,3,4},{1,4,3},{0,4,4},{1,5,3},{0,5,4},{1,5,1},{1,6,2},{2,5,1},{2,6,2},{3,5,1},{3,6,2},{5,5,1},{5,6,2},{6,6,2},{6,5,1},{6,5,4},{7,5,3},{6,4,4},{7,4,3},{6,3,4},{7,3,3},{6,2,4},{7,2,3},{6,1,4},{7,1,3}};\n    @Override\n    public String moveTo(String moveCommandString) {\n        String inuf = moveCommandString.replace(\"[\",\"\").replace(\"]\",\"\");\n        String[] in = inuf.split(\",\");\n        String direction = in[0];\n        int steps = Integer.parseInt(in[1]);\n        for(int i = 0; i< steps; i++) {\n            switch (direction) {\n                case \"no\": {\n                    // plus y\n                    if(!borderInFront(x,y,\"no\") && y+1 < 8){\n                        y++;\n                        break;\n                    }\n                    else{\n                        System.out.println(\"Border detected\");\n                        break;\n                    }\n                }\n                case \"ea\": {\n                    // plus x\n                    if(!borderInFront(x,y, \"ea\") && x+1 < 11){\n                        x++;\n                        break;\n                    }\n                    else{\n                        System.out.println(\"Border detected\");\n                        break;\n                    }\n                }\n                case \"so\": {\n                    // minus y\n                    if(!borderInFront(x,y, \"so\") && y-1 >= 0){\n                        y--;\n                        break;\n                    }\n                    else{\n                        System.out.println(\"Border detected\");\n                        break;\n                    }\n                }\n                case \"we\": {\n                    // minus x\n                    if(!borderInFront(x,y, \"we\") && x-1 >= 0){\n                        x--;\n                        break;\n                    }\n                    else{\n                        System.out.println(\"Border detected\");\n                        break;\n                    }\n                }\n                default:\n                    System.out.println(\"unsupported direction\");\n            }\n        }\n        //throw new UnsupportedOperationException();\n        return \"(\" + x + \",\" + y + \")\";\n\n    }\n    //FALSCH next coordinate, if it crosses a border return true\n    //direction heading\n    //current coordinate\n    //declare inside and outside border\n    public boolean borderInFront(int x, int y, String direction){\n        //write contains method\n        int dir = 0;\n        switch(direction) {\n            case \"no\": dir = 1; break;\n            case \"so\": dir = 2; break;\n            case \"we\": dir = 3; break;\n            case \"ea\": dir = 4; break;\n        }\n        for(int i = 0; i < borders.length; i++){\n            if(borders[i][0] == x && borders[i][1] == y && borders[i][2] == dir){\n                    return true;\n            }\n        }\n        return false;\n    }\n}\n"}, {"source": "student", "name": "student11", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String moveTo(String moveCommandString);\n}\n"}, {"source": "student", "name": "student110", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport javax.persistence.criteria.CriteriaBuilder;\nimport java.util.ArrayList;\n\npublic class Exercise0 implements GoAble {\n    public Integer x = 0;\n    public Integer y=2;\n\n\n\n\n\n\n    @Override\n    public String goTo(String goCommandString) {\n\n\n                String wandpunkt1 = \"3,0\";\n                String wandpunkt2 = \"3,1\";\n                String wandpunkt3 = \"3,2\";\n                String wandpunkt4 = \"5,0\";\n                String wandpunkt5 = \"5,1\";\n                String wandpunkt6 = \"5,2\";\n                String wandpunkt7= \"5,3\";\n                String wandpunkt8 = \"7,9\";\n                String wandpunkt9 = \"7,8\";\n                String wandpunkt10 = \"7,7\";\n                String wandpunkt11 = \"7,6\";\n                String wandpunkt12 = \"5,5\";\n                String wandpunkt13 = \"6,5\";\n\n\n\n        ArrayList<String> wandpunkte = new ArrayList<>();\n        wandpunkte.add(wandpunkt1);\n        wandpunkte.add(wandpunkt2);\n        wandpunkte.add(wandpunkt3);\n        wandpunkte.add(wandpunkt4);\n        wandpunkte.add(wandpunkt5);\n        wandpunkte.add(wandpunkt6);\n        wandpunkte.add(wandpunkt7);\n        wandpunkte.add(wandpunkt8);\n        wandpunkte.add(wandpunkt9);\n        wandpunkte.add(wandpunkt10);\n        wandpunkte.add(wandpunkt11);\n        wandpunkte.add(wandpunkt12);\n        wandpunkte.add(wandpunkt13);\n\n\n\n        int moveAmmount;\n        Integer c;\n        String startString = String.format (\"[%d,%d]\",x,y);\n        String finalString;\n\n        moveAmmount =Integer.parseInt(goCommandString.substring(4,5));\n\n\n\n\n\n        if(goCommandString.contains(\"no\")){\n\n\n            for (int i = 0; i< wandpunkte.size(); i++){\n\n                if (Integer.parseInt(wandpunkte.get(i).substring(2,3))>y && Integer.parseInt(wandpunkte.get(i).substring(2,3))<= (y+moveAmmount) && Integer.parseInt(wandpunkte.get(i).substring(0,1)) == x ){\n\n                    y = Integer.parseInt(wandpunkte.get(i).substring(2,3))-1;\n                    finalString = String.format(\"(%d,%d)\",x,y);\n                    return finalString;\n\n\n                }\n\n            }\n\n            y = y + moveAmmount;\n\n            if (y<0) y=0;\n            if (y>8)y=8;\n            finalString = String.format(\"(%d,%d)\",x,y);\n            return finalString;\n        }\n        else if (goCommandString.contains(\"so\")){\n\n            for (int b = 0; b< wandpunkte.size(); b++){\n\n                if (Integer.parseInt(wandpunkte.get(b).substring(2,3))<y && Integer.parseInt(wandpunkte.get(b).substring(2,3))>= (y-moveAmmount) && Integer.parseInt(wandpunkte.get(b).substring(0,1)) == x ){\n\n                    y =Integer.parseInt(wandpunkte.get(b).substring(2,3))+1;\n                    finalString = String.format(\"(%d,%d)\",x,y);\n                    return finalString;\n\n                }\n            }\n\n                y = y - moveAmmount;\n                if (y<0) y=0;\n                if (y>8)y=8;\n\n            finalString = String.format(\"(%d,%d)\",x,y);\n            return finalString;\n\n        }\n        else if (goCommandString.contains(\"ea\")){\n\n\n\n            for (int a = 0; a< wandpunkte.size(); a++){\n\n                if (Integer.parseInt(wandpunkte.get(a).substring(0,1))>x && Integer.parseInt(wandpunkte.get(a).substring(0,1))<= (x+moveAmmount) && Integer.parseInt(wandpunkte.get(a).substring(2,3)) == y ){\n\n                    x = Integer.parseInt(wandpunkte.get(a).substring(0,1))-1;\n                    finalString = String.format(\"(%d,%d)\",x,y);\n                    return finalString;\n\n\n                }\n\n            }\n\n\n                 x = x+moveAmmount;\n                if (x<0) x=0;\n               if (x>12)x=12;\n\n            finalString = String.format(\"(%d,%d)\",x,y);\n            return finalString;\n        }\n        else if (goCommandString.contains(\"we\")){\n\n\n\n            for (int i = 0; i< wandpunkte.size(); i++){\n                    ///&& Integer.parseInt(wandpunkte.get(i).substring(2,3)) !=Integer.parseInt(wandpunkte.get(i+1).substring(2,3))  && Integer.parseInt(wandpunkte.get(i+1).substring(2,3)) !=Integer.parseInt(wandpunkte.get(i+2).substring(2,3))  && Integer.parseInt(wandpunkte.get(i+2).substring(2,3)) !=Integer.parseInt(wandpunkte.get(i+3).substring(2,3))\n\n                if (Integer.parseInt(wandpunkte.get(i).substring(0,1))<x && Integer.parseInt(wandpunkte.get(i).substring(0,1))>= (x-moveAmmount) && Integer.parseInt(wandpunkte.get(i).substring(2,3)) == y ){\n\n                    x = Integer.parseInt(wandpunkte.get(i).substring(0,1));\n                    finalString = String.format(\"(%d,%d)\",x,y);\n                    return finalString;\n\n\n                }\n\n            }\n\n            x = x - moveAmmount;\n            if (x<0) x=0;\n            if (x>12)x=12;\n            finalString = String.format(\"(%d,%d)\",x,y);\n            return finalString;\n\n\n        }\n\n     else return null;\n    }\n\n\n\n\n\n}\n"}, {"source": "student", "name": "student110", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "student", "name": "student112", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\n\npublic class Exercise0 implements GoAble {\n    public Integer startposition_x=0;\n    public Integer startposition_y=2;\n\n    @Override\n    public String go(String goCommandString) {\n\n        Pair no [] =new Pair[3];\n        no[0] = new Pair(4, 5);\n        no[1] = new Pair(5, 5);\n        no[2] = new Pair(6, 5);\n\n        Pair so [] =new Pair[3];\n        so[0] = new Pair(4, 4);\n        so[1] = new Pair(5, 4);\n        so[2] = new Pair(6, 4);\n\n        Pair ea [] =new Pair[11];\n        ea[0] = new Pair(2, 2);\n        ea[1] = new Pair(2, 1);\n        ea[2] = new Pair(2, 0);\n        ea[3] = new Pair(4, 2);\n        ea[4] = new Pair(4, 1);\n        ea[5] = new Pair(4, 0);\n        ea[6] = new Pair(4, 3);\n        ea[7] = new Pair(6, 5);\n        ea[8] = new Pair(6, 6);\n        ea[9] = new Pair(6, 7);\n        ea[10] = new Pair(6, 8);\n\n        Pair we [] =new Pair[11];\n        we[0] = new Pair(3, 2);\n        we[1] = new Pair(3, 1);\n        we[2] = new Pair(3, 0);\n        we[3] = new Pair(5, 2);\n        we[4] = new Pair(5, 1);\n        we[5] = new Pair(5, 0);\n        we[6] = new Pair(5, 3);\n        we[7] = new Pair(7, 5);\n        we[8] = new Pair(7, 6);\n        we[9] = new Pair(7, 7);\n        we[10] = new Pair(7, 8);\n\n        goCommandString=goCommandString.replace(\"[\",\"\");\n        goCommandString=goCommandString.replace(\"]\",\"\");\n        String[]commando=goCommandString.split(\",\");\n\n        Integer steps = Integer.valueOf(commando[1]);\n            //Abfrage f\u00fcr 0 -- wenn ganz am rand\n            switch (commando[0]) {\n                case \"no\": {\n                    for (int i = steps; i > 0; i--) {\n                    if (!compare(new Pair(startposition_x, startposition_y), no)) {\n                        if (startposition_y < 8)\n                            startposition_y++;\n                    }\n                    }break;\n                }\n                case \"so\": {\n                    for (int i = steps; i > 0; i--) {\n                    if (!compare(new Pair(startposition_x, startposition_y), so)) {\n                            if (startposition_y > 0)\n                                startposition_y--;\n                        }\n                    }break;\n                }\n                case \"ea\": {\n                    for (int i = steps; i > 0; i--) {\n                    if (!compare(new Pair(startposition_x, startposition_y), ea)) {\n                        if (startposition_x < 11)\n                            startposition_x++;\n                    }\n                    }break;\n                }\n                case \"we\": {\n                    for (int i = steps; i > 0; i--) {\n                        if (!compare(new Pair(startposition_x, startposition_y), we)) {\n                            if (startposition_x > 0)\n                                startposition_x--;\n                        }\n                    }break;\n                }\n            }\n\n\n        return (\"(\"+startposition_x+\",\"+startposition_y+\")\");\n\n    }\n    public Boolean compare(Pair gesucht, Pair[] arr){\n\n        for(int i=0; i<arr.length; i++){\n            if(arr[i].first==gesucht.first && arr[i].second==gesucht.second){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}, {"source": "student", "name": "student112", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String go(String goCommandString);\n}\n"}, {"source": "student", "name": "student112", "file_name": "Pair.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Pair {\n    int first;\n    int second;\n    // Constructor\n    public Pair(int first, int second)\n    {\n        this.first = first;\n        this.second = second;\n    }\n}\n"}, {"source": "student", "name": "student116", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n    private int x;\n    private int y;\n    char[] c=new char[2];\n    @Override\n    public String walk(String walkCommandString){\n        c[0]=walkCommandString.charAt(1);\n        c[1]=walkCommandString.charAt(2);\n        String []h=walkCommandString.split(\",\");\n        String j=h[1];\n        j=j.replace(\"]\",\"\");\n        int b=Integer.parseInt(j);\n        if(c[0]=='n'&&c[1]=='o'){\n            goNorth(b);\n        }\n\n        else if(c[0]=='s'&&c[1]=='o'){\n            goSouth(b);\n        }\n\n        else if(c[0]=='e'&&c[1]=='a'){\n            goEast(b);\n        }\n\n        else if(c[0]=='w'&&c[1]=='e'){\n            goWest(b);\n        }\n        else{\n            return \"-1\";\n        }\n        return \"(\"+x+\",\"+y+\")\";\n    }\n    boolean [] [] obstaclesX = new boolean[12][9];\n    boolean [] [] obstaclesY = new boolean[12][9];\n    Exercise0() {\n        x = 1;\n        y = 6;\n        obstaclesY[0][6] = true;\n        obstaclesY[1][6] = true;\n        obstaclesY[2][6] = true;\n\n        obstaclesY[1][5] = true;\n        obstaclesY[2][5] = true;\n        obstaclesY[3][5] = true;\n        obstaclesY[4][5] = true;\n        obstaclesY[5][5] = true;\n        obstaclesY[6][5] = true;\n        obstaclesY[7][5] = true;\n        obstaclesY[8][5] = true;\n        obstaclesY[9][5] = true;\n\n        obstaclesX[9][1] = true;\n        obstaclesX[9][2] = true;\n        obstaclesX[9][3] = true;\n        obstaclesX[9][4] = true;\n        obstaclesX[9][5] = true;\n\n        obstaclesX[3][6] = true;\n        obstaclesX[3][7] = true;\n        obstaclesX[3][8] = true;\n    }\n    private void goNorth(int steps){\n        if(y<7 && steps>0){\n            if(!obstaclesY[x][y+1] || !obstaclesY[x+1][y+1]) {\n                y++;\n                goNorth(steps - 1);\n            }\n        }\n    }\n\n    private void goSouth(int steps){\n        if(y>0 && steps>0){\n            if(!obstaclesY[x][y] || !obstaclesY[x+1][y]) {\n                y--;\n                goSouth(steps - 1);\n            }\n        }\n    }\n\n    private void goEast(int steps){\n        if(x<10 && steps>0){\n            if(!obstaclesX[x+1][y] || !obstaclesX[x+1][y+1]) {\n                x++;\n                goEast(steps - 1);\n            }\n        }\n    }\n\n    private void goWest(int steps){\n        if(x>0 && steps>0){\n            if(!obstaclesX[x][y] || !obstaclesX[x][y+1]) {\n                x--;\n                goWest(steps - 1);\n            }\n        }\n    }\n\n}\n"}, {"source": "student", "name": "student116", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walk(String walkCommandString);\n}\n"}, {"source": "student", "name": "student118", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport org.modelmapper.internal.Pair;\n\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class Exercise0 implements GoAble {\n\n    int X_MAX = 10;\n    int Y_MAX = 7;\n    int X = 1;\n    int Y = 6;\n\n\n    @Override\n    public String go(String goCommandString) {\n\n        int steps = Integer.parseInt(String.valueOf(goCommandString.charAt(4)));\n\n        //north\n        if (goCommandString.charAt(1)=='n') {\n            if ((X>=1 && X<=8) && Y<5) {\n                if (Y+steps>4) Y=4;\n                else Y +=steps;\n\n            }\n            else if (X==0 && Y<6){\n                if (Y+steps>5) Y=5;\n                else Y-=steps;\n\n            }\n            else if (X==1&&Y==5) Y=5;\n            else if (steps+Y>Y_MAX) Y= Y_MAX;\n            else Y +=steps;\n        }\n        //south\n        if (goCommandString.charAt(1)=='s') {\n            if ((X>=2 && X<=8) && Y>5){\n                if (Y-steps<5) Y=5;\n                else Y-=steps;\n\n            }\n            else if (X<2 && Y>5){\n                if (Y-steps<6) Y=6;\n                else Y-=steps;\n\n            }\n            else if (X==1 && Y==5) Y=5;\n            else if (Y-steps<0) Y= 0;\n            else Y-=steps;\n\n        }\n        //east\n        if (goCommandString.charAt(1)=='e'){\n            if ((Y>=1 && Y<=4) && X<9){\n                if (X+steps>8) X=8;\n                else X+=steps;\n\n\n            }\n            else if (Y>5 && X<3){\n                if (X+steps>2) X=2;\n                else X+=steps;\n            }\n            else if (steps+X>X_MAX) X=X_MAX;\n            else X+=steps;\n        }\n        //west\n        if (goCommandString.charAt(1)=='w'){\n            if ((Y>=1 && Y<=4) && X>8){\n                if (X-steps<9) X=9;\n                else X-=steps;\n\n            }\n            else if (Y>5 && X>2){\n                if (X-steps<3) X=3;\n                else X-=steps;\n\n            }\n            else if (X-steps<0) X=0;\n            else X-=steps;\n        }\n\n        return \"(\"+X+\",\"+Y+\")\";\n    }\n    public static void main(String args[]){\n\n        Exercise0 ex = new Exercise0();\n\n\n        System.out.println(ex.go(\"[no,2]\"));\n        System.out.println(ex.go(\"[ea,5]\"));\n        System.out.println(ex.go(\"[we,3]\"));\n        System.out.println(ex.go(\"[we,4]\"));\n\n    }\n}\n\n"}, {"source": "student", "name": "student118", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String go(String goCommandString);\n}\n"}, {"source": "student", "name": "student119", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.awt.*;\nimport java.util.List;\n\npublic class Exercise0 implements Walkable {\n\n    // Barriers\n    // (0,6) - (2,6)\n    // (3,6) - (3,8)\n    // (1,5) - (9,5)\n    // (9,1) - (9,5)\n    private final List<Barrier> mBarriers = List.of(\n            // Map borders\n            new Barrier(new Point(0, 0), new Point(11, 0), BarrierType.horizontal),\n            new Barrier(new Point(0, 8), new Point(11, 8), BarrierType.horizontal),\n            new Barrier(new Point(0, 0), new Point(0, 8), BarrierType.vertical),\n            new Barrier(new Point(11, 0), new Point(11, 8), BarrierType.vertical),\n\n            // Barriers\n            new Barrier(new Point(0, 6), new Point(2, 6), BarrierType.horizontal),\n            new Barrier(new Point(3, 6), new Point(3, 8), BarrierType.vertical),\n            new Barrier(new Point(1, 5), new Point(9, 5), BarrierType.horizontal),\n            new Barrier(new Point(9, 1), new Point(9, 5), BarrierType.vertical)\n    );\n\n    // Start\n    // (1,6)\n    private final TilePosition mCurrentPosition = new TilePosition(\n            new Point(1, 6),\n            new Point(1, 7),\n            new Point(2, 7),\n            new Point(2, 6)\n    );\n\n    @Override\n    public String walkTo(String walkCommandString) {\n        // 1. in which direction are we moving?\n        // 2. get barriers for this direction\n        // 3. get barriers for current tile position, which barrier would be crossed?\n        // 4. move to the new tile position\n        // 5. return new tile position (bottom left corner)\n        final WalkCommand command = parseCommand(walkCommandString);\n\n        for (int i = 0; i < command.steps; i++) {\n            // if the border coordinate is lower than the barrier limit, we can move\n            final boolean limitReached = barrierReached(command);\n            if(limitReached)\n                break;\n\n            mCurrentPosition.walk(command.direction, 1);\n        }\n        return mCurrentPosition.getCoordinates();\n    }\n\n    private boolean barrierReached(WalkCommand command) {\n        final int border = mCurrentPosition.getBorder(command.direction);\n        return mBarriers.stream().anyMatch(barrier -> {\n            switch (command.direction) {\n                // we are interested in barriers where the y coordinate is greater than or equal\n                // the current tile position, and the x coordinate is in rage of barriers x coordinates\n                case north:\n                case south:\n                    return barrier.type == BarrierType.horizontal &&\n                            mCurrentPosition.leftTop.x >= barrier.start.x && mCurrentPosition.rightTop.x <= barrier.end.x &&\n                            border == barrier.start.y;\n                case east:\n                case west:\n                    final boolean barrierTypeMatch = barrier.type == BarrierType.vertical;\n                    final boolean barrierInRange = mCurrentPosition.leftBottom.y >= barrier.start.y && mCurrentPosition.leftTop.y <= barrier.end.y;\n                    return barrierTypeMatch &&\n                            barrierInRange &&\n                            border == barrier.start.x;\n                default:\n                    throw new UnsupportedOperationException();\n            }\n        });\n    }\n\n    private WalkCommand parseCommand(String commandString) {\n        var replaced = commandString.replace(\"]\", \"\");\n        replaced = replaced.replace(\"[\", \"\");\n        var splits = replaced.split(\",\");\n        var directionString = splits[0];\n        var steps = splits[1];\n\n        Direction direction;\n        switch (directionString) {\n            case \"no\":\n                direction = Direction.north;\n                break;\n            case \"ea\":\n                direction = Direction.east;\n                break;\n            case \"so\":\n                direction = Direction.south;\n                break;\n            case \"we\":\n                direction = Direction.west;\n                break;\n            default:\n                throw new UnsupportedOperationException();\n\n        }\n\n        return new WalkCommand(direction, Integer.parseInt(steps));\n    }\n\n    private static class TilePosition {\n        final public Point leftBottom;\n        final public Point leftTop;\n        final public Point rightTop;\n        final public Point rightBottom;\n\n        private TilePosition(Point leftBottom, Point leftTop, Point rightTop, Point rightBottom) {\n            this.leftBottom = leftBottom;\n            this.leftTop = leftTop;\n            this.rightTop = rightTop;\n            this.rightBottom = rightBottom;\n        }\n\n        private void walk(Direction direction, int steps) {\n            var stepPoint = getStepPoint(direction, steps);\n            updatePoint(leftBottom, stepPoint);\n            updatePoint(leftTop, stepPoint);\n            updatePoint(rightTop, stepPoint);\n            updatePoint(rightBottom, stepPoint);\n        }\n\n        private void updatePoint(Point point, Point updates) {\n            point.move(point.x + updates.x, point.y + updates.y);\n        }\n\n        private Point getStepPoint(Direction direction, int steps) {\n            switch (direction) {\n                case north:\n                    return new Point(0, steps);\n                case east:\n                    return new Point(steps, 0);\n                case south:\n                    return new Point(0, -steps);\n                case west:\n                    return new Point(-steps, 0);\n                default:\n                    throw new UnsupportedOperationException();\n            }\n        }\n\n        public int getBorder(Direction direction) {\n            switch (direction) {\n                case north:\n                    return leftTop.y;\n                case east:\n                    return rightTop.x;\n                case south:\n                    return rightBottom.y;\n                case west:\n                    return leftTop.x;\n                default:\n                    throw new UnsupportedOperationException();\n            }\n        }\n\n        public String getCoordinates() {\n            return \"(\" + leftBottom.x + \",\" + leftBottom.y + \")\";\n        }\n    }\n\n    private static class WalkCommand {\n        final Direction direction;\n        final int steps;\n\n        private WalkCommand(Direction direction, int steps) {\n            this.direction = direction;\n            this.steps = steps;\n        }\n    }\n\n    private enum Direction {\n        north, east, south, west\n    }\n\n    private static class Barrier {\n        public final Point start;\n        public final Point end;\n        public final BarrierType type;\n\n        private Barrier(Point start, Point end, BarrierType type) {\n            this.start = start;\n            this.end = end;\n            this.type = type;\n        }\n\n        public int getLimit() {\n            switch (type) {\n                case horizontal:\n                    return start.y;\n                case vertical:\n                    return start.x;\n                default:\n                    throw new UnsupportedOperationException();\n            }\n        }\n    }\n\n    private enum BarrierType {\n        horizontal, vertical\n    }\n}\n"}, {"source": "student", "name": "student119", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "student", "name": "student121", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n    int xPos = 11;\n    int yPos = 7;\n\n    @Override\n    public String walk(String walkCommandString) {\n\n        int lowerBoundary = 0;\n        int upperBoundary = 8;\n        int rightBoundary = 12;\n        int leftBoundary = 0;\n\n\n\n        String direction = walkCommandString.split(\",\")[0].substring(1, 3);\n        int stepSize = Integer.parseInt(walkCommandString.split(\",\")[1].substring(0,walkCommandString.split(\",\")[1].length() -1));\n\n//        System.out.println(direction);\n//        System.out.println(stepSize);\n\n        switch (direction) {\n            case \"no\": {\n                for (int i = 0; i < stepSize; i++) {\n                    yPos++;\n                    if (yPos == upperBoundary) {\n                        break;\n                    }\n                    //obstacle\n                    if (yPos == 5 && xPos == 5) {\n                        yPos--;\n                        break;\n                    }\n                    if (yPos == 6 && (xPos >= 5 && xPos <= 11)) {\n                        yPos--;\n                        break;\n                    }\n                }\n            }\n            break;\n            case \"so\": {\n                for (int i = 0; i < stepSize; i++) {\n                    yPos--;\n                    if (yPos == lowerBoundary) {\n                        break;\n                    }\n                    //obstacle\n                    if (yPos == 6 && (xPos >= 5 && xPos <= 11)) {\n                        break;\n                    }\n\n                }\n            }\n            break;\n            case \"ea\": {\n                for (int i = 0; i < stepSize; i++) {\n                    xPos++;\n                    if (xPos == rightBoundary) {\n                        xPos--;\n                        break;\n                    }\n                    //obstacle\n                    if (xPos == 5 && yPos == 5) {\n                        xPos--;\n                        break;\n                    }\n                    if (xPos == 6 && (yPos >= 2 && yPos <= 4)) {\n                        xPos--;\n                        break;\n                    }\n                }\n            }\n            break;\n            case \"we\": {\n                for (int i = 0; i < stepSize; i++) {\n                    xPos--;\n                    if (xPos == leftBoundary) {\n                        break;\n                    }\n                    //obstacle\n                    if (xPos == 6 && yPos == 5) {\n                        break;\n                    }\n                    if (xPos == 7 && (yPos >= 2 && yPos <= 4)) {\n                        break;\n                    }\n                }\n            }\n            break;\n            default:\n                System.out.println(\"Invalid command\");\n        }\n\n        String lastPosition = \"(\" + xPos + \",\" + yPos + \")\";\n\n//        System.out.println(lastPosition);\n\n        return lastPosition;\n\n    }\n}\n"}, {"source": "student", "name": "student121", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walk(String walkCommandString);\n}\n"}, {"source": "student", "name": "student122", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class Exercise0 implements Walkable {\n\n    private String loc = \"(1,6)\";\n    String[] horizontalObstacles = {\n            \"(0,6)-(2,6)\",  // horizontal\n            \"(0,0)-(11,0)\", //horizontal\n            \"(0,8)-(11,8)\",  //horizontal\n            \"(1,5)-(9,5)\"  // horizontal\n    };\n    String[] verticalObstacles = {\n            \"(3,6)-(3,8)\",\n            \"(9,1)-(9,5)\",\n            \"(0,0)-(0,8)\",\n            \"(11,0)-(11,8)\"\n    };\n\n\n    @Override\n    public String walkTo(String walkCommandString) {\n        System.out.println(\"COMMAND: \"+walkCommandString);\n        String[] commandArr = walkCommandString.replace(\"[\",\"\").replace(\"]\",\"\").split(\",\");\n        String direction = commandArr[0];\n        List<String> vObs = getObstacles(verticalObstacles);\n        List<String> hObs = getObstacles(horizontalObstacles);\n\n        switch (commandArr[0]){\n            case \"so\":// y--\n                for(int i =0; i<Integer.parseInt(commandArr[1]);i++){\n                    int[] locArr = getLocAsArray(loc);\n                    int[] firstPoint = {locArr[0],locArr[1]};\n                    int[] secondPoint = {locArr[0]+1,locArr[1]};\n                    int unchanged = locArr[1];\n                    String boxEdge = stringOfTwoPoints(unchanged,firstPoint[0],secondPoint[0]);\n                    System.out.println(\"BOXEDGE: \"+boxEdge);\n\n                    System.out.println(\"HOBS\"+hObs);\n                    if(hObs.contains(boxEdge)){\n                        System.out.println(\"CONTAINS\");\n                        break;\n                    }else {\n                        System.out.println(\"NOT CONTAINS\");\n                        System.out.println(\"LOC BEFORE: \"+loc);\n                        loc=changeLoc(loc, \"so\");\n                        System.out.println(\"LOC AFTER: \"+loc);\n                    }\n                }\n                break;\n            case \"no\":// y--\n                for(int i =0; i<Integer.parseInt(commandArr[1]);i++){\n                    int[] locArr = getLocAsArray(loc);\n                    int[] firstPoint = {locArr[0],locArr[1]+1};\n                    int[] secondPoint = {locArr[0]+1,locArr[1]+1};\n                    int unchanged = locArr[1]+1;\n\n                    String boxEdge = stringOfTwoPoints(unchanged,firstPoint[0],secondPoint[0]);\n                    System.out.println(\"BOXEDGE: \"+boxEdge);\n\n                    System.out.println(\"HOBS\"+hObs);\n                    if(hObs.contains(boxEdge)){\n                        System.out.println(\"CONTAINS\");\n                        break;\n                    }else {\n                        System.out.println(\"NOT CONTAINS\");\n                        System.out.println(\"LOC BEFORE: \"+loc);\n                        loc=changeLoc(loc, \"no\");\n                        System.out.println(\"LOC AFTER: \"+loc);\n                    }\n                }\n                break;\n            case \"ea\":\n                System.out.println(\"EA START\");\n                for(int i = 0; i<Integer.parseInt(commandArr[1]);i++){\n                    int[] locArr = getLocAsArray(loc);\n                    int[] firstPoint = {locArr[0]+1,locArr[1]};\n                    int[] secondPoint = {locArr[0]+1,locArr[1]+1};\n                    int unchanged = locArr[0]+1;\n                    String boxEdge = stringOfTwoPoints(unchanged,firstPoint[1],secondPoint[1]);\n                    System.out.println(\"BOXEDGE: \"+boxEdge);\n\n                    System.out.println(\"VOBS\"+vObs);\n                    if(vObs.contains(boxEdge)){\n                        System.out.println(\"CONTAINS\");\n                        break;\n                    }\n                    else {\n                        System.out.println(\"NOT CONTAINS\");\n                        System.out.println(\"LOC BEFORE: \"+loc);\n                        loc=changeLoc(loc, \"ea\");\n                        System.out.println(\"LOC AFTER: \"+loc);\n                    }\n\n                }\n                System.out.println(\"EA END\");\n                break;\n            case \"we\":\n                for(int i = 0; i<Integer.parseInt(commandArr[1]);i++){\n                    int[] locArr = getLocAsArray(loc);\n\n                    int[] firstPoint = {locArr[0],locArr[1]};\n                    int[] secondPoint = {locArr[0],locArr[1]+1};\n                    System.out.println(\"FIRST: \"+ Arrays.toString(firstPoint) +\" SECOND: \"+ Arrays.toString(secondPoint));\n                    int unchanged = locArr[0];\n                    System.out.println(\"UNCHANGED: \"+unchanged);\n                    String boxEdge = stringOfTwoPoints(unchanged,firstPoint[1],secondPoint[1]);\n                    System.out.println(\"BOX EDGE: \"+boxEdge);\n\n                    System.out.println(\"VOBS\"+vObs);\n                    if(vObs.contains(boxEdge)){\n                        System.out.println(\"CONTAINS\");\n                        break;\n                    }\n                    else {\n                        System.out.println(\"NOT CONTAINS\");\n                        System.out.println(\"LOC BEFORE: \"+loc);\n                        loc=changeLoc(loc, \"we\");\n                        System.out.println(\"LOC AFTER: \"+loc);\n                    }\n\n                }\n                break;\n        }\n\n        System.out.println(\"NEW LOC: \"+loc);\n        System.out.println(\"END OF WALK--------------------------------------------------\");\n        return loc;\n    }\n\n    private String changeLoc(String currentLoc,String direction){\n        int[] currArr = getLocAsArray(currentLoc);\n        switch (direction){\n            case \"so\":\n                currArr[1]--;\n                break;\n            case \"no\":\n                currArr[1]++;\n                break;\n            case \"we\":\n                currArr[0]--;\n\n                break;\n            case \"ea\":\n                currArr[0]++;\n                break;\n        }\n\n        return getLocAsString(currArr);\n\n    }\n\n    private String stringOfTwoPoints(int unchange, int p1, int p2){\n        return unchange+\"-(\"+p1+\",\"+p2+\")\";\n    }\n\n    private List<String> getObstacles(String[] obsStr){\n        List<String> listOfEdges = new ArrayList<>();\n        for(String obs:obsStr){\n            HashMap<String,HashMap<String,String>> a = getPoints(obs);\n            String direction = (String) a.keySet().toArray()[0];\n            String axis = (String) a.get(direction).keySet().toArray()[0];\n            String[] arr = getEdges(a.get(direction).get(axis));\n            for(String ar: arr){\n                String obsWithAxis = (axis+\"-\"+ar);\n                listOfEdges.add(obsWithAxis);\n            }\n        }\n\n        return listOfEdges;\n    }\n\n    private String[] getEdges(String str){\n        String[] edgStr = str.split(\",\");\n        String[] edges = new String[edgStr.length-1];\n\n        for(int i = 0; i< edges.length;i++){\n            edges[i] = (\"(\" + edgStr[i] + \",\"+edgStr[i+1]+\")\");\n        }\n\n        return edges;\n    }\n\n    private HashMap<String,HashMap<String,String>> getPoints(String str){\n        String direction;\n        String nonChangingAxis;\n        StringBuilder dots = new StringBuilder();\n        String[] points = str.split(\"-\");\n        String[] leftPoint = points[0].replace(\"(\",\"\").replace(\")\",\"\").split(\",\");\n        String[] rightPoint = points[1].replace(\"(\",\"\").replace(\")\",\"\").split(\",\");\n\n        if(!leftPoint[0].equals(rightPoint[0])){\n            direction = \"horizontal\";\n            nonChangingAxis = leftPoint[1];\n            for(int i = Integer.parseInt(leftPoint[0]); i<=Integer.parseInt(rightPoint[0]);i++){\n                dots.append(i);\n                dots.append(\",\");\n            }\n        }else{\n            direction = \"vertical\";\n            nonChangingAxis = leftPoint[0];\n            for(int i = Integer.parseInt(leftPoint[1]); i<=Integer.parseInt(rightPoint[1]);i++){\n                dots.append(i);\n                dots.append(\",\");\n            }\n        }\n        dots.deleteCharAt(dots.length()-1);\n        HashMap<String,String> axisAndDots = new HashMap<>();\n        HashMap<String,HashMap<String,String>> mainHash = new HashMap<>();\n        axisAndDots.put(nonChangingAxis,dots.toString());\n        mainHash.put(direction,axisAndDots);\n\n        return mainHash;\n    }\n\n    private int[] getLocAsArray(String locString){\n        String[] split = locString.replace(\"(\", \"\").replace(\")\", \"\").split(\",\");\n\n        return new int[]{\n                Integer.parseInt(split[0]),\n                Integer.parseInt(split[1])\n        };\n    }\n\n    private String getLocAsString(int[] arr){\n        return \"(\"+(arr[0])+\",\"+(arr[1])+\")\";\n    }\n\n}\n"}, {"source": "student", "name": "student122", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "student", "name": "student123", "file_name": "Cell.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Cell {\n\n    private boolean borderNorth;\n    private boolean borderEast;\n    private boolean borderSouth;\n    private boolean borderWest;\n\n    public Cell(){\n        borderNorth = false;\n        borderEast = false;\n        borderSouth = false;\n        borderWest = false;\n    }\n\n    public boolean isBorderNorth() {\n        return borderNorth;\n    }\n\n    public boolean isBorderEast() {\n        return borderEast;\n    }\n\n    public boolean isBorderSouth() {\n        return borderSouth;\n    }\n\n    public boolean isBorderWest() {\n        return borderWest;\n    }\n\n    public void setBorderNorth(boolean borderNorth) {\n        this.borderNorth = borderNorth;\n    }\n\n    public void setBorderEast(boolean borderEast) {\n        this.borderEast = borderEast;\n    }\n\n    public void setBorderSouth(boolean borderSouth) {\n        this.borderSouth = borderSouth;\n    }\n\n    public void setBorderWest(boolean borderWest) {\n        this.borderWest = borderWest;\n    }\n}\n"}, {"source": "student", "name": "student123", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n\n    private final Cell[][] grid;\n\n    private final int outerBorderx;\n    private final int outerBordery;\n\n    private int turobotx;\n    private int turoboty;\n\n    public Exercise0(){\n        this.outerBorderx = 11;\n        this.outerBordery = 8;\n        this.grid = new Cell[outerBorderx][outerBordery];\n        this.turobotx = 1;\n        this.turoboty = 6;\n\n        for(int i = 0; i < outerBorderx;i++){\n            for (int j = 0; j < outerBordery;j++){\n                this.grid[i][j] = new Cell();\n            }\n        }\n        this.setBorder(0,6,1,6);\n        this.setBorder(3,6,3,7);\n        this.setBorder(1,5,8,5);\n        this.setBorder(9,1,9,4);\n    }\n\n    private void setBorder(int startx, int starty, int endx, int endy){\n        if((endx - startx) != 0){\n            for( int i = startx; i<=endx;i++){\n                this.grid[i][starty].setBorderSouth(true);\n                this.grid[i][starty - 1].setBorderNorth(true);\n            }\n        }\n        else if((endy - starty) != 0){\n            for( int i = starty; i<=endy;i++){\n                this.grid[startx][i].setBorderWest(true);\n                this.grid[startx - 1][i].setBorderEast(true);\n            }\n        }\n    }\n    @Override\n    public String go(String goCommandString) {\n        String[] commandValue = goCommandString.split(\",\");\n        String direction = commandValue[0].substring(1);\n        int amount = Integer.parseInt(commandValue[1].substring(0,commandValue[1].length()-1));\n        switch (direction){\n            case \"no\":\n                this.moveNorth(amount);\n                break;\n            case \"so\":\n                this.moveSouth(amount);\n                break;\n            case \"ea\":\n                this.moveEast(amount);\n                break;\n            case \"we\":\n                this.moveWest(amount);\n                break;\n        }\n        return \"(\" + this.turobotx +\",\" + this.turoboty + \")\";\n    }\n\n    private void moveNorth(int amount){\n        for(int i = amount; i > 0; i--){\n            if(!this.grid[this.turobotx][this.turoboty].isBorderNorth() && this.turoboty + 1 < this.outerBordery) {\n                this.turoboty++;\n            }else return;\n        }\n    }\n    private void moveSouth(int amount){\n        for(int i = amount; i > 0; i--){\n            if(!this.grid[this.turobotx][this.turoboty].isBorderSouth() && this.turoboty - 1 >=0) {\n                this.turoboty--;\n            } else return;\n        }\n    }\n    private void moveEast(int amount){\n        for(int i = amount; i > 0; i--){\n            if(!this.grid[this.turobotx][this.turoboty].isBorderEast() && this.turobotx + 1 < this.outerBorderx) {\n                this.turobotx++;\n            }else return;\n        }\n    }\n    private void moveWest(int amount){\n        for(int i = amount; i > 0; i--){\n            if(!this.grid[this.turobotx][this.turoboty].isBorderWest() && this.turobotx - 1 >= 0) {\n                this.turobotx--;\n            }else return;\n        }\n    }\n}\n"}, {"source": "student", "name": "student123", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String go(String goCommandString);\n}\n"}, {"source": "student", "name": "student124", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Exercise0 implements GoAble {\n\n    private List<Path> walls = new ArrayList<>();\n    private Point position = new Point(8, 3);\n    private int width = 12;\n    private int height = 9;\n\n    public Exercise0() {\n        walls.add(new Path(new Point(4, 1), new Point(4, 7)));\n        walls.add(new Path(new Point(6, 2), new Point(9, 2)));\n        walls.add(new Path(new Point(6, 2), new Point(6, 5)));\n        walls.add(new Path(new Point(6, 5), new Point(9, 5)));\n    }\n\n    @Override\n    public String go(String goCommandString) {\n        String direction = goCommandString.substring(1, 3);\n        int steps = Integer.parseInt(goCommandString.substring(4, goCommandString.length() - 1));\n\n        Movement movement;\n\n        switch(direction) {\n            case \"no\":\n                movement = new Movement(\n                        new Point (position.getX(), position.getY()),\n                        new Point(position.getX(), position.getY() + steps),\n                        Movement.Direction.NORTH\n                );\n                break;\n            case \"ea\":\n                movement = new Movement(\n                        new Point (position.getX(), position.getY()),\n                        new Point(position.getX() + steps, position.getY()),\n                        Movement.Direction.EAST\n                );\n                break;\n            case \"so\":\n                movement = new Movement(\n                        new Point (position.getX(), position.getY()),\n                        new Point(position.getX(), position.getY() - steps),\n                        Movement.Direction.SOUTH\n                );\n                break;\n            case \"we\":\n                movement = new Movement(\n                        new Point (position.getX(), position.getY()),\n                        new Point(position.getX() - steps, position.getY()),\n                        Movement.Direction.WEST\n                );\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected value: \" + direction);\n        }\n\n        System.out.println(\"From: \" + movement.getFrom().toString());\n        System.out.println(\"To: \" + movement.getTo().toString());\n\n        Point collisionPoint = movement.getLastPossibleMovementPoint(walls, width, height);\n        if(collisionPoint != null) {\n            System.out.println(\"Collides with path at \" + collisionPoint);\n            position = collisionPoint;\n            return position.toString();\n        }\n\n        System.out.println(\"\");\n\n        position = movement.getTo();\n\n        return position.toString();\n    }\n}\n"}, {"source": "student", "name": "student124", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String go(String goCommandString);\n}\n"}, {"source": "student", "name": "student124", "file_name": "Movement.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.List;\n\npublic class Movement extends Path {\n\n    private Direction direction;\n\n    enum Direction {\n        NORTH,\n        EAST,\n        SOUTH,\n        WEST\n    }\n\n    public Movement(Point start, Point end, Direction direction) {\n        super(start, end);\n        this.direction = direction;\n    }\n\n    public Point getLastPossibleMovementPoint(List<Path> walls, int mapWidth, int mapHeight) {\n        // mache bewegung und \u00fcberpr\u00fcfe jedes mal ob man eine wall ber\u00fchrt auf diesem Punkt\n        Point position = getFrom();\n\n        System.out.println();\n\n        while (!position.equals(getTo())) {\n            for (Path wall: walls) {\n                if(stepCollidesWithWall(position, wall, direction)) {\n                    System.out.println(wall);\n                    System.out.println(\"Collides with wall\");\n                    return position;\n                }\n            }\n\n            Point newPosition = move(position, 1);\n\n            System.out.println(\"New position: \" + newPosition);\n\n            if(newPosition.isOutOfBounds(mapWidth, mapHeight)) {\n                System.out.println(\"Is out of bounds\");\n                return position;\n            }\n\n            position = newPosition;\n\n            System.out.println(position);\n            System.out.println(getTo());\n            System.out.println(position.equals(getTo()));\n\n            System.out.println();\n        }\n\n        return position;\n    }\n\n    private Point move(Point position, int i) {\n        switch (direction) {\n            case NORTH:\n                return new Point(position.getX(), position.getY() + 1);\n            case EAST:\n                return new Point(position.getX() + 1, position.getY());\n            case SOUTH:\n                return new Point(position.getX(), position.getY() - 1);\n            case WEST:\n                return new Point(position.getX() - 1, position.getY());\n            default:\n                throw new IllegalStateException(\"Unexpected value: \" + direction);\n        }\n    }\n\n    private boolean stepCollidesWithWall(Point position, Path wall, Direction direction) {\n\n        int pathMinX = Math.min(wall.getFrom().getX(), wall.getTo().getX());\n        int pathMaxX = Math.max(wall.getFrom().getX(), wall.getTo().getX());\n        int pathMinY = Math.min(wall.getFrom().getY(), wall.getTo().getY());\n        int pathMaxY = Math.max(wall.getFrom().getY(), wall.getTo().getY());\n\n        int x = position.getX();\n        int y = position.getY();\n\n        switch (direction) {\n            case NORTH:\n            case SOUTH:\n                // wall muss vertikal sein\n\n                // ist wall vertikal?\n                if(pathMinY == pathMaxY) {\n                    System.out.println(\"Wall ist vertikal\");\n\n                    // kann es auf y-Achse Ber\u00fchrung geben\n                    if(direction == Direction.SOUTH) {\n                        // (8,2) -> (8,1)\n                        if(y != pathMinY) {\n                            return false;\n                        }\n                    } else {\n                        // (8,1) -> (8,2)\n                        if(y + 1 != pathMinY) {\n                            return false;\n                        }\n                    }\n                    return x >= pathMinX && x < pathMaxX;\n                }\n                break;\n            default:\n                // wall muss horizontal sein\n\n                // ist wall horizontal?\n                if(pathMinX == pathMaxX) {\n                    System.out.println(\"Wall ist horizontal\");\n\n                    // kann es auf y-Achse Ber\u00fchrung geben\n                    if(direction == Direction.WEST) {\n                        // (8,2) -> (8,1)\n                        if(x != pathMinX) {\n                            return false;\n                        }\n                    } else {\n                        // (8,1) -> (8,2)\n                        if(x + 1 != pathMinX) {\n                            return false;\n                        }\n                    }\n                    return y >= pathMinY && y < pathMaxY;\n                }\n                break;\n        }\n\n        return false;\n    }\n\n    public Direction getDirection() {\n        return direction;\n    }\n}\n"}, {"source": "student", "name": "student124", "file_name": "Path.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nclass Path {\n    private Point from;\n    private Point to;\n\n    public Path(Point start, Point end) {\n        this.from = start;\n        this.to = end;\n    }\n\n    public Point getFrom() {\n        return from;\n    }\n\n    public Point getTo() {\n        return to;\n    }\n\n    @Override\n    public String toString() {\n        return \"Path{\" + \"from=\" + from + \", to=\" + to +'}';\n    }\n}"}, {"source": "student", "name": "student124", "file_name": "Point.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.Objects;\n\nclass Point {\n    private int x;\n    private int y;\n\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public boolean isOutOfBounds(int width, int height) {\n        return x >= width || y >= height || x < 0 || y < 0;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Point point = (Point) o;\n        return x == point.x && y == point.y;\n    }\n}"}, {"source": "student", "name": "student125", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.List;\n\npublic class Exercise0 implements Walkable\n{\n    private Position currentPosition;\n    private Room room;\n\n    public Exercise0()\n    {\n        //generate the room (Grid of Field objects)\n        this.room = new Room(12, 9);\n\n        //setup barriers on our individual field\n        room.setupBarrierAt(4, 1, List.of(\"we\"));\n        room.setupBarrierAt(4, 2, List.of(\"we\"));\n        room.setupBarrierAt(4, 3, List.of(\"we\"));\n        room.setupBarrierAt(4, 4, List.of(\"we\"));\n        room.setupBarrierAt(4, 5, List.of(\"we\"));\n        room.setupBarrierAt(4, 6, List.of(\"we\"));\n\n        room.setupBarrierAt(6, 2, List.of(\"we\", \"so\"));\n        room.setupBarrierAt(7, 2, List.of(\"so\"));\n        room.setupBarrierAt(8, 2, List.of(\"so\"));\n\n        room.setupBarrierAt(6, 3, List.of(\"we\"));\n\n        room.setupBarrierAt(6, 4, List.of(\"we\", \"no\"));\n        room.setupBarrierAt(7, 4, List.of(\"no\"));\n        room.setupBarrierAt(8, 4, List.of(\"no\"));\n\n        //bring our little robot into starting position\n        spawnRobotAtPosition(new Position(8, 3));\n    }\n\n    //true if robot collides with field at given position\n    private boolean collidesAtPosition(Position position, String walkDirection)\n    {\n        switch(walkDirection)\n        {\n            case \"no\":\n            {\n                return room.roomLayout[position.posX][position.posY].hasNorthernBarrier;\n            }\n            case \"so\":\n            {\n                return room.roomLayout[position.posX][position.posY].hasSouthernBarrier;\n            }\n            case \"we\":\n            {\n                return room.roomLayout[position.posX][position.posY].hasWesternBarrier;\n            }\n            case \"ea\":\n            {\n                return room.roomLayout[position.posX][position.posY].hasEasternBarrier;\n            }\n            default: {}\n        }\n\n        return false;\n    }\n\n    private void spawnRobotAtPosition(Position position)\n    {\n        this.currentPosition = position;\n    }\n\n    @Override\n    public String walk(String walkCommandString)\n    {\n        String direction = walkCommandString.split(\",\")[0].replace(\"[\", \"\");\n        int amount = Integer.valueOf(walkCommandString.split(\",\")[1].replace(\"]\", \"\"));\n\n        switch (direction)\n        {\n            case \"no\":\n            {\n                for (int i = 0; i < amount; i++)\n                {\n                    if (!collidesAtPosition(currentPosition, direction))\n                        ++currentPosition.posY;\n                }\n                break;\n            }\n            case \"so\":\n            {\n                for (int i = 0; i < amount; i++)\n                {\n                    if (!collidesAtPosition(currentPosition, direction))\n                        --currentPosition.posY;\n                }\n                break;\n            }\n            case \"ea\":\n            {\n                for (int i = 0; i < amount; i++)\n                {\n                    if (!collidesAtPosition(currentPosition, direction))\n                        ++currentPosition.posX;\n                }\n                break;\n            }\n            case \"we\":\n            {\n                for (int i = 0; i < amount; i++)\n                {\n                    if (!collidesAtPosition(currentPosition, direction))\n                        --currentPosition.posX;\n                }\n                break;\n            }\n            default: {}\n        }\n\n        return \"(\" + currentPosition.posX + \",\" + currentPosition.posY + \")\";\n    }\n\n    public class Position\n    {\n        int posX, posY;\n\n        public Position(int x, int y)\n        {\n            this.posX = x;\n            this.posY = y;\n        }\n    }\n\n    public class Room\n    {\n        public Field[][] roomLayout;\n\n        public Room(int x, int y)\n        {\n            roomLayout = new Field[x][y];\n\n            for(int i = 0; i < x; i++)\n            {\n                for (int j = 0; j < y; j++)\n                {\n                    roomLayout[i][j] = new Field();\n                }\n            }\n        }\n\n        public void setupBarrierAt(int x, int y, List<String> directions)\n        {\n            for (String direction : directions)\n            {\n                switch(direction)\n                {\n                    case \"no\":\n                    {\n                        roomLayout[x][y].hasNorthernBarrier = true;\n                        break;\n                    }\n                    case \"so\":\n                    {\n                        roomLayout[x][y].hasSouthernBarrier = true;\n                        break;\n                    }\n                    case \"we\":\n                    {\n                        roomLayout[x][y].hasWesternBarrier = true;\n                        break;\n                    }\n                    case \"ea\":\n                    {\n                        roomLayout[x][y].hasEasternBarrier = true;\n                        break;\n                    }\n                    default: {}\n                }\n            }\n        }\n    }\n\n    public class Field\n    {\n        public boolean hasNorthernBarrier;\n        public boolean hasSouthernBarrier;\n        public boolean hasWesternBarrier;\n        public boolean hasEasternBarrier;\n\n        public Field()\n        {\n            this.hasNorthernBarrier = false;\n            this.hasSouthernBarrier = false;\n            this.hasWesternBarrier = false;\n            this.hasEasternBarrier = false;\n        }\n    }\n}\n"}, {"source": "student", "name": "student125", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walk(String walkCommandString);\n}\n"}, {"source": "student", "name": "student126", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n\n    private int x;\n    private int y;\n    private String[][] movGrid;\n\n    public Exercise0() {\n        movGrid = new String[11][8];\n        x = 4;\n        y = 0;\n        initMovGrid();\n    }\n\n    private void initMovGrid() {\n        for (int i = 0; i < 6; i++) {\n            movGrid[0][i] = \"ea\";\n            movGrid[1][i] = \"we\";\n            if (i != 0) {\n                movGrid[6][i] = \"ea\";\n                movGrid[7][i] = \"we\";\n            }\n        }\n        for (int i = 1; i < 7; i++) {\n            if (i != 4) {\n                movGrid[i][5] += \" no\";\n                movGrid[i][6] += \" so\";\n            }\n        }\n    }\n\n    @Override\n    public String go(String goCommandString) {\n        String[] commands = goCommandString.substring(1, goCommandString.length() - 1).split(\",\");\n        int distance = Integer.parseInt(commands[1]);\n        switch (commands[0]) {\n            case \"no\":\n                moveNo(distance);\n                break;\n            case \"so\":\n                moveSo(distance);\n                break;\n            case \"we\":\n                moveWe(distance);\n                break;\n            case \"ea\":\n                moveEa(distance);\n        }\n        return (\"(\" + x + \",\" + y + \")\");\n    }\n\n    private void moveNo(int distance) {\n        for (int i = 0; i < distance; i++) {\n            if (movGrid[x][y] != null) {\n                String[] moves = movGrid[x][y].split(\" \");\n                if (y + 1 == 8 || moves[0].equals(\"no\") || (moves.length > 1 && moves[1].equals(\"no\"))) {\n                    break;\n                } else {\n                    y++;\n                }\n            } else if (y + 1 != 8) {\n                y++;\n            } else {\n                break;\n            }\n        }\n    }\n\n    private void moveSo(int distance) {\n        for (int i = 0; i < distance; i++) {\n            if (movGrid[x][y] != null) {\n                String[] moves = movGrid[x][y].split(\" \");\n                if (y - 1 == -1 || moves[0].equals(\"so\") || (moves.length > 1 && moves[1].equals(\"so\"))) {\n                    break;\n                } else{\n                    y--;\n                }\n            } else if (y - 1 != -1) {\n                y--;\n            } else {\n                break;\n            }\n        }\n    }\n\n    private void moveWe(int distance) {\n        for (int i = 0; i < distance; i++) {\n            if (movGrid[x][y] != null) {\n                String[] moves = movGrid[x][y].split(\" \");\n                if (x - 1 == -1 || moves[0].equals(\"we\") || (moves.length > 1 && moves[1].equals(\"we\"))) {\n                    break;\n                } else {\n                    x--;\n                }\n            } else if (x - 1 != -1) {\n                x--;\n            } else {\n                break;\n            }\n        }\n    }\n\n    private void moveEa(int distance) {\n        for (int i = 0; i < distance; i++) {\n            if (movGrid[x][y] != null) {\n                String[] moves = movGrid[x][y].split(\" \");\n                if (x + 1 == 11 || moves[0].equals(\"ea\") || (moves.length > 1 && moves[1].equals(\"ea\"))) {\n                    break;\n                } else {\n                    x++;\n                }\n            } else if (x + 1 != 11) {\n                x++;\n            } else {\n                break;\n            }\n        }\n    }\n}\n"}, {"source": "student", "name": "student126", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String go(String goCommandString);\n}\n"}, {"source": "student", "name": "student127", "file_name": "Barrier.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Barrier {\n    private int[] start;\n    private int[] end;\n\n    private Character getAxis() {\n        if (start[1]==end[1]) {\n            return 'h';\n        } else if (start[0]==end[0]) {\n            return 'v';\n        } else {\n            throw new IllegalStateException();\n        }\n    }\n\n    private Boolean isCrossingThePlane(int plane, int current, int next) {\n        return current < plane && next == plane;\n    }\n\n    private Boolean isNotInOrder(int[] currentPosition, int[] nextPosition) {\n        return currentPosition[0]==nextPosition[0] && currentPosition[1] > nextPosition[1]\n                || currentPosition[1]==nextPosition[1] && currentPosition[0] > nextPosition[0];\n    }\n\n    public Boolean isBlocking(int[] currentPosition, int[] nextPosition) {\n        //sorting to half the possible cases\n        if (isNotInOrder(currentPosition,nextPosition)) {\n            int[] temp = currentPosition;\n            currentPosition = nextPosition;\n            nextPosition = temp;\n        }\n\n        if ( getAxis() == 'h' && isCrossingThePlane(start[1], currentPosition[1], nextPosition[1]) ) {\n            return nextPosition[0] >= start[0] && nextPosition[0] < end[0];\n        } else if ( getAxis() == 'v' && isCrossingThePlane(start[0], currentPosition[0], nextPosition[0]) ) {\n            return nextPosition[1] >= start[1] && nextPosition[1] < end[1];\n        }\n\n        return false;\n    }\n\n    public Barrier(int[] start, int[] end) {\n        this.start = start;\n        this.end = end;\n    }\n\n    public static List<Barrier> getDefaultBarrierList() {\n        List<Barrier> allBarriers = new ArrayList<>();\n\n        //borders of the map\n        allBarriers.add( new Barrier(new int[]{0,0}, new int[]{0,8}) );\n        allBarriers.add( new Barrier(new int[]{0,0}, new int[]{12,0}) );\n        allBarriers.add( new Barrier(new int[]{12,0}, new int[]{12,8}) );\n        allBarriers.add( new Barrier(new int[]{0,8}, new int[]{12,8}) );\n\n        //additional barriers\n        allBarriers.add( new Barrier(new int[]{1,6}, new int[]{6,6}) );\n        allBarriers.add( new Barrier(new int[]{3,3}, new int[]{9,3}) );\n        allBarriers.add( new Barrier(new int[]{4,1}, new int[]{4,3}) );\n        allBarriers.add( new Barrier(new int[]{6,2}, new int[]{6,8}) );\n\n        return allBarriers;\n    }\n}\n"}, {"source": "student", "name": "student127", "file_name": "Direction.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic enum Direction { no, ea, so, we }\n"}, {"source": "student", "name": "student127", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport org.springframework.data.util.Pair;\n\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.function.Predicate;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Exercise0 implements Walkable {\n    // default barriers and starting position\n    private int[] position = new int[] {5, 3};\n    List<Barrier> barriers = Barrier.getDefaultBarrierList();\n\n    @Override\n    public String walk(String walkCommandString) {\n        if (!isValidInput(walkCommandString)) {\n            throw new IllegalArgumentException();\n        }\n\n        Pair<Direction, Integer> walkCommand = getPairOf(walkCommandString);\n\n        for(int currentStep = 0; currentStep < walkCommand.getSecond(); currentStep++) {\n            int[] nextPosition = getNextPosition(walkCommand.getFirst());\n\n            Predicate<Barrier> p = element -> element.isBlocking(position, nextPosition);\n            if (barriers.stream().anyMatch(p)) {\n                break;\n            }\n\n            position = nextPosition;\n        }\n\n        return \"(\" + position[0] + \",\" + position[1] + \")\";\n    }\n\n    public Boolean isValidInput(String walkCommandString) {\n        Pattern st = Pattern.compile(\"^\\\\[((no)|(ea)|(so)|(we)),\\\\d*\\\\]\\\\z$\");\n        Matcher mt = st.matcher(walkCommandString);\n        return mt.matches();\n    }\n\n    public Pair<Direction, Integer> getPairOf(String walkCommandString) {\n        final StringTokenizer st = new StringTokenizer(walkCommandString, \"[],\");\n\n        Direction direction = Direction.valueOf(st.nextToken());\n        Integer steps = Integer.parseInt(st.nextToken());\n\n        return Pair.of(direction,steps);\n    }\n\n    public int[] getNextPosition(Direction direction) {\n        switch (direction) {\n            case no:\n                return new int[] {position[0], position[1]+1};\n            case ea:\n                return new int[] {position[0]+1, position[1]};\n            case so:\n                return new int[] {position[0], position[1]-1};\n            case we:\n                return new int[] {position[0]-1, position[1]};\n            default:\n                throw new IllegalArgumentException();\n        }\n    }\n}\n"}, {"source": "student", "name": "student127", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walk(String walkCommandString);\n}\n"}, {"source": "student", "name": "student128", "file_name": "Dam.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Dam {\n\n\n    Position from, to;\n\n    public Dam() {\n    }\n\n    public Dam(Position from, Position to) {\n        this.from = from;\n        this.to = to;\n    }\n\n    public Position getFrom() {\n        return from;\n    }\n\n    public void setFrom(Position from) {\n        this.from = from;\n    }\n\n    public Position getTo() {\n        return to;\n    }\n\n    public void setTo(Position to) {\n        this.to = to;\n    }\n}"}, {"source": "student", "name": "student128", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Exercise0 implements  Walkable {\n\n    Position cleaningdvice;\n    int endof_x = 11, endof_y = 8;\n    List<Dam> damList = new ArrayList<>();\n    public Exercise0() {\n        cleaningdvice = new Position(1, 7);\n        Position damposition1 = new Position(3, 3);\n        Position damposition2 = new Position(3, 9);\n        Position damposition3 = new Position(5, 3);\n        Position damposition4 = new Position(5, 0);\n        Position damposition5 = new Position(5, 2);\n        Position damposition6 = new Position(6, 0);\n        Position damposition7 = new Position(6, 4);\n        damList.add(new Dam(damposition1, damposition2));\n        damList.add(new Dam(damposition1, damposition3));\n        damList.add(new Dam(damposition4, damposition5));\n        damList.add(new Dam(damposition6, damposition7));\n    }\n\n\n    String run_commend(String direction, int steps) {\n        switch (direction) {\n            case \"no\":\n                up_and_down(steps, 1);\n                break;\n            case \"so\":\n                up_and_down(steps, -1);\n                break;\n            case \"ea\":\n                right_and_left(steps,1);\n                break;\n            case \"we\":\n                right_and_left(steps,-1);\n                break;\n        }\n        return \"\";\n    }\n\n    private void right_and_left(int movment, int right_or_left) {\n        int right=0;if(right_or_left>0)right=1;\n        for (int i = 1; i <= movment; i++) {\n            boolean can_move = true;\n            if (cleaningdvice.getX() + right_or_left <= endof_x && cleaningdvice.getX() + right_or_left >= 0) {\n                for (Dam dam : damList) {\n                    if (dam.getFrom().getX() == dam.getTo().getX()) {\n                        if (cleaningdvice.getX()+right == dam.getFrom().getX() && cleaningdvice.getY() >= dam.getFrom().getY() && cleaningdvice.getY() < dam.getTo().getY()) {\n                            can_move = false;\n                            break;\n                        }\n                    }\n                }\n            }else can_move = false;\n            if (can_move) cleaningdvice.setX(cleaningdvice.getX()+right_or_left);\n            else break;\n        }\n    }\n\n\n\n    private void up_and_down(int movment, int up_or_down) {\n        int up=0;if(up_or_down>0)up=1;\n        for (int i = 1; i <= movment; i++) {\n            boolean can_move = true;\n            if (cleaningdvice.getY() + up_or_down <= endof_y && cleaningdvice.getY() + up_or_down >= 0) {\n                for (Dam dam : damList) {\n                    if (dam.getFrom().getY() == dam.getTo().getY()) {\n                        if (cleaningdvice.getY()+up == dam.getFrom().getY() && cleaningdvice.getX() >= dam.getFrom().getX() && cleaningdvice.getX() < dam.getTo().getX()) {\n                            can_move = false;\n                            break;\n                        }\n                    }\n                }\n            } else can_move = false;\n            if (can_move) cleaningdvice.setY(cleaningdvice.getY()+up_or_down);\n            else break;\n        }\n    }\n\n\n    @Override\n    public String walkTo(String walkCommandString) {\n        String newcommand[]=walkCommandString.replace(\"[\",\"\").replace(\"]\",\"\").split(\",\");\n        String direction=newcommand[0];\n        int steps =Integer.parseInt(newcommand[1]);\n\n\n\n        run_commend(direction,steps);\n        return cleaningdvice.toString();\n    }\n\n\n\n}\n"}, {"source": "student", "name": "student128", "file_name": "Position.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Position {\n\n\n    int x,y;\n\n    public Position() {\n    }\n\n    public Position(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public void setX(int x) {\n        this.x = x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public void setY(int y) {\n        this.y = y;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + x +\",\" + y +')';\n    }\n}\n"}, {"source": "student", "name": "student128", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "student", "name": "student129", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n    int[][] matrix = {\n            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},\n            {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n            {0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},\n            {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},\n            {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},\n            {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},\n            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n    };\n    int posX = 1;\n    int posY = 1;\n    int steps = 0;\n    boolean no_change = true;\n\n    @Override\n    public String move(String moveCommandString) {\n\n        if (moveCommandString.charAt(0) == 'n') {\n            steps = moveCommandString.charAt(3) - '0';\n            for (int i = 0; i < steps; i++) {\n                if (posY <= 0) {\n                    break;\n                } else if (matrix[posY - 1][posX] == 1) {\n                    break;\n                } else {\n                    no_change = false;\n                    posY--;\n                }\n                if (posY <= 0) {\n                    break;\n                }\n            }\n        } else if (moveCommandString.charAt(0) == 'e') {\n            steps = moveCommandString.charAt(3) - '0';\n            for (int i = 0; i < steps; i++) {\n                if (posX >= 10) {\n                    break;\n                } else {\n                    posX++;\n                }\n                if (matrix[posY][posX] == 1) {\n                    posX--;\n                    break;\n                }\n                if (posX >= 10) {\n                    break;\n                }\n            }\n\n        } else if (moveCommandString.charAt(0) == 's') {\n            steps = moveCommandString.charAt(3) - '0';\n            for (int i = 0; i < steps; i++) {\n                if (posY <= 0) {\n                    break;\n                } else if (matrix[posY + 1][posX] == 1) {\n                    break;\n                } else {\n                    no_change = false;\n                    posY++;\n                }\n                if (posY >= 8) {\n                    break;\n                }\n            }\n\n        } else if (moveCommandString.charAt(0) == 'w') {\n            steps = moveCommandString.charAt(3) - '0';\n            for (int i = 0; i < steps; i++) {\n                if (posX <= 0) {\n                    break;\n                } else {\n                    posX--;\n                }\n                if (matrix[posY][posX] == 1) {\n                    posX++;\n                    break;\n                }\n                if (posX <= 0) {\n                    break;\n                }\n            }\n        }\n        if (no_change) {\n            return \"(\" + posX + \",\" + (7 - posY) + \")\";\n        } else {\n            return \"(\" + posX + \",\" + (8 - posY) + \")\";\n        }\n        //throw new UnsupportedOperationException();\n    }\n}\n"}, {"source": "student", "name": "student129", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "student", "name": "student13", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Exercise0 implements Walkable {\n\n        final int xCoordinateSize = 12;\n        final int yCoordinateSize = 9;\n\n        int currentXPosition = 1;\n        int currentYPosition = 7;\n\n        Room r;\n        Room [][] field = new Room[xCoordinateSize][yCoordinateSize];\n\n        public void createRoom() {\n            for (int i = 0; i < xCoordinateSize; i++) {\n                for (int j = 0; j < yCoordinateSize; j++) {\n                    field[i][j] = new Room(i, j);\n                }\n            }\n        }\n\n\n    public void determineNeighbor(){\n\n        for(int i = 0; i < field.length; i++){\n            for(int j = 0; j < field[i].length; j++){\n\n                System.out.printf(\"%d,%d\\n\",i,j);\n                if(j+1 < field[i].length && field[i][j+1] != null) {\n                    field[i][j].setNorth(field[i][j + 1]);\n                }\n                if(i+1 < field.length && field[i+1][j] != null){\n                    field[i][j].setEast(field[i+1][j]);\n                }\n                if(j-1 >= 0 ){\n                    field[i][j].setSouth(field[i][j-1]);\n                }\n\n                if(i-1 >= 0 && i-1 < field[i].length && field[i-1][j] != null){\n                    field[i][j].setWest(field[i-1][j]);\n                }\n            }\n        }\n    }\n\n        public void verticallyWalls(){\n\n            //1.wall\n            for(int i = 3; i <= 8; i++ ){\n                //from east\n                field[2][i].setEast(null);\n                // from west\n                field[3][i].setWest(null);\n            }\n\n            //2.wall\n            for(int i = 0; i <= 1; i++){\n                //from east\n                field[4][i].setEast(null);\n                //from west\n                field[5][i].setWest(null);\n            }\n\n            //3.wall\n            for(int i = 0; i <= 3; i++){\n                //from east\n                field[5][i].setEast(null);\n                //from west\n                field[7][i].setWest(null);\n            }\n        }\n\n        public void horizontallyWalls(){\n                //4.wall\n                //from north\n                field[3][2].setNorth(null);\n                field[4][2].setNorth(null);\n\n                //from south\n                field[4][4].setSouth(null);\n\n\n        }\n\n    public Exercise0(){\n        createRoom();\n        determineNeighbor();\n        verticallyWalls();\n        horizontallyWalls();\n        r = field[currentXPosition][currentYPosition];\n    }\n\n    //@Override\n        public String walkTo(String walkCommandString) {\n\n            String [] coordinates = walkCommandString\n                    .substring(1,walkCommandString.length()-1)\n                    .split(\",\");\n\n            String direction = coordinates[0];\n            int numberOfSteps = Integer.parseInt(coordinates[1]);\n\n\n            switch (direction) {\n                case \"no\": r = r.moveNorth(numberOfSteps);\n                    break;\n                case \"so\": r = r.moveSouth(numberOfSteps);\n                    break;\n                case \"ea\": r = r.moveEast(numberOfSteps);\n                    break;\n                case \"we\": r = r.moveWest(numberOfSteps);\n                    break;\n            }\n\n            String xCoordinate = String.valueOf(r.xPosition);\n            String yCoordinate = String.valueOf(r.yPosition);\n            return \"(\" + xCoordinate + \",\" + yCoordinate + \")\";\n        }\n\n\n        public static void main(String[]args){\n\n            Exercise0 r = new Exercise0();\n\n//            System.out.println(r.walkTo(\"[ea,3]\"));\n//            System.out.println(r.walkTo(\"[we,2]\"));\n//            System.out.println(r.walkTo(\"[ea,4]\"));\n//            System.out.println(r.walkTo(\"[so,5]\"));\n\n            //System.out.println(r.walkTo(\"[so,5]\"));\n            //System.out.println(r.walkTo(\"[ea,1]\")); // expected position (4,0)\n\n            //HiddenTest1\n            System.out.println(r.walkTo(\"[so,5]\"));\n            System.out.println(r.walkTo(\"[ea,4]\"));\n            System.out.println(r.walkTo(\"[no,1]\"));\n            System.out.println(r.walkTo(\"[we,3]\"));\n\n\n//            System.out.println(r.walkTo(\"[so,5]\"));\n//            System.out.println(r.walkTo(\"[ea,5]\"));\n//            System.out.println(r.walkTo(\"[so,4]\"));\n//            System.out.println(r.walkTo(\"[no,5]\"));\n\n\n\n        }\n    }\n\n"}, {"source": "student", "name": "student13", "file_name": "Room.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Room {\n\n    public int xPosition;\n    public int yPosition;\n\n    private Room north;\n    private Room south;\n    private Room east;\n    private Room west;\n\n\n    public void setEast(Room east) {\n        this.east = east;\n    }\n\n    public void setNorth(Room north) {\n        this.north = north;\n    }\n\n    public void setWest(Room west) {\n        this.west = west;\n    }\n\n    public void setSouth(Room south) {\n        this.south = south;\n    }\n\n    //Konstruktor\n    public Room(int xPosition, int yPosition){\n        this.xPosition = xPosition;\n        this.yPosition = yPosition;\n    }\n\n    // TODO: public Room moveNorth(int steps){ }\n    // TODO: public Room moveSouth(int steps){ }\n    // TODO: public Room moveEast(int steps){ }\n    // TODO: public Room moveWest(int steps){ }\n\n    public Room moveNorth(int steps) {\n        if(north == null || steps == 0 ) return this;\n        return north.moveNorth(steps-1);\n    }\n\n    public Room moveSouth(int steps){\n        if(south == null || steps == 0) return this;\n        return south.moveSouth(steps-1);\n    }\n\n    public Room moveEast(int steps){\n        if(east == null || steps == 0) return this;\n        return east.moveEast(steps-1);\n    }\n\n    public Room moveWest(int steps){\n        if(west == null || steps == 0) return this;\n        return west.moveWest(steps-1);\n    }\n\n}\n"}, {"source": "student", "name": "student13", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "student", "name": "student130", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n\n    int[][] room = new int[12][9];\n    int[] robot = {8, 3};\n\n    private void init() {\n        // fill room\n        for(int i = 0; i < 11; i++)\n            for(int j = 0; j < 8; j++)\n                room[i][j] = 0;\n\n        // wall 1\n        room[4][1] = 1;\n        room[4][2] = 1;\n        room[4][3] = 1;\n        room[4][4] = 1;\n        room[4][5] = 1;\n        room[4][6] = 1;\n\n        // wall 2\n        room[7][5] = 1;\n        room[8][5] = 1;\n        room[9][5] = 1;\n\n        // wall 3\n        room[6][2] = 1;\n        room[6][3] = 1;\n        room[6][4] = 1;\n        room[6][5] = 1;\n\n        // wall 4\n        room[7][2] = 1;\n        room[8][2] = 1;\n        room[9][2] = 1;\n    }\n\n    @Override\n    public String go(String goCommandString) {\n\n        init();\n        String dir = goCommandString.substring(1, 3);\n        int len = Integer.parseInt(goCommandString.substring(4, 5));\n\n        switch (dir) {\n            case \"no\":\n                for (int i = 0; i < len; i++)\n                    if(robot[1] == 8 || (room[robot[0]][robot[1] + 1] == 1 && room[robot[0] + 1][robot[1] + 1] == 1))\n                        return \"(\" + robot[0] + \",\" + robot[1] + \")\";\n                    else robot[1] ++;\n                return \"(\" + robot[0] + \",\" + robot[1] + \")\";\n            case \"ea\":\n                for (int i = 0; i < len; i++)\n                    if(robot[0] == 11 || (room[robot[0] + 1][robot[1]] == 1 && room[robot[0] + 1][robot[1] + 1] == 1))\n                        return \"(\" + robot[0] + \",\" + robot[1] + \")\";\n                    else robot[0] ++;\n                return \"(\" + robot[0] + \",\" + robot[1] + \")\";\n            case \"so\":\n                for (int i = 0; i < len; i++)\n                    if(robot[1] == 0 || (room[robot[0]][robot[1]] == 1 && room[robot[0] + 1][robot[1]] == 1))\n                        return \"(\" + robot[0] + \",\" + robot[1] + \")\";\n                    else robot[1] --;\n                return \"(\" + robot[0] + \",\" + robot[1] + \")\";\n            case \"we\":\n                for (int i = 0; i < len; i++)\n                    if(robot[0] == 0 || (room[robot[0]][robot[1]] == 1 && room[robot[0]][robot[1] + 1] == 1))\n                        return \"(\" + robot[0] + \",\" + robot[1] + \")\";\n                    else robot[0] --;\n                return \"(\" + robot[0] + \",\" + robot[1] + \")\";\n            default: return \"\";\n        }\n    }\n}\n"}, {"source": "student", "name": "student130", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String go(String goCommandString);\n}\n"}, {"source": "student", "name": "student131", "file_name": "Dam.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Dam {\n\n\n    Position from, to;\n\n    public Dam() {}\n\n\n    public Dam(Position from, Position to) {\n            this.from = from;\n            this.to = to;\n        }\n\n        public Position getFrom () {\n            return from;\n        }\n\n        public void setFrom (Position from){\n            this.from = from;\n        }\n\n        public Position getTo () {\n            return to;\n        }\n\n        public void setTo (Position to){\n            this.to = to;\n        }\n    }"}, {"source": "student", "name": "student131", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Exercise0 implements  GoAble {\n\n    Position cleaningdvice;\n    int endof_x = 10, endof_y = 7;\n    List<Dam> damList = new ArrayList<>();\n    public Exercise0() {\n        cleaningdvice = new Position(1, 6);\n        Position damposition1 = new Position(9, 1);\n        Position damposition2 = new Position(9, 5);\n        Position damposition3 = new Position(0, 6);\n        Position damposition4 = new Position(2, 6);\n        Position damposition5 = new Position(3, 6);\n        Position damposition6 = new Position(3, 8);\n        Position damposition7 = new Position(1, 5);\n        Position damposition8 = new Position(9, 5);\n        damList.add(new Dam(damposition1, damposition2));\n        damList.add(new Dam(damposition3, damposition4));\n        damList.add(new Dam(damposition5, damposition6));\n        damList.add(new Dam(damposition7, damposition8));\n    }\n\n\n    String run_commend(String direction, int steps) {\n        switch (direction) {\n            case \"no\":\n                up_and_down(steps, 1);\n                break;\n            case \"so\":\n                up_and_down(steps, -1);\n                break;\n            case \"ea\":\n                right_and_left(steps,1);\n                break;\n            case \"we\":\n                right_and_left(steps,-1);\n                break;\n        }\n        return \"\";\n    }\n\n    private void right_and_left(int movment, int right_or_left) {\n        int right=0;if(right_or_left>0)right=1;\n        for (int i = 1; i <= movment; i++) {\n            boolean can_move = true;\n            if (cleaningdvice.getX() + right_or_left <= endof_x && cleaningdvice.getX() + right_or_left >= 0) {\n                for (Dam dam : damList) {\n                    if (dam.getFrom().getX() == dam.getTo().getX()) {\n                        if (cleaningdvice.getX()+right == dam.getFrom().getX() && cleaningdvice.getY() >= dam.getFrom().getY() && cleaningdvice.getY() < dam.getTo().getY()) {\n                            can_move = false;\n                            break;\n                        }\n                    }\n                }\n            }else can_move = false;\n            if (can_move) cleaningdvice.setX(cleaningdvice.getX()+right_or_left);\n            else break;\n        }\n    }\n\n\n\n    private void up_and_down(int movment, int up_or_down) {\n        int up=0;if(up_or_down>0)up=1;\n        for (int i = 1; i <= movment; i++) {\n            boolean can_move = true;\n            if (cleaningdvice.getY() + up_or_down <= endof_y && cleaningdvice.getY() + up_or_down >= 0) {\n                for (Dam dam : damList) {\n                    if (dam.getFrom().getY() == dam.getTo().getY()) {\n                        if (cleaningdvice.getY()+up == dam.getFrom().getY() && cleaningdvice.getX() >= dam.getFrom().getX() && cleaningdvice.getX() < dam.getTo().getX()) {\n                            can_move = false;\n                            break;\n                        }\n                    }\n                }\n            } else can_move = false;\n            if (can_move) cleaningdvice.setY(cleaningdvice.getY()+up_or_down);\n            else break;\n        }\n    }\n\n\n    @Override\n    public String go(String goCommandString) {\n        String newcommand[]=goCommandString.replace(\"[\",\"\").replace(\"]\",\"\").split(\",\");\n        String direction=newcommand[0];\n        int steps =Integer.parseInt(newcommand[1]);\n\n\n\n        run_commend(direction,steps);\n        return cleaningdvice.toString();\n    }\n\n\n\n}\n"}, {"source": "student", "name": "student131", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String go(String goCommandString);\n}\n"}, {"source": "student", "name": "student131", "file_name": "Position.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Position {\n\n\n    int x,y;\n\n    public Position() {\n    }\n\n    public Position(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public void setX(int x) {\n        this.x = x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public void setY(int y) {\n        this.y = y;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + x +\",\" + y +')';\n    }\n}\n"}, {"source": "student", "name": "student132", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n\n    private static final Integer startX = 3;\n    private static final Integer startY = 0;\n    //obstacles\n    private static final String[] obstacles = {\"(1,4)-(8,4)\", \"(3,0)-(3,3)\", \"(4,3)-(7,3)\", \"(7,0)-(7,2)\"};\n    private Integer x = startX;\n    private Integer y = startY;\n\n    @Override\n    public String walkTo(String walkCommandString) {\n        //Parse Command String\n        String direction = parseCommandDirection(walkCommandString); //north, east, south, west\n        Integer distance = parseCommandDistance(walkCommandString); //Integer\n\n        return move(distance, direction);\n    }\n\n\n    private String parseCommandDirection(String walkCommandString) {\n        if (walkCommandString.contains(\"no\")) {\n            return \"north\";\n        } else if (walkCommandString.contains(\"ea\")) {\n            return \"east\";\n        } else if (walkCommandString.contains(\"so\")) {\n            return \"south\";\n        } else if (walkCommandString.contains(\"we\")) {\n            return \"west\";\n        } else {\n            return \"\";\n        }\n    }\n\n    private Integer parseCommandDistance(String walkCommandString) {\n        return Character.getNumericValue(walkCommandString.toCharArray()[4]);\n    }\n\n    private String move(Integer dis, String dir) {\n        if (dis > 0) {\n            switch (dir) {\n                case \"north\":\n                    if (canMove(dir)) this.y++;\n                    break;\n                case \"east\":\n                    if (canMove(dir)) this.x++;\n                    break;\n                case \"south\":\n                    if (canMove(dir)) this.y--;\n                    break;\n                case \"west\":\n                    if (canMove(dir)) this.x--;\n                    break;\n            }\n            return move(dis - 1, dir);\n        } else {\n            return \"(\" + x + \",\" + y + \")\";\n        }\n    }\n\n    private Boolean canMove(String dir) {\n        for (String s : obstacles) {\n            char[] obstacle = s.toCharArray();\n            Integer x1 = Character.getNumericValue(obstacle[1]);\n            Integer x2 = Character.getNumericValue(obstacle[7]);\n            Integer y1 = Character.getNumericValue(obstacle[3]);\n            Integer y2 = Character.getNumericValue(obstacle[9]);\n\n            if (x == 0 && dir.equals(\"west\")) return false;\n            if (y == 0 && dir.equals(\"south\")) return false;\n            if (x == 11 && dir.equals(\"east\")) return false;\n            if (y == 7 && dir.equals(\"north\")) return false;\n\n            if (x1.equals(x2) && y1 <= y && y < y2) {\n                if (x.equals(x1) && dir.equals(\"west\")) {\n                    return false;\n                } else if (x.equals(x1 - 1) && dir.equals(\"east\")) {\n                    return false;\n                }\n            } else if (y1.equals(y2) && x1 <= x && x < x2) {\n                if (y.equals(y1) && dir.equals(\"south\")) {\n                    return false;\n                } else if (y.equals(y1 - 1) && dir.equals(\"north\")) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n}"}, {"source": "student", "name": "student132", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "student", "name": "student134", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n\n    /**\n     * Initialisierung der Koordinaten des Roboters und\n     * den Waenden.\n     */\n\n    private String robot_coordinates = \"5,3\";\n    private int robot_x = Integer.parseInt(robot_coordinates.substring(0,1));\n    private int robot_y = Integer.parseInt(robot_coordinates.substring(2));\n\n    private String[] wall1_coordinates = {\"1,6\",\"2,6\",\"3,6\",\"4,6\",\"5,6\",\"6,6\"};\n    private String[] wall2_coordinates = {\"6,8\",\"6,7\",\"6,6\",\"6,5\",\"6,4\",\"6,3\",\"6,2\"};\n    private String[] wall3_coordinates = {\"3,3\",\"4,3\",\"5,3\",\"6,3\",\"7,3\",\"8,3\",\"9,3\"};\n    private String[] wall4_coordinates = {\"4,1\",\"4,2\",\"4,3\"};\n\n    @Override\n\n    /**\n     * Methode walk:\n     * Der Roboter bewegt sich abhaengig davon ob der Weg frei ist.\n     * @param walkCommandString Der Befehl, wie der Roboter sich bewegen soll, wird uebergeben. (Richtung, Schrittanzahl)\n     * @return robot_coordinates gibt den aktuellen Standpunkt des Roboters wieder.\n     */\n\n    public String walk(String walkCommandString) {\n\n\n        // Der String Befehl wird aufgeteilt in 2 Strings:\n        // Die Richtung \"direction\" und die Schrittanzahl \"steps\"\n        String direction = walkCommandString.substring(1,3);\n        int steps = Integer.parseInt(walkCommandString.substring(4,5));\n\n            switch (direction) {\n                case \"no\": {\n                    // For-Schleifen laeufen solange wie es Schritte gibt.\n                    for (int i = 0; i < steps; i++) {\n                        if (robot_y < 7) {\n                            // Methode test wird aufgerufen und die Variable \"direction wird uebergeben\"\n                            if (test(direction) == true) {\n                                robot_y++;\n                            }\n                        }\n                    }\n                    break;\n                }\n\n                case \"ea\": {\n                    for (int i = 0; i < steps; i++) {\n                        if (robot_x < 11) {\n                            if (test(direction) == true) {\n                                robot_x++;\n                            }\n                        }\n                    }\n                    break;\n                }\n\n                case \"so\": {\n                    for (int i = 0; i < steps; i++) {\n                        if (robot_y > 0) {\n                            if (test(direction) == true) {\n                                robot_y--;\n                            }\n                        }\n                    }\n                    break;\n                }\n\n                case \"we\": {\n                    for (int i = 0; i < steps; i++) {\n                        if (robot_x > 0) {\n                            if (test(direction) == true) {\n                                robot_x--;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n        // Konvertiert die Werte vom Typen Integer in die gewuenschte String Syntax um.\n        robot_coordinates = \"(\" + String.valueOf(robot_x) + \",\" + String.valueOf(robot_y) + \")\";\n        return robot_coordinates;\n    }\n\n    /**\n     * Methode no:\n     * Prueft ob in der Richtung Norden eine Wand existiert.\n     * @param wall die Koordinaten der Wand werden uebergeben.\n     * @return boolean \n     */\n\n    public boolean no(String [] wall){\n        \n        // Zaehler der anfaengt zu zaehlen wenn ein Wandpunkt erreicht wird.\n        int wall_counter = 0;\n\n        for (int i = 0; i < wall.length; i++){\n            // Prueft ob bei dem naechsten Schritt ein Wandpunkt vorhanden ist.\n            if (wall[i].equals(robot_x + \",\" + (robot_y + 1))){\n                wall_counter++;\n            }\n            if (wall[i].equals((robot_x + 1) + \",\" + (robot_y + 1))){\n                wall_counter++;\n            }\n        }\n        if(wall_counter == 2){\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Methode so:\n     * Prueft ob in der Richtung Sueden eine Wand existiert.\n     * @param wall die Koordinaten der Wand werden uebergeben.\n     * @return\n     */\n    public boolean so(String [] wall){\n\n        int wall_counter = 0;\n        for (int i = 0; i < wall.length; i++){\n            if (wall[i].equals(robot_x + \",\" + (robot_y))){\n                wall_counter++;\n            }\n            if (wall[i].equals((robot_x + 1) + \",\" + robot_y)){\n                wall_counter++;\n            }\n        }\n        if(wall_counter == 2){\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Methode ea:\n     * Prueft ob in der Richtung Osten eine Wand existiert.\n     * @param wall\n     * @return boolean\n     */\n\n    public boolean ea(String [] wall){\n\n        int wall_counter = 0;\n        String a = (robot_x + 1) + \",\" + (robot_y + 1);\n        String b = (robot_x + 1) + \",\" + robot_y;\n        for (int i = 0; i < wall.length; i++){\n            if (wall[i].equals(a)){\n                wall_counter++;\n            }\n            if (wall[i].equals(b)){\n                wall_counter++;\n            }\n        }\n        if(wall_counter == 2){\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Methode we:\n     * Prueft ob in der Richtung Westen eine Wand existiert.\n     * @param wall\n     * @return\n     */\n\n    public boolean we(String [] wall){\n\n        int wall_counter = 0;\n        for (int i = 0; i < wall.length; i++){\n            if (wall[i].equals(robot_x + \",\" + (robot_y + 1))){\n                wall_counter++;\n            }\n            if (wall[i].equals(robot_coordinates)){\n                wall_counter++;\n            }\n        }\n        if(wall_counter == 2){\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Methode no_so_ea_we:\n     * @param wall\n     * @param direction\n     * @return\n     */\n\n    public boolean no_so_ea_we(String [] wall, String direction) {\n        switch (direction) {\n            case \"no\":\n                if (no(wall) == false) return false;\n                break;\n            case \"so\":\n                if (so(wall) == false) return false;\n                break;\n            case \"ea\":\n                if (ea(wall) == false) return false;\n                break;\n            case \"we\":\n                if (we(wall) == false) return false;\n                break;\n        }\n        return true;\n    }\n\n    /**\n     * Methode test:\n     * @param direction\n     * @return\n     */\n\n    public boolean test(String direction){\n\n        if(no_so_ea_we(wall1_coordinates,direction) == false)\n            return false;\n        if(no_so_ea_we(wall2_coordinates,direction) == false)\n            return false;\n        if(no_so_ea_we(wall3_coordinates,direction) == false)\n            return false;\n        if(no_so_ea_we(wall4_coordinates,direction) == false)\n            return false;\n        return true;\n    }\n}\n"}, {"source": "student", "name": "student134", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walk(String walkCommandString);\n}\n"}, {"source": "student", "name": "student135", "file_name": "Barrier.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Barrier {\n    private Vector2 start;\n    private Vector2 end;\n    private boolean isHorizontal;\n\n    public Barrier(Vector2 _start, Vector2 _end) {\n        if(_start.x == _end.x || _start.y == _end.y){\n            start = _start;\n            end = _end;\n            isHorizontal = start.y == end.y;\n        }\n    }\n\n    public boolean checkCross(Vector2 pos, Vector2 dir){\n        if(isHorizontal && start.x <= pos.x && pos.x < end.x){\n            if(pos.y < start.y && pos.add(dir).y >= start.y){\n                return true;\n            }\n            else if(pos.y >= start.y && pos.add(dir).y <= start.y){\n                return true;\n            }\n        }\n        else if(!isHorizontal && start.y <= pos.y && pos.y < end.y){\n            if(pos.x < start.x && pos.add(dir).x >= start.x){\n                return true;\n            }\n            else if(pos.x >= start.x && pos.add(dir).x <= start.x){\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public Vector2 limit(Vector2 pos){\n        Vector2 res = pos.clone();\n        if(isHorizontal){\n            if(pos.y > start.y){\n                res.y = start.y;\n            }\n            else{\n                res.y = start.y-1;\n            }\n        }\n        else{\n            if(pos.x > start.x){\n                res.x = start.x;\n            }\n            else{\n                res.x = start.x-1;\n            }\n        }\n        return res;\n    }\n}\n"}, {"source": "student", "name": "student135", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Exercise0 implements GoAble {\n\n    Map map = new Map(new Vector2(0,2),\n            new Vector2(12,9),\n            new Barrier(new Vector2(3,0), new Vector2(3,3)),\n            new Barrier(new Vector2(5,0), new Vector2(5,4)),\n            new Barrier(new Vector2(4,5), new Vector2(7,5)),\n            new Barrier(new Vector2(7,5), new Vector2(7,9))\n            );\n\n    public Exercise0(){\n\n    }\n    @Override\n    public String go(String goCommandString) {\n        Vector2 dir = decypher(goCommandString);\n        Vector2 newPos = map.getPlayerPosition().add(dir);\n        for(Barrier b: map.getBarriers()){\n            if(b.checkCross(map.getPlayerPosition(),dir)){\n                Vector2 possibleNewPos = b.limit(map.getPlayerPosition());\n                if(possibleNewPos.clone().add(map.getPlayerPosition().multiply(-1)).length() < newPos.clone().add(map.getPlayerPosition().multiply(-1)).length()){\n                    newPos = possibleNewPos;\n                }\n            }\n        }\n        if(newPos.x >= map.getDimensions().x){\n            newPos.x = map.getDimensions().x-1;\n        }\n        else if(newPos.x < 0){\n            newPos.x = 0;\n        }\n        if(newPos.y >= map.getDimensions().y){\n            newPos.y = map.getDimensions().y-1;\n        }\n        else if(newPos.y < 0){\n            newPos.y = 0;\n        }\n        map.setPlayerPosition(newPos);\n        return map.getPlayerPosition().toString();\n    }\n\n    public Vector2 decypher(String s){\n        Vector2 dir = new Vector2(0,0);\n        Pattern p = Pattern.compile(\"\\\\[(so|we|no|ea),\\\\d+]\");\n        Matcher m = p.matcher(s);\n        if(m.matches()){\n            p = Pattern.compile(\"(so|no|ea|we)\");\n            Matcher a = p.matcher(s);\n            a.find();\n            switch(a.group()){\n                case \"no\":\n                    dir.y += 1;\n                    break;\n                case \"ea\":\n                    dir.x += 1;\n                    break;\n                case \"so\":\n                    dir.y -= 1;\n                    break;\n                case \"we\":\n                    dir.x -= 1;\n                    break;\n            }\n\n            p = Pattern.compile(\"\\\\d+\");\n            a = p.matcher(s);\n            a.find();\n            dir.multiply(Integer.parseInt(a.group()));\n        }\n        return dir;\n    }\n}\n"}, {"source": "student", "name": "student135", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String go(String goCommandString);\n}\n"}, {"source": "student", "name": "student135", "file_name": "Map.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.ArrayList;\n\npublic class Map {\n    private Vector2 player;\n    private Vector2 dimensions;\n    private ArrayList<Barrier> barriers = new ArrayList<Barrier>();\n\n    public Map(Vector2 player, Vector2 dimensions, Barrier... barriers){\n        this.player = player;\n        this.dimensions = dimensions;\n        for(Barrier b: barriers){\n            this.barriers.add(b);\n        }\n    }\n\n    public Vector2 getPlayerPosition(){\n        return player.clone();\n    }\n\n    public void setPlayerPosition(Vector2 pos){\n        player.x = pos.x;\n        player.y = pos.y;\n    }\n\n    public Vector2 getDimensions(){\n        return dimensions.clone();\n    }\n\n    public ArrayList<Barrier> getBarriers(){\n        return (ArrayList<Barrier>) barriers.clone();\n    }\n\n    public void addBarrier(Barrier b){\n        barriers.add(b);\n    }\n\n    public void addBarrier(Vector2 start, Vector2 end) throws Exception {\n        barriers.add(new Barrier(start, end));\n    }\n\n\n}\n"}, {"source": "student", "name": "student135", "file_name": "Vector2.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Vector2 {\n    int x, y;\n    Vector2(int _x, int _y){\n        x = _x;\n        y = _y;\n    }\n\n    public Vector2 add(Vector2 c){\n        x += c.x;\n        y += c.y;\n        return this;\n    }\n\n    public Vector2 multiply(int skalar){\n        x *= skalar;\n        y *= skalar;\n        return this;\n    }\n\n    public Vector2 clone(){\n        return new Vector2(this.x, this.y);\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + x + ',' + y + ')';\n    }\n\n    public double length(){\n        return Math.sqrt(x*x + y*y);\n    }\n}\n"}, {"source": "student", "name": "student137", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n    int startY = 7;\n    int startX = 11;\n    @Override\n    public String goTo(String goCommandString) {\n        // throw new UnsupportedOperationException();\n\n        String direction = goCommandString.substring(1,3); // substring the incoming value for direction\n        int amount = Integer.parseInt(goCommandString.substring(4,5)); // substring incoming value for moving amount\n\n        // define raster with bounds\n        int  [][] lab = new int [8][12]; // define array size\n        // define the blocked directions per field\n        int  [] WEarray = {1, 5, 8, 9, 11, 12};\n        int  [] NOarray = {2, 5, 6, 9, 10, 12};\n        int  [] EAarray = {3, 6, 7, 9, 10, 11};\n        int  [] SOarray = {4, 7, 8, 10, 11, 12};\n        // fill entire array with 0\n        for(int y = 0; y <8; y++) {\n            for(int x = 0; x < 12; x++){\n                lab[y][x] = 0;\n            }\n        }\n        // fill outer barrier\n        for(int x = 1; x <11; x++) {\n            lab[0][x] = 4;\n        }\n        for(int x = 1; x <11; x++) {\n            lab[7][x] = 2;\n        }\n        for(int y = 1; y <7; y++) {\n            lab[y][0] = 1;\n        }\n        for(int y = 1; y <7; y++) {\n            lab[y][11] = 3;\n        }\n        // fill outer corner barrier\n        lab[0][0] = 8;\n        lab[0][11] = 7;\n        lab[7][0] = 5;\n        lab[7][11] = 6;\n\n        // define specific barriers inside the raster\n        for(int x = 5; x <11; x++) {\n            lab[6][x] = 4;\n        }\n        for(int x = 6; x <11; x++) {\n            lab[5][x] = 2;\n        }\n        for(int y = 2; y <5; y++) {\n            lab[y][6] = 1;\n        }\n        for(int y = 2; y <4; y++) {\n            lab[y][5] = 3;\n        }\n        lab[5][5] = 12;\n        lab[4][5] = 6;\n        lab[5][4] = 3;\n        lab[6][11] = 7;\n        lab[5][11] = 6;\n\n        // switch case to move depending on direction\n        // first checking current field value to decide if movement in direction is possible.\n        // moving one field in direction and checking for next movement\n        // movement aborts on hitting any barrier, stays in current position and continues with direction change for another movement test\n        switch (direction) {\n\n            case \"we\" : outerloop:\n                        for (int m = 0; m < amount; m++) { // itterate in single steps for every move\n                            for (int i : WEarray) { // check for every step if movement in direction is possible\n                                if (lab[startY][startX] == i) { // if movement is not possible in desired direction, abort action\n                                    break outerloop; // abort outer loop\n                                }\n                            }\n                            startX = startX - 1; // if movement is possible, continue by one value (in this case negative x) and repeat loop\n                        }\n                        break;\n\n            case \"no\" : outerloop:\n                        for (int m = 0; m < amount; m++) { // see documentation for \"we\" movement\n                            for (int i : NOarray) {\n                                if (lab[startY][startX] == i) {\n                                    System.out.println();\n                                    break outerloop;\n                                }\n                            }\n                            startY = startY + 1;\n                        }\n                            break;\n\n            case \"ea\" : outerloop:\n                        for (int m = 0; m < amount; m++) { // see documentation for \"we\" movement\n                            for (int i : EAarray) {\n                                if (lab[startY][startX] == i) {\n                                    break outerloop;\n                                }\n                            }\n                            startX = startX + 1;\n                        }\n                            break;\n\n            case \"so\" : outerloop:\n                        for (int m = 0; m < amount; m++) { // see documentation for \"we\" movement\n                            for (int i : SOarray) {\n                                if (lab[startY][startX] == i) {\n                                    break outerloop;\n                                }\n                            }\n                            startY = startY - 1;\n                        }\n                            break;\n        }\n\n        //test output of outta bounds\n/*\n        for(int y = 7; y>=0; y--) {\n            for(int x = 0; x < 12; x++){\n                System.out.print(lab[y][x] + \"  \");\n            }\n            System.out.println();\n        }\n        System.out.println();\n\n */\n\n        return \"(\" + startX + \",\"  + startY + \")\";\n    }\n}\n"}, {"source": "student", "name": "student137", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n\n    String goTo(String goCommandString);\n\n}\n"}, {"source": "student", "name": "student138", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n    int posx = 4;\n    int posy = 7;\n    int[][] cord = {\n            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n            {0, 2, 2, 2, 0, 2, 2, 0, 0, 0, 0},\n            {0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0},\n            {0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0},\n            {0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0},\n            {0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0},\n            {0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0},\n            {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}};\n    @Override\n    public String goTo(String goCommandString) {\n        String[] commands = goCommandString.split(\",\");\n        String direction = commands[0].replace(\"[\", \"\");\n        int amount = Integer.parseInt(commands[1].replace(\"]\", \"\"));\n\n        int u = cord[7][4];\n        for (int i = 0; i < amount; i++)\n        {\n            switch (direction)\n            {\n                case \"no\":\n                    if (posy != 0)\n                    {\n                        if (cord[posy - 1][posx] != 2)\n                            posy--;\n                    }\n                    break;\n                case \"ea\":\n                    if (posx != 10)\n                    {\n                        if (cord[posy][posx + 1] != 1)\n                            posx++;\n                    }\n                    break;\n                case \"so\":\n                    if (posy != 7)\n                    {\n                        if (cord[posy][posx] != 2)\n                            posy++;\n                    }\n                    break;\n                case \"we\":\n                    if (posx != 0)\n                    {\n                        if (cord[posy][posx] != 1)\n                            posx--;\n                    }\n                    break;\n            }\n        }\n\n        return \"(\" + posx + \",\" + (7 - posy) + \")\";\n    }\n\n    public static void main(String[] args){\n        Exercise0 ex =  new Exercise0();\n        String res = ex.goTo(\"[no,5]\");\n        res = ex.goTo(\"[we,3]\");\n        res = ex.goTo(\"[so,2]\");\n        res = ex.goTo(\"[ea,1]\");\n\n    }\n}\n"}, {"source": "student", "name": "student138", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "student", "name": "student140", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\n\npublic class Exercise0 implements GoAble {\n    static String[][] grid = new String[11][8];\n    int positionX = 1;\n    int positionY = 6;\n\n    public static void initialize() {\n        grid[0][6] = \"horizontal\";\n        grid[1][6] = \"horizontal\";\n\n        grid[3][6] = \"vertical\";\n        grid[3][7] = \"vertical\";\n\n        grid[1][5] = \"horizontal\";\n        grid[2][5] = \"horizontal\";\n        grid[3][5] = \"horizontal\";\n        grid[4][5] = \"horizontal\";\n        grid[5][5] = \"horizontal\";\n        grid[6][5] = \"horizontal\";\n        grid[7][5] = \"horizontal\";\n        grid[8][5] = \"horizontal\";\n\n        grid[9][1] = \"vertical\";\n        grid[9][2] = \"vertical\";\n        grid[9][3] = \"vertical\";\n        grid[9][4] = \"vertical\";\n    }\n\n    @Override\n    public String go(String goCommandString) {\n        initialize();\n\n        String direction = \"\";\n        String commandStart = \"\";\n        String commandEnd = \"\";\n\n        String[] stringSplit = goCommandString.split(\",\");\n\n        if(stringSplit.length > 1) {\n        direction = stringSplit[0].substring(1);\n        commandStart = stringSplit[0].substring(0,1);\n\n\n            commandEnd = stringSplit[1].substring(stringSplit[1].length() - 1);\n        }\n\n\n        if(commandStart.equals(\"[\") && commandEnd.equals(\"]\")) {\n\n            int count;\n            try {\n                count = Integer.parseInt(stringSplit[1].substring(0, stringSplit[1].length() - 1));\n            } catch (NumberFormatException e) {\n                count = 0;\n            }\n\n\n            switch (direction) {\n                case \"no\":\n                    if (count >= 0) {\n                        for (int counter = 0; counter < count; counter++) {\n                            if (positionY + 1 < grid[1].length) {\n                                if (grid[positionX][positionY + 1] == null || grid[positionX][positionY + 1] == \"vertical\") {\n                                    positionY += 1;\n                                } else if (grid[positionX][positionY + 1] == \"horizontal\") {\n                                    break;\n                                }\n                            } else break;\n                        }\n                    } else if (count < 0) {\n                        count *= -1;\n                        go(\"[so\" + \",\" + count + \"]\");\n                    }\n                    break;\n\n                case \"ea\":\n                    if (count >= 0) {\n                        for (int counter = 0; counter < count; counter++) {\n                            if (positionX + 1 < grid.length) {\n                                if (grid[positionX + 1][positionY] == null || grid[positionX + 1][positionY] == \"horizontal\") {\n                                    positionX += 1;\n                                } else if (grid[positionX + 1][positionY] == \"vertical\") {\n                                    break;\n                                }\n                            } else break;\n                        }\n                    } else if (count < 0) {\n                        count *= -1;\n                        go(\"[we\" + \",\" + count + \"]\");\n                    }\n                    break;\n                case \"so\":\n                    if (count >= 0) {\n                        if (grid[positionX][positionY] != \"horizontal\") {\n                            for (int counter = 0; counter < count; counter++) {\n                                if (positionY - 1 >= 0) {\n                                    if (grid[positionX][positionY - 1] == null || grid[positionX][positionY - 1] == \"vertical\") {\n                                        positionY -= 1;\n                                    } else if (grid[positionX][positionY - 1] == \"horizontal\") {\n                                        positionY -= 1;\n                                        break;\n                                    }\n                                } else break;\n                            }\n                        }\n                    } else if (count < 0) {\n                        count *= -1;\n                        go(\"[no\" + \",\" + count + \"]\");\n                    }\n                    break;\n                case \"we\":\n                    if (count >= 0) {\n                        if (grid[positionX][positionY] != \"vertical\") {\n                            for (int counter = 0; counter < count; counter++) {\n                                if (positionX - 1 >= 0) {\n                                    if (grid[positionX - 1][positionY] == null || grid[positionX - 1][positionY] == \"horizontal\") {\n                                        positionX -= 1;\n                                    } else if (grid[positionX - 1][positionY] == \"vertical\") {\n                                        positionX -= 1;\n                                        break;\n                                    }\n                                } else break;\n                            }\n                        }\n                    } else if (count < 0) {\n                        count *= -1;\n                        go(\"[ea\" + \",\" + count + \"]\");\n                    }\n                    break;\n            }\n\n        }\n        return \"(\" + positionX + \",\" + positionY + \")\";\n    }\n}"}, {"source": "student", "name": "student140", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String go(String goCommandString);\n}"}, {"source": "student", "name": "student142", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class  Exercise0 implements GoAble {\n\n    int X_MAX = 12;\n    int Y_MAX = 9;\n\n    int xDroid = 0;\n    int yDroid = 0;\n\n\n    class Obstacle{\n        boolean North = false;\n        boolean South = false;\n        boolean East = false;\n        boolean West = false;\n    }\n\n    public Exercise0(){\n        InitializeDeck();\n    }\n\n    public static void main(String[] args){\n        Exercise0 ex = new Exercise0();\n        System.out.println(ex.goTo(\"[so,5]\"));\n        System.out.println(ex.goTo(\"[ea,5]\"));\n        System.out.println(ex.goTo(\"[so,4]\"));\n        System.out.println(ex.goTo(\"[no,5]\"));\n    }\n\n    Obstacle [][] obstaclesInDeck = new Obstacle[X_MAX][Y_MAX];\n\n    public enum Direction{\n        North, South, East, West, None\n    }\n\n    void goToDirection(Direction d, int steps){\n\n        if (steps <= 0)\n            return;\n\n        int newX = xDroid;\n        int newY = yDroid;\n\n        switch (d){\n            case North:\n                newY = newY +1;\n                break;\n            case South:\n                newY = newY-1;\n                break;\n            case East:\n                newX = newX +1;\n                break;\n            case West:\n                newX = newX-1;\n                break;\n        }\n\n        if (newX < 0 || newX >= X_MAX || newY < 0 || newY >= Y_MAX)\n            return;\n\n        boolean obstacleExists = false;\n\n        switch  (d){\n            case North:\n                obstacleExists = obstaclesInDeck[xDroid][yDroid].North ||\n                        obstaclesInDeck[newX][newY].South;\n                break;\n            case South:\n                obstacleExists = obstaclesInDeck[xDroid][yDroid].South ||\n                        obstaclesInDeck[newX][newY].North;\n                break;\n\n            case West:\n                obstacleExists = obstaclesInDeck[xDroid][yDroid].West ||\n                        obstaclesInDeck[newX][newY].East;\n                break;\n\n            case East:\n                obstacleExists = obstaclesInDeck[xDroid][yDroid].East ||\n                        obstaclesInDeck[newX][newY].West;\n                break;\n        }\n        if (!obstacleExists){\n            xDroid = newX;\n            yDroid = newY;\n            goToDirection(d, steps-1);\n        }else{\n            // obstacle found. exit\n        }\n    }\n\n    void InitializeDeck(){\n        xDroid = 1;\n        yDroid = 7;\n\n        for( int i = 0; i < X_MAX; i++)\n            for( int j = 0; j < Y_MAX; j++)\n                obstaclesInDeck[i][j] = new Obstacle();\n\n\n\n        for( int j = 3; j < Y_MAX; j++)\n            obstaclesInDeck[3][j].West = true;\n\n        obstaclesInDeck[3][2].North = true;\n        obstaclesInDeck[4][2].North = true;\n\n        obstaclesInDeck[4][0].East = true;\n        obstaclesInDeck[4][1].East = true;\n\n        obstaclesInDeck[5][0].East = true;\n        obstaclesInDeck[5][1].East = true;\n        obstaclesInDeck[5][2].East = true;\n        obstaclesInDeck[5][3].East = true;\n\n    }\n\n    @Override\n    public String goTo(String goCommandString) {\n        boolean found = false;\n        goCommandString = goCommandString.toLowerCase();\n        String dirString = \"\";\n        String stepString = \"\";\n\n        int indexBrakeLeft = goCommandString.indexOf(\"[\");\n        if (indexBrakeLeft >=0){\n            int indexComma = goCommandString.indexOf(\",\", indexBrakeLeft + 1);\n            if (indexComma >= 0){\n                dirString = goCommandString.substring(indexBrakeLeft +1, indexComma);\n                int indexBrakeRight = goCommandString.indexOf(\"]\", indexComma+1);\n                if (indexBrakeRight >= 0){\n                    stepString = goCommandString.substring(indexComma + 1, indexBrakeRight);\n                    found = true;\n                }\n            }\n        }\n\n        if (found){\n            Direction d = Direction.None;\n            switch(dirString){\n                case \"no\": d = Direction.North; break;\n                case \"ea\": d = Direction.East; break;\n                case \"so\": d = Direction.South; break;\n                case \"su\": d = Direction.South; break;\n                case \"we\": d = Direction.West; break;\n            }\n            int steps = Integer.parseInt(stepString);\n            goToDirection(d,steps);\n        }\n\n        String newPosition = \"(\" + xDroid + \",\" + yDroid + \")\";\n        return newPosition;\n\n    }\n\n}\n\n"}, {"source": "student", "name": "student142", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "student", "name": "student143", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n\n    enum Direction {NORTH, SOUTH, EAST, WEST};\n    class Coordinate {\n        public int x;\n        public int y;\n        public Coordinate(int x, int y){this.x = x; this.y = y;}\n        @Override\n        public String toString() { return \"(\" + x + \",\" + y + ')'; }\n    }\n\n    class Wall {\n        public Coordinate start;\n        public Coordinate end;\n        public Wall(Coordinate start, Coordinate end){this.start = start; this.end = end;}\n    }\n\n    Wall [] walls;\n    Coordinate miningMachine;\n\n    // little helper function to look if the mining machine\n    // is at the same level as a wall\n    private boolean between(int i, int first, int second) {\n        int min = Integer.min(first,second);\n        int max = Integer.max(first,second);\n        return  (i >= min && i < max) ;\n    }\n\n    private void moveMachine(Direction direction, int steps){\n\n        // movement boundaries for the mining machine\n        int maxRight = Integer.MAX_VALUE;\n        int maxLeft = Integer.MIN_VALUE;\n        int maxTop = Integer.MAX_VALUE;\n        int maxBottom = Integer.MIN_VALUE;\n\n        // get the smallest bound\n        for(Wall wall : walls){\n            // if there is a wall at the same ground area\n            if(between(miningMachine.x,wall.end.x,wall.start.x)){\n                // get the vertical distance\n                int distance = wall.start.y - miningMachine.y;\n                if(distance > 0){ // wall at the top\n                    distance--; // correction due to coordinate at bottom left corner\n                    if(distance < maxTop){ maxTop = distance;}\n                } else {  // wall at bottom\n                    if(distance > maxBottom){maxBottom = distance;}\n                }\n            }\n            // if there is a wall at the same height\n            if(between(miningMachine.y,wall.end.y, wall.start.y)){\n                int distance = wall.start.x - miningMachine.x;\n                if(distance > 0){ // wall at right\n                    distance--; // correction due to coordinate at bottom left corner\n                    if(distance < maxRight){maxRight=distance;}\n                } else {\n                    if(distance > maxLeft){maxLeft=distance;}\n                }\n            }\n        }\n\n        // do the steps for the mining machine\n        switch (direction){\n            case NORTH:\n                int stepsUp = Integer.min(maxTop,steps);\n                miningMachine.y += stepsUp;\n                break;\n            case EAST:\n                int stepsRight = Integer.min(maxRight,steps);\n                miningMachine.x += stepsRight;\n                break;\n            case WEST:\n                int stepsLeft = Integer.min(-maxLeft,steps);\n                miningMachine.x -= stepsLeft;\n                break;\n            case SOUTH:\n                int stepsDown = Integer.min(-maxBottom,steps);\n                miningMachine.y -= stepsDown;\n        }\n    }\n\n    public Exercise0() {\n        miningMachine = new Coordinate(11,7);\n        walls = new Wall [] {\n                // boundaries\n                new Wall(new Coordinate(0,0), new Coordinate(12,0)),  // bottom\n                new Wall(new Coordinate(0, 8), new Coordinate(12,8)), // top\n                new Wall(new Coordinate(0,0), new Coordinate(0,8)),   // left\n                new Wall(new Coordinate(12,0), new Coordinate(12,8)), // right\n\n                // normal walls\n                new Wall(new Coordinate(6,2), new Coordinate(6,5)),\n                new Wall(new Coordinate(5,5), new Coordinate(6,5)),\n                new Wall(new Coordinate(5,5), new Coordinate(5,6)),\n                new Wall(new Coordinate(5,6), new Coordinate(12,6))\n        };\n    }\n\n\n\n    @Override\n    public String walkTo(String walkCommandString) {\n\n        // parse string somehow\n        // get steps\n        int steps = Integer.parseInt(walkCommandString.replaceAll(\"[^0-9]\",\"\"));\n        // get direction\n        Direction direction;\n        String str = walkCommandString.replaceAll(\"[\\\\[|\\\\]|0-9]|\\\\,\",\"\");\n        if(str.equals(\"we\")){ direction = Direction.WEST;}\n        else if(str.equals(\"no\")){direction = Direction.NORTH;}\n        else if(str.equals(\"so\")){direction = Direction.SOUTH;}\n        else if(str.equals(\"ea\")){direction = Direction.EAST;}\n        else { throw new IllegalArgumentException(\"couldn't parse string argument for walkTo\"); }\n\n        // do the movement\n        moveMachine(direction,steps);\n\n        return miningMachine.toString();\n    }\n}\n"}, {"source": "student", "name": "student143", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "student", "name": "student144", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\nimport java.util.Arrays;\npublic class Exercise0 implements GoAble {\n    Integer startUpDown = 2;\n    Integer startLeftRight = 0;\n\n    public Integer change(Integer anderungswert,Integer upDownOrLeftRight){\n        if(anderungswert == 0){\n            anderungswert = upDownOrLeftRight;\n        }\n        return anderungswert;\n    }\n    public Integer wallCheck(Integer startUpDown,Integer startLeftRight,Integer newLeftRight,Integer newUpDown){\n        Integer anderungswert;\n        anderungswert = 0;\n        //Section1 Begin\n        if(startLeftRight<=2 && startUpDown<=2){\n            if(newLeftRight>2){\n                anderungswert = 2;\n            }\n        }\n        //Section1 End\n        //Section2 Begin\n        if(startLeftRight<=4 && startLeftRight >=3 && startUpDown<=2){\n            if(newLeftRight<3){\n                anderungswert=3;\n            }\n            if(newLeftRight>4){\n                anderungswert=4;\n            }\n        }\n        //Section2 End\n        //Section3 Begin\n        if(startLeftRight>=5&&startUpDown<=3){\n            if(newLeftRight<5){\n                anderungswert=5;\n            }\n        }\n        //Section3 End\n        //Section4 Begin\n        if(startLeftRight>=7&&startUpDown>=5){\n            if(newLeftRight<7){\n                anderungswert=7;\n            }\n        }\n        //Section4 End\n        //Section5 Begin\n        if(startLeftRight<=4&&startUpDown==3){\n            if(newLeftRight>4){\n                anderungswert=4;\n            }\n        }\n        //Section5 End\n        //Section6 Begin\n        if(startLeftRight<=6&&startUpDown>=5){\n            if(newLeftRight>6){\n                anderungswert=6;\n            }\n            if(startLeftRight>=4){\n                if(newUpDown<5&&newLeftRight==0){\n                    anderungswert=5;\n                }\n            }\n        }\n        //Section6 End\n        //Section7 Begin\n        if(startLeftRight>=4&&startLeftRight<=6&&startUpDown<=4){\n            if(newUpDown>4){\n                anderungswert=4;\n            }\n        }\n        return anderungswert ;\n    }\n\n    public Integer findAmount(String goCommandString){\n        if(goCommandString.substring(5,6).equals(\"]\")){\n            return Integer.parseInt(goCommandString.substring(4,5));\n        }\n        if(goCommandString.substring(7,7).equals(\"]\")){\n            return Integer.parseInt(goCommandString.substring(4,7));\n        }\n        else{\n            return Integer.parseInt(goCommandString.substring(4,6));\n        }\n    }\n\n    @Override\n    public String go(String goCommandString) {\n        Integer newUpDown,newLeftRight,amount,upDown,leftRight,maxUpDown, minUpDown,maxLeftRight,minLeftRight;\n        String direction,finish;\n\n        direction = goCommandString.substring(1,3);\n        amount = findAmount(goCommandString);\n        upDown = startUpDown;\n        leftRight = startLeftRight;\n        maxLeftRight = 11;\n        maxUpDown = 8;\n        minLeftRight = 0;\n        minUpDown = 0;\n        newLeftRight = 0;\n        newUpDown = 0;\n\n        if(direction.equals(\"no\")||direction.equals(\"ea\")){\n            if(direction.equals(\"no\")){\n                newUpDown = amount + upDown;\n                newUpDown = change(wallCheck(startUpDown,startLeftRight,newLeftRight,newUpDown),newUpDown);\n                if(newUpDown>maxUpDown){\n                    newUpDown = maxUpDown;\n                }\n                if(newUpDown<minUpDown){\n                    newUpDown = minUpDown;\n                }\n                startUpDown = newUpDown;\n            }\n            else{\n                newLeftRight = amount+leftRight;\n                newLeftRight = change(wallCheck(startUpDown,startLeftRight,newLeftRight,newUpDown),newLeftRight);\n                if(newLeftRight>maxLeftRight){\n                    newLeftRight = maxLeftRight;\n                }\n                if(newLeftRight<minLeftRight){\n                    newLeftRight = minLeftRight;\n                }\n                startLeftRight = newLeftRight;\n            }\n        }\n        if(direction.equals(\"so\")||direction.equals(\"we\")){\n            if(direction.equals(\"so\")){\n                newUpDown = upDown - amount;\n                if(newUpDown<0){\n                    newUpDown = 0;\n                }\n                newUpDown = change(wallCheck(startUpDown,startLeftRight,newLeftRight,newUpDown),newUpDown);\n                if(newUpDown<minUpDown){\n                    newUpDown = minUpDown;\n                }\n                startUpDown = newUpDown;\n            }\n            else{\n                newLeftRight = leftRight - amount;\n                if(newLeftRight<0){\n                    newLeftRight = 0;\n                }\n                newLeftRight = change(wallCheck(startUpDown,startLeftRight,newLeftRight,newUpDown),newLeftRight);\n                if(newLeftRight<minLeftRight){\n                    newLeftRight = minLeftRight;\n                }\n                startLeftRight = newLeftRight;\n            }\n        }\n        finish = \"(\"+startLeftRight+\",\"+startUpDown+\")\";\n        return finish;\n    }\n}\n"}, {"source": "student", "name": "student144", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String go(String goCommandString);\n}\n"}, {"source": "student", "name": "student145", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n\n    int x, y;\n    int rechts = 1;\n    int hoch = 6;\n    int[][] board;\n\n\n    @Override\n    public String goTo(String goCommandString) {\n\n\n        board = new int[rechts][hoch];\n\n\n        String c = String.valueOf(goCommandString.charAt(4));\n        int a = Integer.valueOf(c);\n        String b = String.valueOf(goCommandString.charAt(1));\n\n        if (b.equals(\"n\")) {\n            if (this.rechts == 0) {\n                if (this.hoch == 5){if(a > 0){this.hoch=5;}}\n                else if (this.hoch == 4){if(a >= 1){this.hoch=5;}}\n                else if (this.hoch == 3){if(a >= 2) { this.hoch = 5;}}\n                else if (this.hoch == 2){if(a >= 3){this.hoch = 5;}}\n                else if (this.hoch == 1){if(a >= 4){this.hoch = 5;}}\n                else if (this.hoch == 0){if(a >= 5){this.hoch = 5;}}\n                else {\n                    this.hoch = hoch + a;\n                }}\n\n            else if (this.rechts == 1){\n                if(this.hoch == 5){if (a >= 0){this.hoch = 5;}}\n                else {\n                    this.hoch = hoch + a;\n                }}\n            else if (this.rechts == 1){\n                if(this.hoch == 4){if(a >= 0){this.hoch = 4;}}\n                else if (this.hoch == 3){if (a >= 1){this.hoch = 4;}}\n                else if (this.hoch == 2){if (a >= 2){this.hoch = 4;}}\n                else if (this.hoch == 1){if (a >= 3){this.hoch = 4;}}\n                else if (this.hoch == 0){if (a >= 4){this.hoch = 4;}}\n                else {\n                    this.hoch = hoch + a;\n                }}\n            else if (this.rechts == 2){\n                if(this.hoch == 4){if(a > 0){this.hoch = 4;}}\n                else if (this.hoch == 3){if (a >= 1){this.hoch = 4;}}\n                else if (this.hoch == 2){if (a >= 2){this.hoch = 4;}}\n                else if (this.hoch == 1){if (a >= 3){this.hoch = 4;}}\n                else if (this.hoch == 0){if (a >= 4){this.hoch = 4;}}\n                else {\n                    this.hoch = hoch + a;\n                }}\n            else if (this.rechts == 3){\n                if(this.hoch == 4){if(a > 0){this.hoch = 4;}}\n                else if (this.hoch == 3){if (a >= 1){this.hoch = 4;}}\n                else if (this.hoch == 2){if (a >= 2){this.hoch = 4;}}\n                else if (this.hoch == 1){if (a >= 3){this.hoch = 4;}}\n                else if (this.hoch == 0){if (a >= 4){this.hoch = 4;}}\n                else {\n                    this.hoch = hoch + a;\n                }}\n            else if (this.rechts == 4){\n                if(this.hoch == 4){if(a > 0){this.hoch = 5;}}\n                else if (this.hoch == 3){if (a >= 1){this.hoch = 4;}}\n                else if (this.hoch == 2){if (a >= 2){this.hoch = 4;}}\n                else if (this.hoch == 1){if (a >= 3){this.hoch = 4;}}\n                else if (this.hoch == 0){if (a >= 4){this.hoch = 4;}}\n                else {\n                    this.hoch = hoch + a;\n                }}\n            else if (this.rechts == 5){\n                if(this.hoch == 4){if(a > 0){this.hoch = 5;}}\n                else if (this.hoch == 3){if (a >= 1){this.hoch = 4;}}\n                else if (this.hoch == 2){if (a >= 2){this.hoch = 4;}}\n                else if (this.hoch == 1){if (a >= 3){this.hoch = 4;}}\n                else if (this.hoch == 0){if (a >= 4){this.hoch = 4;}}\n                else {\n                    this.hoch = hoch + a;\n                }}\n            else if (this.rechts == 6){\n                if(this.hoch == 4){if(a > 0){this.hoch = 5;}}\n                else if (this.hoch == 3){if (a >= 1){this.hoch = 4;}}\n                else if (this.hoch == 2){if (a >= 2){this.hoch = 4;}}\n                else if (this.hoch == 1){if (a >= 3){this.hoch = 4;}}\n                else if (this.hoch == 0){if (a >= 4){this.hoch = 4;}}\n                else {\n                    this.hoch = hoch + a;\n                }}\n            else if (this.rechts == 7){\n                if(this.hoch == 4){if(a >= 0){this.hoch = 4;}}\n                else if (this.hoch == 3){if (a >= 1){this.hoch = 4;}}\n                else if (this.hoch == 2){if (a >= 2){this.hoch = 4;}}\n                else if (this.hoch == 1){if (a >= 3){this.hoch = 4;}}\n                else if (this.hoch == 0){if (a >= 4){this.hoch = 4;}}\n                else {\n                    this.hoch = hoch + a;\n                }}\n            else if (this.rechts == 8){\n                if(this.hoch == 4){if(a >= 0){this.hoch = 4;}}\n                else if (this.hoch == 3){if (a >= 1){this.hoch = 4;}}\n                else if (this.hoch == 2){if (a >= 2){this.hoch = 4;}}\n                else if (this.hoch == 1){if (a >= 3){this.hoch = 4;}}\n                else if (this.hoch == 0){if (a >= 4){this.hoch = 4;}}\n                else {\n                    this.hoch = hoch + a;\n                }}\n\n            else {\n                this.hoch = hoch + a;\n            }\n            if (this.hoch >= 7) {\n                this.hoch = 7; }}\n\n        if (b.equals(\"s\")) {\n            if (this.rechts == 0) {\n                if (this.hoch == 7) { if (a >= 1) { this.hoch = 6; } }\n                else if (this.hoch == 6) { if (a >= 0) { this.hoch = 6; } }\n                else {\n                    this.hoch = hoch - a;\n                }}\n            else if (this.rechts == 1) {\n                if (this.hoch == 7) { if (a >= 1) { this.hoch = 6; } }\n                else if (this.hoch == 6) { this.hoch = 6; }\n                else if (this.hoch == 5) { this.hoch = 5; }\n                else {\n                    this.hoch = hoch - a;\n                }}\n            else if (this.rechts == 2) {\n                if (this.hoch == 7) { if (a >= 2) { this.hoch = 5; } }\n                else if (this.hoch == 6){if (a >= 1) { this.hoch = 5; } }\n                else if (this.hoch == 5){if (a >= 0){this.hoch = 5;}}\n                else {\n                    this.hoch = hoch - a;\n                }}\n            else if (this.rechts == 3) {\n                if (this.hoch == 7) { if (a >= 2) { this.hoch = 5; } }\n                else if (this.hoch == 6) { if (a >= 1) { this.hoch = 5; } }\n                else if (this.hoch == 5) { if (a >= 0) { this.hoch = 5; } }\n                else {\n                    this.hoch = hoch - a;\n                }}\n            else if (this.rechts == 4) {\n                if (this.hoch == 7) { if (a >= 2) { this.hoch = 5; } }\n                else if (this.hoch == 6) { if (a >= 1) { this.hoch = 5; } }\n                else if (this.hoch == 5) { if (a >= 0) { this.hoch = 5; } }\n                else {\n                    this.hoch = hoch - a;\n                }}\n            else if (this.rechts == 5) {\n                if (this.hoch == 7) { if (a >= 2) { this.hoch = 5; } }\n                else if (this.hoch == 6) { if (a >= 1) { this.hoch = 5; } }\n                else if (this.hoch == 5) { if (a >= 0) { this.hoch = 5; } }\n                else {\n                    this.hoch = hoch - a;\n                }}\n            else if (this.rechts == 6) {\n                if (this.hoch == 7) { if (a >= 2) { this.hoch = 5; } }\n                else if (this.hoch == 6) { if (a >= 1) { this.hoch = 5; } }\n                else if (this.hoch == 5) { if (a >= 0) { this.hoch = 5; } }\n                else {\n                    this.hoch = hoch - a;\n                }}\n            else if (this.rechts == 7) {\n                if (this.hoch == 7) { if (a >= 2) { this.hoch = 5; } }\n                else if (this.hoch == 6) { if (a >= 1) { this.hoch = 5; } }\n                else if (this.hoch == 5) { if (a >= 0) { this.hoch = 5; } }\n                else {\n                    this.hoch = hoch - a;\n                }}\n            else if (this.rechts == 8) {\n                if (this.hoch == 7) { if (a >= 2) { this.hoch = 5; } }\n                else if (this.hoch == 6) { if (a >= 1) { this.hoch = 5; } }\n                else if (this.hoch == 5) { if (a >= 0) { this.hoch = 5; } }\n                else {\n                    this.hoch = hoch - a;\n                }}\n            else {\n                this.hoch = hoch - a;\n            }\n            if (this.hoch <= 0) {\n                this.hoch = 0;\n            }\n        }\n\n        if (b.equals(\"e\")) {\n            if(this.rechts==0) {\n                if(this.hoch== 1){if(a >= 8){this.rechts = 8;}}\n                if(this.hoch== 2){if(a >= 8){this.rechts = 8;}}\n                if(this.hoch== 3){if(a >= 8){this.rechts = 8;}}\n                if(this.hoch== 4){if(a >= 8){this.rechts = 8;}}\n                if(this.hoch== 6){if(a >= 2){this.rechts = 2;}}\n                if(this.hoch== 7){if(a >= 2){this.rechts = 2;}}}\n\n            else if(this.rechts==1) {\n                if(this.hoch== 1){if(a >= 7){this.rechts = 8;}}\n                else if(this.hoch== 2){if(a >= 7){this.rechts = 8;}}\n                else if(this.hoch== 3){if(a >= 7){this.rechts = 8;}}\n                else if(this.hoch== 4){if(a >= 7){this.rechts = 8;}}\n                else if(this.hoch== 6){if(a >= 1){this.rechts = 2;}}\n                else if(this.hoch== 7){if(a >= 1){this.rechts = 2;}}\n                else {\n                    this.rechts = rechts + a;}}\n\n            else if(this.rechts==2) {\n                if(this.hoch== 1){if(a >= 6){this.rechts = 8;}}\n                else if(this.hoch== 2){if(a >= 6){this.rechts = 8;}}\n                else if(this.hoch== 3){if(a >= 6){this.rechts = 8;}}\n                else if(this.hoch== 4){if(a >= 6){this.rechts = 8;}}\n                else {\n                    this.rechts = rechts + a;}}\n\n            else if(this.rechts==3) {\n                if(this.hoch== 1){if(a >= 5){this.rechts = 8;}}\n                else if(this.hoch== 2){if(a >= 5){this.rechts = 8;}}\n                else if(this.hoch== 3){if(a >= 5){this.rechts = 8;}}\n                else if(this.hoch== 4){if(a >= 5){this.rechts = 8;}}\n                else {\n                    this.rechts = rechts + a;}}\n\n            else if(this.rechts==4) {\n                if(this.hoch== 1){if(a >= 4){this.rechts = 8;}}\n                else if(this.hoch== 2){if(a >= 4){this.rechts = 8;}}\n                else if(this.hoch== 3){if(a >= 4){this.rechts = 8;}}\n                else if(this.hoch== 4){if(a >= 4){this.rechts = 8;}}\n                else {\n                    this.rechts = rechts + a;}}\n\n            else if(this.rechts==5) {\n                if(this.hoch== 1){if(a >= 3){this.rechts = 8;}}\n                else if(this.hoch== 2){if(a >= 3){this.rechts = 8;}}\n                else if(this.hoch== 3){if(a >= 3){this.rechts = 8;}}\n                else if(this.hoch== 4){if(a >= 3){this.rechts = 8;}}\n                else {\n                    this.rechts = rechts + a;}}\n\n            else if(this.rechts==6) {\n                if(this.hoch== 1){if(a >= 2){this.rechts = 8;}}\n                else if(this.hoch== 2){if(a >= 2){this.rechts = 8;}}\n                else if(this.hoch== 3){if(a >= 2){this.rechts = 8;}}\n                else if(this.hoch== 4){if(a >= 2){this.rechts = 8;}}\n                else {\n                    this.rechts = rechts + a;}}\n\n            else if(this.rechts==7) {\n                if(this.hoch== 1){if(a >= 1){this.rechts = 8;}}\n                else if(this.hoch== 2){if(a >= 1){this.rechts = 8;}}\n                else if(this.hoch== 3){if(a >= 1){this.rechts = 8;}}\n                else if(this.hoch== 4){if(a >= 1){this.rechts = 8;}}\n                else {\n                    this.rechts = rechts + a;}}\n\n            else if(this.rechts==8) {\n                if(this.hoch== 1){if(a >= 0){this.rechts = 8;}}\n                else if(this.hoch== 2){if(a >= 0){this.rechts = 8;}}\n                else if(this.hoch== 3){if(a >= 0){this.rechts = 8;}}\n                else if(this.hoch== 4){if(a >= 0){this.rechts = 8;}}\n                else {\n                    this.rechts = rechts + a;}}\n\n            else {\n                this.rechts = rechts + a;}\n\n            if (this.rechts >= 10) {\n                this.rechts = 10; }}\n\n        if (b.equals(\"w\")) {\n            if(this.rechts==10) {\n                if(this.hoch== 1){if(a >= 1){this.rechts = 9;}}\n                else if(this.hoch== 2){if(a >= 1){this.rechts = 9;}}\n                else if(this.hoch== 3){if(a >= 1){this.rechts = 9;}}\n                else if(this.hoch== 4){if(a >= 1){this.rechts = 9;}}\n                else if(this.hoch== 6){if(a >= 7){this.rechts = 3;}}\n                else if(this.hoch== 7){if(a >= 7){this.rechts = 3;}}\n                else{\n                    this.rechts = rechts - a;}}\n            else if(this.rechts==9) {\n                if(this.hoch== 1){if(a >= 0){this.rechts = 9;}}\n                else if(this.hoch== 2){if(a >= 0){this.rechts = 9;}}\n                else if(this.hoch== 3){if(a >= 0){this.rechts = 9;}}\n                else if(this.hoch== 4){if(a >= 0){this.rechts = 9;}}\n                else if(this.hoch== 6){if(a >= 6){this.rechts = 3;}}\n                else if(this.hoch== 7){if(a >= 6){this.rechts = 3;}}\n                else{\n                    this.rechts = rechts - a;}}\n            else if(this.rechts==8) {\n                if(this.hoch== 6){if(a >= 5){this.rechts = 3;}}\n                else if(this.hoch== 7){if(a >= 5){this.rechts = 3;}}\n                else{\n                    this.rechts = rechts - a;}}\n            else if(this.rechts==7) {\n                if(this.hoch== 6){if(a >= 4){this.rechts = 3;}}\n                else if(this.hoch== 7){if(a >= 4){this.rechts = 3;}}\n                else{\n                    this.rechts = rechts - a;}}\n            else if(this.rechts==6) {\n                if(this.hoch== 6){if(a > 3){this.rechts = 3;}}\n                else if(this.hoch== 7){if(a >= 3){this.rechts = 3;}}\n                else{\n                    this.rechts = rechts - a;}}\n            else if(this.rechts==5) {\n                if(this.hoch== 6){if(a > 2){this.rechts = 3;}}\n                else if(this.hoch== 7){if(a >= 2){this.rechts = 3;}}\n                else{\n                    this.rechts = rechts - a;}}\n            else if(this.rechts==4) {\n                if(this.hoch== 6){if(a > 1){this.rechts = 3;}}\n                else if(this.hoch== 7){if(a >= 1){this.rechts = 3;}}\n                else{\n                    this.rechts = rechts - a;}}\n            else if(this.rechts==3) {\n                if(this.hoch== 6){if(a >= 0){this.rechts = 3;}}\n                else if(this.hoch== 7){if(a >= 0){this.rechts = 3;}}\n                else{\n                    this.rechts = rechts - a;}}\n\n            else{\n                this.rechts = rechts - a;}\n        }\n        if (this.rechts <= 0) {\n            this.rechts = 0;\n        }\n\n\n\n\n        return \"(\" + rechts + \",\" + hoch + \")\";\n    }\n}\n\n\n\n"}, {"source": "student", "name": "student145", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n\n\n}\n"}, {"source": "student", "name": "student146", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Exercise0 implements Moveable {\n    private final Map<WallType, List<String>> walls = new HashMap<>();\n\n    private final int MAX_HEIGHT = 7;\n    private final int MAX_WIDTH = 11;\n    private int x = 5;\n    private int y = 3;\n\n    @Override\n    public String moveTo(String moveCommandString) {\n        List<String> tmp = new ArrayList<>(Arrays.asList(\"(4,1)\", \"(4,2)\", \"(6,2)\", \"(6,3)\", \"(6,4)\", \"(6,5)\", \"(6,6)\", \"(6,7)\"));\n        walls.put(WallType.HORIZONTAL, tmp);\n        tmp = new ArrayList<>(Arrays.asList(\"(3,3)\", \"(4,3)\", \"(5,3)\", \"(6,3)\", \"(7,3)\", \"(8,3)\", \"(1,6)\", \"(2,6)\", \"(3,6)\", \"(4,6)\", \"(5,6)\"));\n        walls.put(WallType.VERTICAL, tmp);\n        String direction = getSplit(moveCommandString, 0).replace(\"[\", \"\");\n        int value = Integer.parseInt(getSplit(moveCommandString, 1).replace(\"]\", \"\"));\n        switch (direction) {\n            case \"no\":\n                doY(value, true);\n                break;\n            case \"ea\":\n                doX(value, true);\n                break;\n            case \"so\":\n                doY(value, false);\n                break;\n            case \"we\":\n                doX(value, false);\n                break;\n        }\n        System.out.println(moveCommandString);\n        System.out.println(\"(\" + x + \",\" + y + \")\");\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    private void doX(int value, boolean plus) {\n        List<String> list;\n        if (plus) {\n            list = walls.get(WallType.HORIZONTAL).stream().filter(s -> {\n                int a = getY(s);\n                return a == y && x < getX(s) && (x + value) >= getX(s);\n            }).collect(Collectors.toList());\n            if (list.isEmpty())\n                x += value;\n            else\n                x = list.stream().mapToInt(this::getX).min().getAsInt() - 1;\n            if (x > MAX_WIDTH)\n                x = MAX_WIDTH;\n        } else {\n            list = walls.get(WallType.HORIZONTAL).stream().filter(s -> {\n                int a = getY(s);\n                return a == y && x >= getX(s) && (x - value) < getX(s);\n            }).collect(Collectors.toList());\n            if (list.isEmpty())\n                x -= value;\n            else\n                x = list.stream().mapToInt(this::getX).max().getAsInt();\n            if (x < 0)\n                x = 0;\n        }\n    }\n\n    private void doY(int value, boolean plus) {\n        List<String> list;\n        if (plus) {\n            list = walls.get(WallType.VERTICAL).stream().filter(s -> {\n                int a = getX(s);\n                return a == x && y < getY(s) && (y + value) >= getY(s);\n            }).collect(Collectors.toList());\n            if (list.isEmpty())\n                y += value;\n            else\n                y = list.stream().mapToInt(this::getY).min().getAsInt() - 1;\n            if (y > MAX_HEIGHT)\n                y = MAX_HEIGHT;\n        } else {\n            list = walls.get(WallType.VERTICAL).stream().filter(s -> {\n                int a = getX(s);\n                return a == x && y >= getY(s) && (y - value) < getY(s);\n            }).collect(Collectors.toList());\n            if (list.isEmpty())\n                y -= value;\n            else\n                y = list.stream().mapToInt(this::getY).max().getAsInt();\n            if (y < 0)\n                y = 0;\n        }\n    }\n\n    private int getX(String s) {\n        return Integer.parseInt(getSplit(s, 0).replace(\"(\", \"\"));\n    }\n\n    private int getY(String s) {\n        return Integer.parseInt(getSplit(s, 1).replace(\")\", \"\"));\n    }\n\n    private String getSplit(String s, int index) {\n        return s.split(\",\")[index].trim();\n    }\n\n    private enum WallType {\n        HORIZONTAL,\n        VERTICAL\n    }\n}\n"}, {"source": "student", "name": "student146", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String moveTo(String moveCommandString);\n}\n"}, {"source": "student", "name": "student147", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n    public  String device=\"3,0\";\n    int device_x = Integer.parseInt(device.substring(0,1));\n    int device_y = Integer.parseInt(device.substring(2));\n    String[] wall1 ={\"1,4\",\"2,4\",\"3,4\",\"4,4\",\"5,4\",\"6,4\",\"7,4\",\"8,4\"};\n    String[] wall2 ={\"3,0\",\"3,1\",\"3,2\",\"3,3\"};\n    String[] wall3 ={\"4,3\",\"5,3\",\"6,3\",\"7,3\"};\n    String[] wall4 ={\"7,0\",\"7,1\",\"7,2\"};\n\n    @Override\n    public String moveTo(String moveCommandString) {\n        int c=0;\n        String check = moveCommandString.substring(1,3);\n        int x = Integer.parseInt(moveCommandString.substring(4,moveCommandString.length()-1));\n        for (int y =0; y < x; y++){\n\n            switch (check){\n                case \"no\":\n                    if(device_y+1 < 8) {\n\n                        if(test(check) == true) {\n                            device = device_x + \",\" + (device_y + 1);\n                            device_y++;\n                        }\n                    }\n\n                    break;\n\n                case \"so\":\n                    if(device_y-1 >= 0) {\n\n                        if(test(check) == true) {\n                            device = device_x + \",\" + (device_y - 1);\n                            device_y--;\n                        }\n                    }\n\n                    break;\n\n                case \"ea\":\n                    if(device_x+1 < 12) {\n\n                        if (test(check) == true) {\n                            device = (device_x + 1) + \",\" + device_y;\n                            device_x++;\n                        }\n                    }\n\n                    break;\n\n                case \"we\":\n                    if(device_x-1 >= 0) {\n\n                        if(test(check) == true) {\n                            device = (device_x - 1) + \",\" + device_y;\n                            device_x--;\n                        }\n                    }\n\n                    break;\n            }\n        }\n        return (\"(\" + device + \")\");\n    }\n    public boolean No(String [] wall){\n        int c = 0;\n        for (int i =0; i < wall.length; i++){\n            if (wall[i].equals(device_x + \",\" + (device_y+1))){\n                c++;\n            }\n            if (wall[i].equals((device_x+1) + \",\" + (device_y+1))){\n                c++;\n            }\n        }\n        if(c == 2){\n            return false;\n        }\n        return true;\n    }\n    public boolean So(String [] wall){\n        int c = 0;\n        for (int i =0; i < wall.length; i++){\n            if (wall[i].equals(device)){\n                c++;\n            }\n            if (wall[i].equals((device_x+1) + \",\" + device_y)){\n                c++;\n            }\n        }\n        if(c == 2){\n            return false;\n        }\n        return true;\n    }\n    public boolean Ea(String [] wall){\n        int c = 0;\n        String a = (device_x+1) + \",\" + (device_y+1);\n        String b = (device_x+1) + \",\" + device_y;\n        for (int i =0; i < wall.length; i++){\n            if (wall[i].equals(a)){\n                c++;\n            }\n            if (wall[i].equals(b)){\n                c++;\n            }\n        }\n        if(c == 2){\n            return false;\n        }\n        return true;\n    }\n    public boolean We(String [] wall){\n        int c = 0;\n        for (int i =0; i < wall.length; i++){\n            if (wall[i].equals(device_x + \",\" + (device_y+1))){\n                c++;\n            }\n            if (wall[i].equals(device)){\n                c++;\n            }\n        }\n        if(c == 2){\n            return false;\n        }\n        return true;\n    }\n    public boolean NoSoEaWe(String [] wall,String direction) {\n        switch (direction) {\n            case \"no\":\n                if (No(wall) == false) return false;\n                break;\n            case \"so\":\n                if (So(wall) == false) return false;\n                break;\n            case \"ea\":\n                if (Ea(wall) == false) return false;\n                break;\n            case \"we\":\n                if (We(wall) == false) return false;\n                break;\n        }\n        return true;\n    }\n    public boolean test(String direction){\n\n        if(NoSoEaWe(wall1,direction) == false)\n            return false;\n        if(NoSoEaWe(wall2,direction) == false)\n            return false;\n        if(NoSoEaWe(wall3,direction) == false)\n            return false;\n        if(NoSoEaWe(wall4,direction) == false)\n            return false;\n        return true;\n    }\n}\n"}, {"source": "student", "name": "student147", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String moveTo(String moveCommandString);\n}\n"}, {"source": "student", "name": "student148", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n    int x = 1;\n    int y = 6;\n\n    @Override\n    public String goTo(String goCommandString) {\n        String commandString = goCommandString.replace(\"[\", \"\");\n        commandString = commandString.replace(\"]\", \"\");\n        String moveArray[] = commandString.split(\",\");\n        String moveDirection = moveArray[0];\n        int steps = Integer.parseInt(moveArray[1]);\n        movement(moveDirection, steps);\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    public void movement(String moveDirection, int steps) {\n        switch (moveDirection) {\n            case \"no\":\n                y = checkNorth(y, steps);\n                break;\n            case \"ea\":\n                x = checkEast(x, steps);\n                break;\n            case \"so\":\n                y = checkSouth(y, steps);\n                break;\n            case \"we\":\n                x = checkWest(x, steps);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Move not allowed!\");\n        }\n    }\n\n    public int checkNorth(int yMove, int steps) {\n        int[] illegalXs1 = new int[]{0, 1};\n        int[] illegalYs1 = new int[]{6};\n        int[] illegalXs2 = new int[]{1, 2, 3, 4, 5, 6, 7, 8};\n        int[] illegalYs2 = new int[]{5};\n        for (int i = 0; i < steps; i++) {\n            if (yMove == 7) break;\n            else if ((contains(illegalYs1, yMove + 1) && contains(illegalXs1, x)) || (contains(illegalYs2, yMove + 1) && contains(illegalXs2, x)))\n                break;\n            else yMove += 1;\n        }\n        return yMove;\n    }\n\n    public int checkEast(int xMove, int steps) {\n        int[] illegalXs1 = new int[]{9};\n        int[] illegalYs1 = new int[]{1, 2, 3, 4};\n        int[] illegalXs2 = new int[]{3};\n        int[] illegalYs2 = new int[]{6, 7};\n\n        for (int i = 0; i < steps; i++) {\n            if (xMove == 10) break;\n            else if ((contains(illegalYs1, y) && contains(illegalXs1, xMove + 1)) || (contains(illegalYs2, y) && contains(illegalXs2, xMove + 1)))\n                break;\n            else xMove += 1;\n        }\n        return xMove;\n    }\n\n    public int checkSouth(int yMove, int steps) {\n        int[] illegalXs1 = new int[]{0, 1};\n        int[] illegalYs1 = new int[]{5};\n        int[] illegalXs2 = new int[]{1, 2, 3, 4, 5, 6, 7, 8};\n        int[] illegalYs2 = new int[]{4};\n        for (int i = 0; i < steps; i++) {\n            if (yMove == 0) break;\n            else if ((contains(illegalYs1, yMove - 1) && contains(illegalXs1, x)) || (contains(illegalYs2, yMove - 1) && contains(illegalXs2, x)))\n                break;\n            else yMove -= 1;\n        }\n        return yMove;\n    }\n\n    public int checkWest(int xMove, int steps) {\n        int[] illegalXs1 = new int[]{8};\n        int[] illegalYs1 = new int[]{1, 2, 3, 4};\n        int[] illegalXs2 = new int[]{2};\n        int[] illegalYs2 = new int[]{6, 7};\n        for (int i = 0; i < steps; i++) {\n            if (xMove == 0) break;\n            else if ((contains(illegalYs1, y) && contains(illegalXs1, xMove - 1)) || (contains(illegalYs2, y) && contains(illegalXs2, xMove - 1)))\n                break;\n            else xMove -= 1;\n        }\n        return xMove;\n    }\n\n    public boolean contains(int[] list, int move) {\n        boolean isInList = false;\n        for (int j : list) {\n            if (j == move) {\n                isInList = true;\n                break;\n            }\n        }\n        return isInList;\n    }\n}\n"}, {"source": "student", "name": "student148", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "student", "name": "student149", "file_name": "Barrier.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Barrier {\n\n    private static final String PATTERN = \"(\\\\((?:\\\\d|\\\\,)+\\\\))\\\\-(\\\\((?:\\\\d|\\\\,)+\\\\))\";\n\n    private Position start;\n    private Position end;\n\n    private List<Transition> blockedTransitions = new ArrayList<>();\n\n    public Barrier(Position start, Position end) {\n        this.start = start;\n        this.end = end;\n\n        initBlockedTransitions();\n    }\n\n    public Barrier(String barrier) {\n        parseBarrier(barrier);\n        initBlockedTransitions();\n    }\n\n    public List<Transition> getBlockedTransitions() {\n        return blockedTransitions;\n    }\n\n    public Position getStart() {\n        return start;\n    }\n\n    public Position getEnd() {\n        return end;\n    }\n\n    @Override\n    public String toString() {\n        return start + \"-\" + end;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Barrier barrier = (Barrier) o;\n        return Objects.equals(start, barrier.start) && Objects.equals(end, barrier.end);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(start, end);\n    }\n\n    private void initBlockedTransitions() {\n        int deltaX = end.getX() - start.getX();\n        int deltaY = end.getY() - start.getY();\n\n        int x = end.getX() - deltaX;\n        int y = end.getY() - deltaY;\n\n        if (deltaX != 0) {\n            int minX = Integer.min(x, end.getX());\n            int maxX = Integer.max(x, end.getX());\n\n            for (int i = minX; i <= maxX; i++) {\n                blockedTransitions.add(new Transition(new Position(i, y), new Position(i, y - 1)));\n            }\n        }\n        if (deltaY != 0) {\n            int minY = Integer.min(y, end.getY());\n            int maxY = Integer.max(y, end.getY());\n\n            for (int i = minY; i <= maxY; i++) {\n                blockedTransitions.add(new Transition(new Position(x, i), new Position(x - 1, i)));\n            }\n        }\n    }\n\n    private void parseBarrier(String barrier) {\n        Pattern pattern = Pattern.compile(PATTERN);\n        Matcher matcher = pattern.matcher(barrier);\n\n        if (matcher.find()) {\n            start = new Position(matcher.group(1));\n            end = new Position(matcher.group(2));\n        }\n    }\n}\n"}, {"source": "student", "name": "student149", "file_name": "Direction.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic enum Direction {\n\n    NORTH(\"no\", 0, 1),\n    EAST(\"ea\", 1, 0),\n    SOUTH(\"so\", 0, -1),\n    WEST(\"we\", -1, 0);\n\n    private String code;\n    private int xFactor = 0;\n    private int yFactor = 0;\n\n    Direction(String code, int xFactor, int yFactor) {\n        this.code = code;\n        this.xFactor = xFactor;\n        this.yFactor = yFactor;\n    }\n\n    public static Direction getValue(String code) {\n        switch (code) {\n            case \"no\": return NORTH;\n            case \"ea\": return EAST;\n            case \"so\": return SOUTH;\n            case \"we\": return WEST;\n            default: return null;\n        }\n    }\n\n    public String getCode() {\n        return code;\n    }\n\n    public int getXFactor() {\n        return xFactor;\n    }\n\n    public int getYFactor() {\n        return yFactor;\n    }\n}\n"}, {"source": "student", "name": "student149", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class Exercise0 implements Moveable {\n\n    private Position currentPosition = new Position(\"(0,2)\");\n    private Map map = new Map(12, 9,\n            Arrays.asList(\"(3,0)-(3,2)\", \"(5,0)-(5,3)\", \"(4,5)-(6,5)\", \"(7,5)-(7,8)\").stream().map(barrier -> new Barrier(barrier)).collect(Collectors.toList()));\n\n    @Override\n    public String moveTo(String moveCommandString) {\n        move(new Movement(moveCommandString));\n\n        return currentPosition.toString();\n    }\n\n    private void move(Movement movement) {\n        if (movement.getMoves() > 0) {\n            Position previewedStep = movement.previewStep(currentPosition);\n            if (map.isMoveValid(currentPosition, previewedStep)) {\n                currentPosition = movement.makeStep(currentPosition);\n                move(movement);\n            }\n        }\n    }\n}\n"}, {"source": "student", "name": "student149", "file_name": "Map.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Map {\n\n    private int width;\n    private int height;\n\n    private List<Transition> blockedTransitions = new ArrayList<>();\n\n    public Map(int width, int height, List<Barrier> barriers) {\n        this.width = width;\n        this.height = height;\n\n        initBlockedTransition(barriers);\n    }\n\n    public boolean isMoveValid(Position current, Position next) {\n        return isPositionOnMap(next) && !blockedTransitions.contains(new Transition(current, next));\n    }\n\n    public int getWidth() {\n        return width;\n    }\n\n    public int getHeight() {\n        return height;\n    }\n\n    public List<Transition> getBlockedTransitions() {\n        return blockedTransitions;\n    }\n\n    private boolean isPositionOnMap(Position position) {\n        return position.getX() >= 0 && position.getY() >= 0\n                && position.getX() < width && position.getY() < height;\n    }\n\n    private void initBlockedTransition(List<Barrier> barriers) {\n        barriers.forEach(barrier -> blockedTransitions.addAll(barrier.getBlockedTransitions()));\n    }\n}\n"}, {"source": "student", "name": "student149", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String moveTo(String moveCommandString);\n}\n"}, {"source": "student", "name": "student149", "file_name": "Movement.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.Objects;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Movement {\n\n    private static final String PATTERN = \"\\\\[(\\\\w{2})\\\\,(\\\\d+)\\\\]\";\n\n    private Direction direction;\n    private int moves = 0;\n\n    public Movement(String movement) {\n        parseMovement(movement);\n    }\n\n    public Movement(Direction direction, int moves) {\n        this.direction = direction;\n        this.moves = moves;\n    }\n\n    public Position makeStep(Position position) {\n        return makeStep(position, 1);\n    }\n\n    public Position makeStep(Position position, int desiredMoves) {\n        Position previewSteps = previewSteps(position, desiredMoves);\n        this.moves -= desiredMoves > this.moves ? this.moves : desiredMoves;\n        return previewSteps;\n    }\n\n    public Position previewStep(Position position) {\n        return previewSteps(position, 1);\n    }\n\n    public Position previewSteps(Position position, int desiredMoves) {\n        int actualMoves = desiredMoves;\n        if (desiredMoves > this.moves) {\n            actualMoves = this.moves;\n        }\n        return new Position(position.getX() + (actualMoves * direction.getXFactor()), position.getY() + (actualMoves * direction.getYFactor()));\n    }\n\n    public Direction getDirection() {\n        return direction;\n    }\n\n    public int getMoves() {\n        return moves;\n    }\n\n    @Override\n    public String toString() {\n        return \"[\" + direction.getCode() +\n                \",\" + moves +\n                \"]\";\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Movement movement = (Movement) o;\n        return moves == movement.moves && direction == movement.direction;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(direction, moves);\n    }\n\n    private void parseMovement(String movement) {\n        Pattern pattern = Pattern.compile(PATTERN);\n        Matcher matcher = pattern.matcher(movement);\n\n        if (matcher.find()) {\n            direction = Direction.getValue(matcher.group(1));\n            moves = Integer.parseInt(matcher.group(2));\n        }\n    }\n}\n"}, {"source": "student", "name": "student149", "file_name": "Position.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.Objects;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Position {\n\n    private static final String PATTERN = \"\\\\((\\\\d+)\\\\,(\\\\d+)\\\\)\";\n\n    private int x;\n    private int y;\n\n    public Position(String position) {\n        parsePosition(position);\n    }\n\n    public Position(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" +\n                x +\n                \",\" +\n                y +\n                ')';\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Position position = (Position) o;\n        return x == position.x && y == position.y;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x, y);\n    }\n\n    private void parsePosition(String position) {\n        Pattern pattern = Pattern.compile(PATTERN);\n        Matcher matcher = pattern.matcher(position);\n\n        if (matcher.find()) {\n            x = Integer.parseInt(matcher.group(1));\n            y = Integer.parseInt(matcher.group(2));\n        }\n    }\n}\n"}, {"source": "student", "name": "student149", "file_name": "Transition.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.Objects;\n\npublic class Transition {\n\n    private Position fromPosition;\n    private Position toPosition;\n\n    public Transition(Position fromPosition, Position toPosition) {\n        this.fromPosition = fromPosition;\n        this.toPosition = toPosition;\n    }\n\n    public Position getFromPosition() {\n        return fromPosition;\n    }\n\n    public Position getToPosition() {\n        return toPosition;\n    }\n\n    @Override\n    public String toString() {\n        return \"Transition{\" +\n                fromPosition +\n                \",\" + toPosition +\n                '}';\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Transition that = (Transition) o;\n        return (Objects.equals(fromPosition, that.fromPosition) && Objects.equals(toPosition, that.toPosition))\n                || (Objects.equals(fromPosition, that.toPosition) && Objects.equals(toPosition, that.fromPosition));\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(fromPosition, toPosition);\n    }\n}\n"}, {"source": "student", "name": "student15", "file_name": "Coordinate.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Coordinate {\n\n    int x;\n    int y;\n    String blockedDir;\n\n    public Coordinate(int x, int y, String blockedDir){\n        this.x = x;\n        this.y = y;\n        this.blockedDir = blockedDir;\n    }\n}\n"}, {"source": "student", "name": "student15", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n\n    int max_x = 11;\n    int max_y = 8;\n    Coordinate currentPos = new Coordinate(8,3, \"\");\n    Coordinate[] blockedFields =\n                            {new Coordinate(4,1, \"we\"), new Coordinate(4,2, \"we\"), new Coordinate(4,3, \"we\"),\n                            new Coordinate(4,4, \"we\"), new Coordinate(4,5, \"we\"), new Coordinate(4,6, \"we\"),\n                                    new Coordinate(3,1, \"ea\"), new Coordinate(3,2, \"ea\"), new Coordinate(3,3, \"ea\"),\n                                    new Coordinate(3,4, \"ea\"), new Coordinate(3,5, \"ea\"), new Coordinate(3,6, \"ea\"),\n                            new Coordinate(8,1, \"no\"), new Coordinate(7,1, \"no\"), new Coordinate(6,1, \"no\"),\n                            new Coordinate(5,2, \"ea\"), new Coordinate(5,3, \"ea\"), new Coordinate(5,4, \"ea\"),\n                            new Coordinate(6,5, \"so\"), new Coordinate(7,5, \"so\"), new Coordinate(8,5, \"so\"),\n                            new Coordinate(6,2, \"so\"), new Coordinate(6,2, \"we\"), new Coordinate(7,2, \"so\"), new Coordinate(8,2, \"so\"),\n                            new Coordinate(6,4, \"no\"), new Coordinate(6,4, \"we\"), new Coordinate(7,4, \"no\"), new Coordinate(8,4, \"no\"),\n                            new Coordinate(6,3,\"we\")};\n\n\n    @Override\n    public String moveTo(String moveCommandString) {\n\n        char[] moveString = moveCommandString.toCharArray();\n        String direction = \"\" + moveString[1] + moveString[2];\n        int amount;\n        String temp = \"\";\n        boolean onWall = false;\n\n        for(int i = 4; i<=moveString.length-2; i++){\n            temp += moveString[i];\n        }\n\n        amount = Integer.parseInt(temp);\n\n        System.out.println(direction);\n        System.out.println(amount);\n\n        switch(direction){\n            case \"no\":\n                onWall = false;\n\n                for(int i = amount; i>0; i--){\n                    if(currentPos.y+1<= max_y){\n                        for(int j = 0; j<blockedFields.length; j++){\n\n                            if(currentPos.x == blockedFields[j].x && currentPos.y == blockedFields[j].y && \"no\" == blockedFields[j].blockedDir){\n                                onWall = true;\n                            }\n                        }\n                        if(onWall == false){\n                            currentPos.y += 1;\n                            System.out.println(\"no\");\n                        }\n                    }\n                }\n                break;\n            case \"ea\":\n                onWall = false;\n\n                for(int i = amount; i>0; i--){\n                    if(currentPos.x+1<= max_x){\n                        for(int j = 0; j<blockedFields.length; j++){\n                            if(currentPos.x == blockedFields[j].x && currentPos.y == blockedFields[j].y && \"ea\" == blockedFields[j].blockedDir){\n                                onWall = true;\n                            }\n                        }\n                        if(onWall == false){\n                            currentPos.x += 1;\n                            System.out.println(\"ea\");\n                        }\n                    }\n                }\n                break;\n            case \"so\":\n                onWall = false;\n\n                for(int i = amount; i>0; i--){\n                    if(currentPos.y-1>=0){\n                        for(int j = 0; j<blockedFields.length; j++){\n                            if(currentPos.x == blockedFields[j].x && currentPos.y == blockedFields[j].y && \"so\" == blockedFields[j].blockedDir){\n                                onWall = true;\n                            }\n                        }\n                        if(onWall == false){\n                            currentPos.y -= 1;\n                            System.out.println(\"so\");\n                        }\n                    }\n                }\n                break;\n            case \"we\":\n                onWall = false;\n\n                for(int i = amount; i>0; i--){\n                    if(currentPos.x-1>=0){\n                        for(int j = 0; j<blockedFields.length; j++){\n                            if(currentPos.x == blockedFields[j].x && currentPos.y == blockedFields[j].y && \"we\" == blockedFields[j].blockedDir){\n                                onWall = true;\n                            }\n                        }\n                        if(onWall == false){\n                            currentPos.x -= 1;\n                            System.out.println(\"we\");\n                        }\n                    }\n                }\n                break;\n        }\n        String result = \"(\" + currentPos.x + \",\" + currentPos.y + \")\";\n\n        return result;\n    }\n\n}\n\n"}, {"source": "student", "name": "student15", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String moveTo(String moveCommandString);\n}\n"}, {"source": "student", "name": "student153", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n\n    int  starty=7;\n    int startx=11;\n\n\n    @Override\n    public String walk(String walkCommandString) {\n\n\n\n\n\n        String direction = walkCommandString.substring(1, 3);\n        String substr2 = walkCommandString.substring(4, 5);\n        int steps = Integer.parseInt(substr2);\n\n\n        //Array erstellen\n\n        int [][] ship = new int [8][12];\n\n        //Array bef\u00fcllen\n\n        for(int y=0;y<8;y++){\n            for (int x=0;x<12;x++){\n                ship[y][x]=0;\n            }\n        }\n\n        //Array spezifisch bef\u00fcllen, der Rand des Shiffes\n\n        for (int x=1;x<11;x++){\n            ship[0][x]=2;\n        }\n        for (int x=1;x<11;x++){\n            ship[7][x]=4;\n        }\n        for (int y=1;y<7;y++){\n            ship[y][0]=1;\n        }\n        for (int y=1;y<7;y++){\n            ship[y][11]=3;\n        }\n        ship[0][0]=5;\n        ship[0][11]=6;\n        ship[7][0]=8;\n        ship[7][11]=7;\n\n        // Wand ins Array f\u00fcllen\n\n        ship[2][5]=3;\n        ship[3][5]=3;\n        ship[4][5]=7;\n        ship[5][4]=3;\n        ship[5][5]=12;\n        ship[2][6]=1;\n        ship[3][6]=1;\n        ship[4][6]=1;\n        ship[5][11]=7;\n        ship[6][11]=6;\n\n        for(int x=6;x<11;x++){\n            ship[5][x]=4;\n        }\n        for(int x=5;x<11;x++){\n            ship[6][x]=2;\n        }\n\n        //\n\n\n       //Move step by Step\n\n    switch (direction){\n        case \"we\":\n\n        for ( int s=0;s<steps;s++){\n           if (ship[starty][startx]== 1 || ship[starty][startx]==5 ||ship[starty][startx]==8||ship[starty][startx]==9||ship[starty][startx]==11||ship[starty][startx]==12){\n               break;\n           }\n            startx=startx-1;\n\n        }\n        break;\n        case \"ea\":\n\n            for ( int s=0;s<steps;s++){\n                if(ship[starty][startx]==3||ship[starty][startx]==6||ship[starty][startx]==7||ship[starty][startx]==9||ship[starty][startx]==10||ship[starty][startx]==11 ){\n                    break;\n                }\n                startx=startx+1;\n\n            }\n            break;\n        case \"no\":\n\n            for ( int s=0;s<steps;s++){\n                if(ship[starty][startx]==4||ship[starty][startx]==7||ship[starty][startx]==8||ship[starty][startx]==10||ship[starty][startx]==11||ship[starty][startx]==12 ){\n\n                    break;\n                }\n                starty=starty+1;\n\n            }\n            break;\n        case \"so\":\n\n            for ( int s=0;s<steps;s++){\n                if(ship[starty][startx]==2||ship[starty][startx]==5||ship[starty][startx]==6||ship[starty][startx]==9||ship[starty][startx]==10||ship[starty][startx]==12){\n                    break;\n                }\n                starty=starty-1;\n\n            }\n            break;\n\n\n\n\n\n\n\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n        return (\"(\"+startx+\",\"+starty+\")\");\n    }\n}\n"}, {"source": "student", "name": "student153", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walk(String walkCommandString);\n}\n"}, {"source": "student", "name": "student157", "file_name": "Direction.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic enum Direction {\n    NORTH, EAST, SOUTH, WEST\n}\n"}, {"source": "student", "name": "student157", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.ArrayList;\n\npublic class Exercise0 implements Walkable {\n\n    public Exercise0() {\n        this.setIllegalMoves();\n    }\n\n    public ArrayList<Move> illegalMoves = new ArrayList<>();\n    private int positionX = 0;\n    private int positionY = 2;\n\n    @Override\n    public String walk(String walkCommandString) {\n        WalkCommand walkCommand = new WalkCommand(walkCommandString);\n        makeMoves(walkCommand);\n        return \"(\" + this.positionX + \",\" + this.positionY + \")\";\n    }\n\n    private void makeMoves(WalkCommand walkCommand) {\n        for (int i = 0; i < walkCommand.steps; i++) {\n            Move currentMove = new Move(this.positionX, this.positionY, walkCommand.direction);\n            if(illegalMoves.contains(currentMove)) {\n                break;\n            }\n\n            switch (walkCommand.direction) {\n                case EAST:\n                    if(positionX == 11) {\n                        break;\n                    }\n                    positionX++;\n                    System.out.println(\"Right\");\n                    break;\n                case WEST:\n                    if(positionX == 0) {\n                        break;\n                    }\n                    positionX--;\n                    System.out.println(\"Left\");\n                    break;\n                case NORTH:\n                    if(positionY == 8) {\n                        break;\n                    }\n                    positionY++;\n                    break;\n                case SOUTH:\n                    if(positionY == 0) {\n                        break;\n                    }\n                    positionY--;\n                    System.out.println(\"Down\");\n                    break;\n            }\n        }\n    }\n\n    private void setIllegalMoves() {\n        illegalMoves.add(new Move(4, 4, Direction.NORTH));\n        illegalMoves.add(new Move(5, 4, Direction.NORTH));\n        illegalMoves.add(new Move(6, 4, Direction.NORTH));\n\n        illegalMoves.add(new Move(4, 5, Direction.SOUTH));\n        illegalMoves.add(new Move(5, 5, Direction.SOUTH));\n        illegalMoves.add(new Move(6, 5, Direction.SOUTH));\n\n\n        illegalMoves.add(new Move(2, 0, Direction.EAST));\n        illegalMoves.add(new Move(2, 1, Direction.EAST));\n        illegalMoves.add(new Move(2, 2, Direction.EAST));\n\n        illegalMoves.add(new Move(3, 0, Direction.WEST));\n        illegalMoves.add(new Move(3, 1, Direction.WEST));\n        illegalMoves.add(new Move(3, 3, Direction.WEST));\n\n\n        illegalMoves.add(new Move(4, 0, Direction.EAST));\n        illegalMoves.add(new Move(4, 1, Direction.EAST));\n        illegalMoves.add(new Move(4, 2, Direction.EAST));\n        illegalMoves.add(new Move(4, 3, Direction.EAST));\n\n        illegalMoves.add(new Move(5, 0, Direction.WEST));\n        illegalMoves.add(new Move(5, 1, Direction.WEST));\n        illegalMoves.add(new Move(5, 2, Direction.WEST));\n        illegalMoves.add(new Move(5, 3, Direction.WEST));\n\n\n        illegalMoves.add(new Move(6, 5, Direction.EAST));\n        illegalMoves.add(new Move(6, 6, Direction.EAST));\n        illegalMoves.add(new Move(6, 7, Direction.EAST));\n        illegalMoves.add(new Move(6, 8, Direction.EAST));\n\n        illegalMoves.add(new Move(7, 5, Direction.WEST));\n        illegalMoves.add(new Move(7, 6, Direction.WEST));\n        illegalMoves.add(new Move(7, 7, Direction.WEST));\n        illegalMoves.add(new Move(7, 8, Direction.WEST));\n    }\n}\n"}, {"source": "student", "name": "student157", "file_name": "Move.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.Objects;\n\npublic class Move {\n\n    public int positionX;\n    public int positionY;\n\n    public Direction direction;\n\n    public Move(int positionX, int positionY, Direction direction) {\n        this.positionY = positionY;\n        this.positionX = positionX;\n        this.direction = direction;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Move move = (Move) o;\n        return positionX == move.positionX && positionY == move.positionY && direction == move.direction;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(positionX, positionY, direction);\n    }\n}\n"}, {"source": "student", "name": "student157", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walk(String walkCommandString);\n}\n"}, {"source": "student", "name": "student157", "file_name": "WalkCommand.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class WalkCommand {\n\n    public Direction direction;\n    public int steps;\n\n    WalkCommand(String walkCommandString) {\n        setDirection(walkCommandString);\n        setSteps(walkCommandString);\n    }\n\n    private void setSteps(String walkCommandString) {\n        char[] stepsArray = new char[walkCommandString.length()-5];\n        walkCommandString.getChars(4, walkCommandString.length() -1, stepsArray, 0);\n        String stepsString = new String(stepsArray);\n        this.steps = Integer.parseInt(stepsString);\n    }\n\n    private void setDirection(String walkCommandString) {\n        String directionString = getString(walkCommandString);\n        setDirectionEnum(directionString);\n    }\n\n    private void setDirectionEnum(String directionString) {\n        switch (directionString) {\n            case \"no\":\n                this.direction = Direction.NORTH;\n                break;\n            case \"ea\":\n                this.direction = Direction.EAST;\n                break;\n            case \"so\":\n                this.direction = Direction.SOUTH;\n                break;\n            case \"we\":\n                this.direction = Direction.WEST;\n                break;\n        }\n    }\n\n    private String getString(String walkCommandString) {\n        return String.valueOf(walkCommandString.charAt(1)) + walkCommandString.charAt(2);\n    }\n\n    public void print() {\n        System.out.println(direction);\n        System.out.println(steps);\n    }\n}\n"}, {"source": "student", "name": "student158", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.ArrayList;\n\npublic class Exercise0 implements Moveable {\n\n    private ArrayList<Wall> walls = new ArrayList<Wall>();\n\n    private Integer posX = 0;\n\n    private Integer posY = 2;\n\n/*\nno = x +\nso = x -\nea = y +\nwe = y -\n*/\n\n    @Override\n    public String moveTo(String input) {\n        if(walls.isEmpty()){\n            setWalls();\n        }\n        String direction = input.substring(1,3);\n        int steps = Integer.parseInt(input.substring(4,6).replace(\"]\", \"\"));\n\n        switch (direction){\n            case \"ea\":\n                for (int i = 0;i<steps;i++){\n                    boolean marker=true;\n                    for(int j=0;j<walls.size();j++){\n                        if(posX==11){\n                            marker = false;\n                            continue;\n                        }\n                        if(marker){\n                            marker = !walls.get(j).checkBlock(posX, posY, 1,0);\n                        }\n                    }\n                    if (marker){\n                        posX++;\n                    } else {\n                        continue;\n                    }\n                }\n                break;\n            case \"we\":\n                for (int i = 0;i<steps;i++){\n                    boolean marker=true;\n                    for(int j=0;j<walls.size();j++){\n                        if(posX==0){\n                            marker = false;\n                            continue;\n                        }\n                        if(marker){\n                            marker = !walls.get(j).checkBlock(posX, posY, -1,0);\n                        }\n                    }\n                    if (marker){\n                        posX--;\n                    } else {\n                        continue;\n                    }\n                }\n                break;\n            case \"no\":\n                for (int i = 0;i<steps;i++){\n                    boolean marker=true;\n                    for(int j=0;j<walls.size();j++){\n                        if (posY == 8){\n                            marker = false;\n                            continue;\n                        }\n                        if(marker){\n                            marker = !walls.get(j).checkBlock(posX, posY, 0,1);\n                        }\n                    }\n                    if (marker){\n                        posY++;\n                    } else {\n                        continue;\n                    }\n                }\n                break;\n            case \"so\":\n                for (int i = 0;i<steps;i++){\n                    boolean marker=true;\n                    for(int j=0;j<walls.size();j++){\n                        if(posY==0){\n                            marker = false;\n                            continue;\n                        }\n                        if(marker){\n                            marker = !walls.get(j).checkBlock(posX, posY, 0,-1);\n                        }\n                    }\n                    if (marker){\n                        posY--;\n                    } else {\n                        continue;\n                    }\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"???\");\n        }\n        String erg = \"(\" + posX+ \",\" + posY+\")\";\n        return erg;\n    }\n\n\n    private void setWalls(){\n        Wall one = new Wall(3,0,3,3);\n        Wall two = new Wall(5,0,5,4);\n        Wall three = new Wall(7,5,7,9);\n        Wall four = new Wall(4,5,7,5);\n\n        walls.add(one);\n        walls.add(two);\n        walls.add(three);\n        walls.add(four);\n\n        /*\n        3,0-3,3\n        5,0-5,4\n        7,5-7-9\n        4,5-7,5\n        */\n    }\n\n}\n"}, {"source": "student", "name": "student158", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String moveTo(String moveCommandString);\n}\n"}, {"source": "student", "name": "student158", "file_name": "Wall.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Wall {\n\n    int startx;\n\n    int starty;\n\n    int endx;\n\n    int endy;\n\n    private boolean direction;\n\n    public Wall(int startx, int starty, int endx, int endy) {\n        this.startx = startx;\n        this.starty = starty;\n        this.endx = endx;\n        this.endy = endy;\n        direction = startx == endx;\n    }\n\n    public boolean checkBlock(int posx, int posy, int stepx, int stepy){\n        if (direction && stepy != 0){\n            return false;\n        } else if (!direction && stepx != 0){\n            return false;\n        }\n        if (stepx!=0){\n            return checkx(posx, stepx, posy);\n        } else {\n            return checky(posy, stepy, posx);\n        }\n    }\n\n    private boolean checkx(int posx, int step, int posy){\n        int newpos = posx+step;\n        for (int i = startx; i<=endx;i++){\n            for(int j = starty; j<=endy; j++){\n                if(step>0) {\n                    if(posy<starty){\n                        if (newpos == i && posy == j) {\n                            return true;\n                        }\n                    } else if (newpos == i && posy == j-1) {\n                        return true;\n                    }\n                } else if(newpos == i-1 && posy == j - 1){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n\n    private boolean checky(int posy, int step, int posx){\n        int newpos = posy+step;\n        for (int i = starty; i<=endy;i++){\n            for(int j= startx; j<= endx;j++){\n                if(step>0) {\n                    if (posx < startx){\n                        if (newpos == i && posx == j) {\n                            return true;\n                        }\n\n                    } else if (newpos == i && posx == j-1) {\n                        return true;\n                    }\n                } else if (newpos == i-1 && posx == j - 1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n}\n"}, {"source": "student", "name": "student16", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n\n    Integer current_X = 0;\n    Integer current_Y = 2;\n    Integer MAX_X = 11;\n    Integer MAX_Y = 8;\n    @Override\n    public String move(String moveCommandString) {\n        var direction = moveCommandString.substring(1,3);\n        var movement = Integer.valueOf(moveCommandString.substring(4,5));\n        if(direction.equals(\"no\")){\n            if(current_Y <= 4 && current_X >= 4 && current_X <= 6){\n                current_Y += movement;\n                if(current_Y > 4) current_Y = 4;\n            }\n            else{\n                current_Y += movement;\n                if(current_Y > MAX_Y) current_Y = MAX_Y;\n            }\n        }\n        else if(direction.equals(\"so\")){\n            if(current_Y >= 5 && current_X >= 4 && current_X <= 6){\n                current_Y -= movement;\n                if(current_Y < 5) current_Y = 5;\n            }\n            else{\n                current_Y -= movement;\n                if(current_Y < 0) current_Y = 0;\n            }\n        }\n        else if(direction.equals(\"ea\")){\n            if(current_X <= 2 && current_Y >= 0 && current_Y <= 2){\n                current_X += movement;\n                if(current_X > 2) current_X = 2;\n            }\n            else if(current_X >= 3 && current_X <= 4 && current_Y >= 0 && current_Y <= 2){\n                current_X += movement;\n                if(current_X > 4) current_X = 4;\n            }\n            else if(current_X <= 4 && current_Y == 3){\n                current_X += movement;\n                if(current_X > 4) current_X = 4;\n            }\n            else if(current_X <= 6 && current_Y >= 5 && current_Y <= 8){\n                current_X += movement;\n                if(current_X > 6) current_X = 6;\n            }\n            else{\n                current_X += movement;\n                if(current_X > MAX_X) current_X = MAX_X;\n            }\n        }\n        else if(direction.equals(\"we\")){\n            if(current_X >= 3 && current_X <= 4 && current_Y >= 0 && current_Y <= 2){\n                current_X -= movement;\n                if(current_X < 3) current_X = 3;\n            }\n            else if(current_X >= 5 && current_Y >= 0 && current_Y <= 3){\n                current_X -= movement;\n                if(current_X < 5) current_X = 5;\n            }\n            else if(current_X >= 7 && current_Y >= 5 && current_Y <= 8){\n                current_X -= movement;\n                if(current_X < 7) current_X = 7;\n            }\n            else{\n                current_X -= movement;\n                if(current_X < 0) current_X = 0;\n            }\n        }\n        String returnString = String.format(\"(%d,%d)\",current_X,current_Y);\n        return returnString;\n    }\n}\n"}, {"source": "student", "name": "student16", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "student", "name": "student17", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport thkoeln.st.st2praktikum.exercise.BitPaw.MoveCommand;\nimport thkoeln.st.st2praktikum.exercise.BitPaw.Point;\nimport thkoeln.st.st2praktikum.exercise.BitPaw.Room;\n\npublic class Exercise0 implements Moveable\n{\n    private final Room _room = new Room();\n\n    @Override\n    public String moveTo(String moveCommandString)\n    {\n        MoveCommand moveCommand = new MoveCommand(moveCommandString);\n        Point currentPosition = _room.MoveRoboter(moveCommand);\n\n        return currentPosition.toString();\n    }\n}\n"}, {"source": "student", "name": "student17", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable\n{\n    String moveTo(String moveCommandString);\n}\n"}, {"source": "student", "name": "student17", "file_name": "BitPaw\\Axis.java", "code": "package thkoeln.st.st2praktikum.exercise.BitPaw;\n\npublic enum Axis\n{\n    Horizontal,\n    Vertical\n}\n"}, {"source": "student", "name": "student17", "file_name": "BitPaw\\Barrier.java", "code": "package thkoeln.st.st2praktikum.exercise.BitPaw;\n\npublic class Barrier\n{\n    private Point _from;\n    private Point _to;\n\n    public Point From() {return _from;}\n    public Point To() {return _to;}\n\n    public Axis Orientation;\n\n    public Barrier(int xA, int yA, int xB, int yB)\n    {\n        Set(xA, yA, xB, yB);\n    }\n\n    public Barrier(Point from, Point to)\n    {\n        Set(from, to);\n    }\n\n    public void Set(int xA, int yA, int xB, int yB)\n    {\n        Set(new Point(xA, yA), new Point(xB, yB));\n    }\n\n    public void Set(Point from, Point to)\n    {\n        boolean isXSame = from.X == to.X;\n        boolean isYSame = from.Y == to.Y;\n        boolean isLiniar = (isXSame || isYSame) && !(isXSame && isYSame);\n\n        if(!isLiniar)\n        {\n            throw new IllegalArgumentException();\n        }\n\n        if(isXSame)\n        {\n            Orientation = Axis.Vertical;\n        }\n\n        if(isYSame)\n        {\n            Orientation = Axis.Horizontal;\n        }\n\n        _from = from;\n        _to = to;\n    }\n\n    public int GetWallOriantationValue()\n    {\n        switch (Orientation)\n        {\n\n            case Horizontal:\n                return From().Y;\n\n            default:\n            case Vertical:\n                return From().X;\n        }\n    }\n\n    public boolean Collide(final Point point)\n    {\n        return Collide(point, Axis.Horizontal) && Collide(point, Axis.Vertical);\n    }\n\n    @Override\n    public String toString()\n    {\n        return  _from + \"-\" + _to + \"(\" + Orientation + \")\";\n    }\n\n    public boolean Collide(final Point point, final Axis axis)\n    {\n        final int x = point.X;\n        final int y = point.Y;\n\n        switch (axis)\n        {\n            case Vertical:\n            {\n                final int xMax = Math.max(_from.X, _to.X);\n                final int xMin = Math.min(_from.X, _to.X);\n\n                return  x < xMax && x >= xMin;\n            }\n\n            default:\n            case Horizontal:\n            {\n                final int yMax = Math.max(_from.Y, _to.Y);\n                final int yMin = Math.min(_from.Y, _to.Y);\n\n                return y < yMax && y >= yMin;\n            }\n        }\n    }\n}"}, {"source": "student", "name": "student17", "file_name": "BitPaw\\MoveCommand.java", "code": "package thkoeln.st.st2praktikum.exercise.BitPaw;\n\npublic class MoveCommand\n{\n    public MoveDirection Direction;\n    public int MoveLength;\n    public Axis Orientation;\n    public boolean IsPositiveDirection;\n\n    public MoveCommand(final MoveDirection direction,  final int moveLength)\n    {\n        Direction = direction;\n        MoveLength = moveLength;\n    }\n\n    public MoveCommand(final String command)\n    {\n        int firstComma = command.indexOf(',');\n        int lengh = command.length();\n        boolean validLength = lengh >= 6;\n        boolean leftBracket;\n        boolean rightBacket;\n        String tempString;\n\n        if(!validLength)\n        {\n            Direction = MoveDirection.None;\n            return;\n        }\n\n        leftBracket = '[' == command.charAt(0);\n        rightBacket = ']' == command.charAt(lengh-1);\n\n        tempString = command.substring(1,firstComma);\n\n        switch (tempString)\n        {\n            case \"no\": // (north),\n                Direction = MoveDirection.Up;\n                Orientation = Axis.Vertical;\n                IsPositiveDirection = true;\n                break;\n\n            case \"ea\": // (east),\n                Direction = MoveDirection.Right;\n                Orientation = Axis.Horizontal;\n                IsPositiveDirection = true;\n                break;\n\n            case \"so\": // (south),\n                Direction = MoveDirection.Down;\n                Orientation = Axis.Vertical;\n                IsPositiveDirection = false;\n                break;\n\n            case \"we\": // (west).\n                Direction = MoveDirection.Left;\n                Orientation = Axis.Horizontal;\n                IsPositiveDirection = false;\n                break;\n        }\n\n        // Parse movement length\n        tempString =  command.substring(firstComma+1, lengh-1);\n\n        MoveLength = Integer.parseInt(tempString);\n    }\n\n    public Point ConvertToPoint()\n    {\n        Point point = new Point();\n\n        switch (Direction)\n        {\n            case Up:\n                point.Set(0, MoveLength);\n                break;\n\n            case Down:\n                point.Set(0, -MoveLength);\n                break;\n\n            case Left:\n                point.Set(-MoveLength, 0);\n                break;\n\n            case Right:\n                point.Set(MoveLength, 0);\n                break;\n        }\n\n        return point;\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        MoveCommand that = (MoveCommand) o;\n\n        return equals(that);\n    }\n\n    public boolean equals(MoveCommand moveCommand)\n    {\n        return (MoveLength == moveCommand.MoveLength) && (Direction == moveCommand.Direction);\n    }\n\n    @Override\n    public String toString()\n    {\n        String directionTag;\n\n        switch (Direction)\n        {\n            case Up:\n                directionTag = \"no\";\n                break;\n\n            case Down:\n                directionTag = \"so\";\n                break;\n\n            case Left:\n                directionTag = \"we\";\n                break;\n\n            case Right:\n                directionTag = \"ea\";\n                break;\n\n            default:\n                directionTag = \"ERROR\";\n                break;\n        }\n\n        return \"[\" +directionTag + \",\" + MoveLength + \"]\";\n    }\n}\n"}, {"source": "student", "name": "student17", "file_name": "BitPaw\\MoveDirection.java", "code": "package thkoeln.st.st2praktikum.exercise.BitPaw;\n\npublic enum MoveDirection\n{\n    None,\n    Up,\n    Down,\n    Left,\n    Right\n}\n"}, {"source": "student", "name": "student17", "file_name": "BitPaw\\Point.java", "code": "package thkoeln.st.st2praktikum.exercise.BitPaw;\n\nimport com.fasterxml.jackson.databind.node.POJONode;\nimport org.springframework.data.domain.Sort;\n\npublic class Point\n{\n    public int X;\n    public int Y;\n\n    public Point()\n    {\n        Set(0, 0);\n    }\n\n    public Point(int x, int y)\n    {\n        Set(x, y);\n    }\n\n    public void Set(int x, int y)\n    {\n        X = x;\n        Y = y;\n    }\n\n    public void Add(Point point)\n    {\n        X += point.X;\n        Y += point.Y;\n    }\n\n    public static boolean IsBNearer(Point reference, int x, int y, MoveDirection direction)\n    {\n        int xDiff;\n        int yDiff;\n\n        switch (direction)\n        {\n            case Up:\n                xDiff = Math.abs(x - reference.Y);\n                yDiff = Math.abs(y - reference.Y);\n                return xDiff > yDiff;\n\n\n            case Down:\n                xDiff = Math.abs(x - reference.Y);\n                yDiff = Math.abs(y - reference.Y);\n                return xDiff > yDiff;\n\n            case Left:\n                xDiff = Math.abs(x - reference.X);\n                yDiff = Math.abs(y - reference.X);\n                return xDiff > yDiff;\n\n            default:\n            case Right:\n                xDiff = Math.abs(x - reference.X);\n                yDiff = Math.abs(y - reference.X);\n                return xDiff > yDiff;\n        }\n\n\n    }\n\n    public boolean IsBNearer(Point a, Point b)\n    {\n        int xDiffA = Math.abs(a.X - X);\n        int yDiffA = Math.abs(a.Y - Y);\n        int xDiffB = Math.abs(b.X - X);\n        int yDiffB = Math.abs(b.Y - Y);\n\n        int deltaX = Math.abs(xDiffA - xDiffB );\n        int deltaY = Math.abs(yDiffA - yDiffB );\n\n        if(deltaX > deltaY)\n        {\n            // Look at X\n            return xDiffA < xDiffB;\n        }\n        else\n        {\n            // Loook at Y\n            return yDiffA < yDiffB;\n        }\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"(\" + X + \",\" + Y + ')';\n    }\n}\n"}, {"source": "student", "name": "student17", "file_name": "BitPaw\\Robot.java", "code": "package thkoeln.st.st2praktikum.exercise.BitPaw;\n\npublic class Robot\n{\n    public Point CurrentPosition;\n\n    public Robot(Point startPosition)\n    {\n        CurrentPosition = startPosition;\n    }\n}\n"}, {"source": "student", "name": "student17", "file_name": "BitPaw\\Room.java", "code": "package thkoeln.st.st2praktikum.exercise.BitPaw;\n\nimport org.springframework.data.domain.Sort;\n\nimport javax.persistence.ManyToOne;\n\npublic class Room\n{\n    private Barrier[] _barrierList;\n    private final Robot _robot;\n    private final Point _roomMaxIndex;\n\n    private boolean _ignoreBarrier = true;\n\n    public Room()\n    {\n        final Point startPosition = new Point(0,2);\n        final int width = 12;\n        final int height = 9;\n\n        _roomMaxIndex = new Point(width,height);\n\n        _robot = new Robot(startPosition);\n\n\nif(_ignoreBarrier)\n{\n    _barrierList = new Barrier[4];\n    _barrierList[0] = new Barrier(3,0,3,3);\n    _barrierList[1] = new Barrier(5,0,5,4);\n    _barrierList[2] = new Barrier(4,5,7,5);\n    _barrierList[3] = new Barrier(7,5,7,9);\n}\n\n\n    }\n\n    private boolean Between(int a, int b, int value)\n    {\n        int max = Math.max(a, b);\n        int min = Math.min(a, b);\n\n        return min < value && value < max;\n    }\n\n    private MoveCommand GetNextPossibleMove(final MoveCommand move)\n    {\n        int nearestWall;\n        int maximalSteps = Integer.MAX_VALUE;\n\n        // Get worldBorder\n        switch (move.Direction)\n        {\n            case Up:\n                nearestWall = _roomMaxIndex.Y;\n                break;\n\n            case Down:\n            case Left:\n                nearestWall = -1;\n                break;\n\n            default:\n            case Right:\n                nearestWall = _roomMaxIndex.X;\n                break;\n        }\n\n        for (Barrier barrier : _barrierList) // Go thru every barrier\n        {\n            if (move.Orientation != barrier.Orientation)  // Get only the barriers with opposite axis\n            {\n                // Are we in collidable direction?\n                boolean canCollide = barrier.Collide(_robot.CurrentPosition, move.Orientation);\n\n                if (canCollide)\n                {\n                    int barrierValue = barrier.GetWallOriantationValue();\n\n                    // We can collide with the wall\n\n                    // Check for range\n\n                    if(Point.IsBNearer(_robot.CurrentPosition,nearestWall, barrierValue, move.Direction))\n                    {\n                        nearestWall = barrierValue;\n                    }\n\n                    /*\n                    // Is the wall nearer to the object\n                    if (move.IsPositiveDirection) {\n                        if (nearestWall > barrierValue && Point.IsBNearer(_robot.CurrentPosition,nearestWall, barrierValue, move.Direction)) {\n                            // Wall is nearer\n                            nearestWall = barrierValue;\n                        }\n                    } else {\n                        if (nearestWall < barrierValue && Point.IsBNearer(_robot.CurrentPosition,nearestWall,barrierValue, move.Direction)) {\n                            // Wall is nearer\n                            nearestWall = barrierValue;\n                        }\n                    }\n*/\n\n\n                }\n            }\n        }\n\n\n\n\n\n\n\n            // Get worldBorder\n            switch (move.Direction)\n            {\n                case Down:\n                {\n                    int wantedPos = _robot.CurrentPosition.Y - move.MoveLength;\n                    int wallPos = nearestWall;\n                    int movelength = move.MoveLength;\n\n                    if(wantedPos < 0) // If we overflow at the bottom, all remaining fields are the move\n                    {\n                        movelength = _robot.CurrentPosition.Y;\n                    }\n\n                    if(wantedPos > wallPos)\n                    {\n                        maximalSteps = movelength + (wantedPos - wallPos);\n                    }\n                    else\n                    {\n                        maximalSteps = movelength;\n                    }\n                    break;\n                }\n\n                case Left:\n                    {\n                        int wantedPos = _robot.CurrentPosition.X - move.MoveLength;\n                        int wallPos = nearestWall;\n                        int movelength = move.MoveLength;\n\n                        if(wantedPos < 0) // If we overflow at the bottom, all remaining fields are the move\n                        {\n                            movelength = _robot.CurrentPosition.X;\n                        }\n\n                        if(wantedPos > wallPos || Between(wantedPos, _robot.CurrentPosition.X, nearestWall))\n                        {\n                            maximalSteps = movelength + (wantedPos - wallPos);\n                        }\n                        else\n                        {\n                            maximalSteps = movelength;\n                        }\n                    break;\n                }\n\n                case Up:\n                {\n                    int wantedPos = _robot.CurrentPosition.Y + move.MoveLength;\n                    int wallPos = nearestWall-1;\n                    int movelength = move.MoveLength;\n\n                    if(wantedPos > _roomMaxIndex.Y-1)\n                    {\n                        movelength = wantedPos - (wantedPos - _roomMaxIndex.Y-1);\n                    }\n\n                    if(wantedPos > wallPos)\n                    {\n                        maximalSteps = move.MoveLength - (wantedPos - wallPos);\n                    }\n                    else\n                    {\n                        maximalSteps = move.MoveLength;\n                    }\n                    break;\n                }\n\n                case Right:\n                {\n                    int wantedPos = _robot.CurrentPosition.X + move.MoveLength;\n                    int wallPos = nearestWall-1;\n                    int movelength = move.MoveLength;\n\n                    if(wantedPos > _roomMaxIndex.X-1)\n                    {\n                        movelength = wantedPos - (wantedPos - _roomMaxIndex.X-1);\n                    }\n\n                    if(wantedPos > wallPos)\n                    {\n                        maximalSteps = move.MoveLength - (wantedPos - wallPos);\n                    }\n                    else\n                    {\n                        maximalSteps = move.MoveLength;\n                    }\n                    break;\n                }\n            }\n\n\n        return new MoveCommand(move.Direction, maximalSteps);\n    }\n\n    public Point MoveRoboter(MoveCommand moveCommand)\n    {\n        final MoveCommand alteredMoveCommand = GetNextPossibleMove(moveCommand);\n        final boolean hasChanged = moveCommand.equals(alteredMoveCommand);\n        final Point movement = alteredMoveCommand.ConvertToPoint();\n        final Point oldPosition =  new Point(_robot.CurrentPosition.X, _robot.CurrentPosition.Y);\n        Point newPosition;\n\n        _robot.CurrentPosition.Add(movement);\n\n        newPosition =  _robot.CurrentPosition;\n\n        System.out.println(\"====================\");\n        System.out.print(\"Wanted: \" + moveCommand.toString());\n        System.out.println(\" CanDo: \" + alteredMoveCommand.toString());\n        System.out.print(\"Pos Before: \" + oldPosition.toString());\n        System.out.println(\" After: \" + newPosition.toString());\n\n        return _robot.CurrentPosition;\n    }\n}"}, {"source": "student", "name": "student18", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport lombok.AllArgsConstructor;\n\nimport java.util.HashSet;\n\npublic class Exercise0 implements GoAble {\n\n    public Exercise0(){\n        createObstacles();\n    }\n\n    Position position = new Position(7,7);\n    HashSet<Double> horizontalObstacles = new HashSet<>();\n    HashSet<Double> verticalObstacles = new HashSet<>();\n\n    @Override\n    public String goTo(String goCommandString) {\n        String[] input = goCommandString.replace(\"[\",\"\").replace(\"]\",\"\").split(\",\");\n        String direction = input[0];\n        int distance = Integer.parseInt(input[1]);\n\n        move(direction, distance);\n\n        return position.toString();\n    }\n\n    public void move(String direction, int distance) {\n        while(distance>0) {\n            if (direction.equals(\"no\") && !(isObstacle(position.x, position.y+1, direction) || position.y==7))\n                position.y++;\n            else if (direction.equals(\"ea\") && !(isObstacle(position.x+1, position.y, direction) || position.x==10))\n                position.x++;\n            else if (direction.equals(\"so\") && !(isObstacle(position.x, position.y, direction) || position.y==0))\n                position.y--;\n            else if (direction.equals(\"we\") && !(isObstacle(position.x, position.y, direction) || position.x==0))\n                position.x--;\n            else\n                break;\n            distance--;\n        }\n    }\n\n    @AllArgsConstructor\n    public class Position{\n        public Integer x;\n        public Integer y;\n\n        @Override\n        public String toString() {\n            return \"(\" + x.toString() + \",\" + y.toString() + \")\";\n        }\n    }\n\n    public Boolean isObstacle(int x, int y, String direction) {\n        Double pos = Double.valueOf(Integer.toString(x).concat(\".\").concat(Integer.toString(y)));\n        if (direction.equals(\"no\") || direction.equals(\"so\"))\n            return horizontalObstacles.contains(pos);\n        else\n            return verticalObstacles.contains(pos);\n    }\n\n    public void createObstacles(){\n        horizontalObstacles.add(2.6);\n        horizontalObstacles.add(3.6);\n        horizontalObstacles.add(4.6);\n        horizontalObstacles.add(5.6);\n        horizontalObstacles.add(6.6);\n\n        horizontalObstacles.add(2.1);\n        horizontalObstacles.add(3.1);\n        horizontalObstacles.add(4.1);\n        horizontalObstacles.add(5.1);\n        horizontalObstacles.add(6.1);\n        horizontalObstacles.add(7.1);\n        horizontalObstacles.add(8.1);\n        horizontalObstacles.add(9.1);\n\n        verticalObstacles.add(2.5);\n        verticalObstacles.add(2.4);\n        verticalObstacles.add(2.3);\n        verticalObstacles.add(2.2);\n        verticalObstacles.add(2.1);\n\n        verticalObstacles.add(10.1);\n        verticalObstacles.add(10.2);\n        verticalObstacles.add(10.3);\n        verticalObstacles.add(10.4);\n        verticalObstacles.add(10.5);\n        verticalObstacles.add(10.6);\n        verticalObstacles.add(10.7);\n        verticalObstacles.add(10.8);\n    }\n\n}\n"}, {"source": "student", "name": "student18", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "student", "name": "student19", "file_name": "Cell.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Cell {\n    private boolean borderNorth;\n    private boolean borderEast;\n    private boolean borderSouth;\n    private boolean borderWest;\n\n    public Cell() {\n        this.borderNorth = false;\n        this.borderEast = false;\n        this.borderSouth = false;\n        this.borderWest = false;\n    }\n\n    public boolean isBorderNorth() {\n        return borderNorth;\n    }\n\n    public void setBorderNorth(boolean borderNorth) {\n        this.borderNorth = borderNorth;\n    }\n\n    public boolean isBorderEast() {\n        return borderEast;\n    }\n\n    public void setBorderEast(boolean borderEast) {\n        this.borderEast = borderEast;\n    }\n\n    public boolean isBorderSouth() {\n        return borderSouth;\n    }\n\n    public void setBorderSouth(boolean borderSouth) {\n        this.borderSouth = borderSouth;\n    }\n\n    public boolean isBorderWest() {\n        return borderWest;\n    }\n\n    public void setBorderWest(boolean borderWest) {\n        this.borderWest = borderWest;\n    }\n}\n"}, {"source": "student", "name": "student19", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n\n    private final Cell[][] cellGrid;\n    private int cleaningDeviceX = 1;\n    private int cleaningDeviceY = 6;\n    private final int xDimension = 11;\n    private final int yDimension = 8;\n\n    public Exercise0() {\n        cellGrid = new Cell[xDimension][yDimension];\n\n        for (int i = 0; i < xDimension; i++) {\n            for (int j = 0; j < yDimension; j++) {\n                cellGrid[i][j] = new Cell();\n            }\n        }\n\n        setBorder(0, 6, 1, 6);\n        setBorder(3, 6, 3, 7);\n        setBorder(1, 5, 8, 5);\n        setBorder(9, 1, 9, 4);\n    }\n\n    private void setBorder(int startX, int startY, int endX, int endY) {\n        if ((endX - startX) != 0) {\n\n            for (int i = startX; i <= endX; i++) {\n                cellGrid[i][startY].setBorderSouth(true);\n                cellGrid[i][startY - 1].setBorderNorth(true);\n            }\n\n        } else if ((endY - startY) != 0) {\n\n            for (int i = startY; i <= endY; i++) {\n                cellGrid[startX][i].setBorderWest(true);\n                cellGrid[startX - 1][i].setBorderEast(true);\n            }\n\n        }\n    }\n\n    @Override\n    public String goTo(String goCommandString) {\n        String[] commands = goCommandString.split(\",\");\n        String direction = commands[0].substring(1);\n        int count = Integer.parseInt(commands[1].substring(0, commands[1].length() - 1));\n\n        switch (direction) {\n            case \"no\":\n                this.moveNorth(count);\n                break;\n            case \"ea\":\n                this.moveEast(count);\n                break;\n            case \"so\":\n                this.moveSouth(count);\n                break;\n            case \"we\":\n                this.moveWest(count);\n                break;\n        }\n\n        return \"(\" + this.cleaningDeviceX + \",\" + this.cleaningDeviceY + \")\";\n    }\n\n    private void moveNorth(int count) {\n        for (int i = count; i > 0; i--) {\n            if (!this.cellGrid[this.cleaningDeviceX][this.cleaningDeviceY].isBorderNorth() &&\n                    this.cleaningDeviceY + 1 < this.yDimension) {\n                this.cleaningDeviceY++;\n            } else return;\n        }\n    }\n\n    private void moveEast(int count) {\n        for (int i = count; i > 0; i--) {\n            if (!this.cellGrid[this.cleaningDeviceX][this.cleaningDeviceY].isBorderEast() &&\n                    this.cleaningDeviceX + 1 < this.xDimension) {\n                this.cleaningDeviceX++;\n            } else return;\n        }\n    }\n\n    private void moveSouth(int count) {\n        for (int i = count; i > 0; i--) {\n            if (!this.cellGrid[this.cleaningDeviceX][this.cleaningDeviceY].isBorderSouth() &&\n                    this.cleaningDeviceY - 1 >= 0) {\n                this.cleaningDeviceY--;\n            } else return;\n        }\n    }\n\n    private void moveWest(int count) {\n        for (int i = count; i > 0; i--) {\n            if (!this.cellGrid[this.cleaningDeviceX][this.cleaningDeviceY].isBorderWest() &&\n                    this.cleaningDeviceX - 1 >= 0) {\n                this.cleaningDeviceX--;\n            } else return;\n        }\n    }\n}\n"}, {"source": "student", "name": "student19", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "student", "name": "student2", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n    private int x = 0;\n    private int y = 2;\n\n    @Override\n    public String moveTo(String moveCommandString) {\n        char[] searchNum = moveCommandString.toCharArray();\n        StringBuilder stringBuilder = new StringBuilder();\n        for(char i : searchNum){\n            if(Character.isDigit(i)){\n                stringBuilder.append(i);\n            }\n        }\n\n        int move = 0;\n        if(stringBuilder == null) throw new RuntimeException();\n        else move = Integer.parseInt(stringBuilder.toString());\n\n        if(moveCommandString.contains(\"no\")){\n            int y1 = y + move;\n\n            if(y1 >= 9) y1 = 8;\n            else if((x >= 4 && x <= 6) && y1 >= 5 && y < 5) y1 = 4;\n\n            y = y1;\n        }\n        else if(moveCommandString.contains(\"ea\")){\n            int x1 = x + move;\n\n            if(x1 >= 12) x1 = 11;\n            else if(y >= 0 && y <= 2){\n                if(x1 >= 3 && x < 3) x1 = 2;\n                else if(x1 >= 5 && (x == 3 || x == 4)) x1 = 4;\n            }\n            else if(y == 3 && x1 >= 5) x1 = 4;\n            else if((y >= 5 && y <= 8) && x1 >= 7 && x < 7) x1 = 6;\n\n            x = x1;\n        }\n        else if(moveCommandString.contains(\"so\")){\n            int y2 = y - move;\n\n            if(y2 < 0) y2 = 0;\n            else if((x >=4 && x <= 6) && y2 < 5 && y >=5) y2 = 5;\n\n            y = y2;\n        }\n        else if(moveCommandString.contains(\"we\")){\n            int x2 = x - move;\n\n            if(x2 < 0) x2 = 0;\n            else if(y >= 0 && y <= 2){\n                if(x2 < 5 && x >= 5) x2 = 5;\n                else if(x2 < 3 && (x == 3 || x == 4)) x2 = 3;\n            }\n            else if(y == 3 && x2 < 5) x2 = 5;\n            else if((y >= 5 && y <= 8) && x2 < 7 && x >= 7) x2 = 7;\n\n            x = x2;\n        }\n\n        return \"(\"+x+\",\"+y+\")\";\n    }\n}\n"}, {"source": "student", "name": "student2", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String moveTo(String moveCommandString);\n}\n"}, {"source": "student", "name": "student20", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.ArrayList;\n\npublic class Exercise0 implements Walkable {\n\n    private  Wall [] wallsvertical = {new Wall(5, 6, 2), new Wall(5, 6, 3), new Wall(5, 6, 4), new Wall(5, 6, 5), new Wall(5, 6, 6), new Wall(5, 6, 7), new Wall(3, 4, 1), new Wall(3, 4, 2)};// Hier werden die Positionen der senkrechten Mauern gespeichert\n\n    private  Wall []wallshorizontal = {new Wall(2,3,3), new Wall(2,3,4), new Wall(2,3,5), new Wall(2,3,6), new Wall(2,3,7), new Wall(2,3,8), new Wall(5,6,1), new Wall(5,6,2), new Wall(5,6,3), new Wall(5,6,4), new Wall(5,6,5) }; // Hier werden die Positionen der waagerechten Mauern gespeichert\n    private int x_koordinate = 5;\n    private int y_koordinate = 3;\n    private int limit = 0;\n    @Override\n    public String walkTo(String walkCommandString) {\n          // So wird die Mauer hinzugef\u00fcgt und zum Vergleich gespeichert\n        String pointOfTheCompas = \"\" + walkCommandString.charAt(1) + walkCommandString.charAt(2);\n        String [] devidedString = walkCommandString.split(\",\");\n        String []numberOfStepsAndSquareBracket  = devidedString[1].split(\"]\");\n        int numberOfSteps = Integer.parseInt(numberOfStepsAndSquareBracket [0]);\n        System.out.println(numberOfSteps);\n        boolean isWallhere = false;\n        String actuallyPosition = \"\";//aktuelle Position der Turtle\n\n        switch(pointOfTheCompas){\n            case \"no\":{\n                limit = y_koordinate + numberOfSteps;\n                int y = 0;\n                for( y = y_koordinate; y <= limit; y++){\n                    for(Wall wall : wallshorizontal){\n                        if(y == wall.befor && x_koordinate == wall.posWall){\n                            isWallhere = true;\n                            break;\n                        }\n                    }\n                    actuallyPosition = \"(\"+ x_koordinate +\",\"+ y + \")\";\n                    y_koordinate = y;\n                    if(isWallhere || y >= 7){\n                        isWallhere = false;\n                        break; //Kommt eine Mauer in die Quere oder bin ich am obersten Rand? Dann bleibe ich stehen\n                    }\n                }\n\n            }\n            break;\n            case \"we\":{\n                limit = (x_koordinate - numberOfSteps);\n                int x = 0;\n                for(x = x_koordinate; x >= limit; x--) {\n                    for (Wall wall : wallsvertical) {\n                        if (x == wall.behind && y_koordinate == wall.posWall) {\n                            isWallhere = true;\n                            break;\n                        }\n                    }\n                    actuallyPosition = \"(\" + x + \",\" + y_koordinate + \")\";\n                    x_koordinate = x;\n                    if (isWallhere || x <= 0) {\n                        isWallhere = false;\n                        break;\n                    }\n                }\n\n            }\n            break;\n            case \"so\":{\n                limit = (y_koordinate - numberOfSteps);\n                int y = 0;\n                for( y = y_koordinate; y >= limit; y--){\n                    for(Wall wall : wallshorizontal){\n                        if(y == wall.behind && x_koordinate == wall.posWall){\n                            isWallhere = true;\n                            break;\n                        }\n                    }\n                    actuallyPosition = \"(\"+ x_koordinate +\",\"+ y + \")\";\n                    y_koordinate = y;\n                    if(isWallhere || y <= 0){\n                        isWallhere = false;\n                        break;\n                    }\n                }\n            }\n            break;\n            case \"ea\":{\n                limit = (x_koordinate + numberOfSteps);\n                int x = 0;\n                for( x = x_koordinate; x <= limit; x++){\n                    for(Wall wall : wallsvertical){\n                        if(x == wall.befor && y_koordinate == wall.posWall){\n                            isWallhere = true;\n                            break;\n                        }\n                    }\n                    actuallyPosition = \"(\"+ x +\",\"+ y_koordinate + \")\";\n                    x_koordinate = x;\n                    if(isWallhere || x >= 11){\n                        isWallhere = false;\n                        break; //Kommt eine Mauer in die Quere oder bin ich am obersten Rand? Dann bleibe ich stehen\n                    }\n                }\n\n            }\n            break;\n            default:\n                throw new IllegalStateException(\"Bitte geben sie eine Himmelsrichtung an\" + pointOfTheCompas);\n        }\n\n\n        return actuallyPosition ;\n    }\n\n}\n"}, {"source": "student", "name": "student20", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "student", "name": "student20", "file_name": "Wall.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Wall {\n    public int befor, behind, posWall = -1;\n    public Wall(int before, int after, int wall){\n        befor = before;\n        behind = after;\n        posWall = wall;\n    }\n}\n"}, {"source": "student", "name": "student21", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n\n    // 9x12 da noch die \u00e4u\u00dferen R\u00e4nder selber Grenzen sind\n    public int[][] room = {\n            {0,0,0,0,0,0,0,0,0,0,0,3},\n            {0,0,0,0,0,0,0,0,0,1,0,3},\n            {0,0,0,0,0,0,0,0,0,1,0,3},\n            {0,0,0,0,0,0,0,0,0,1,0,3},\n            {0,0,0,0,0,0,0,0,0,1,0,3},\n            {0,1,1,1,1,1,1,1,1,1,0,3},\n            {2,2,2,3,0,0,0,0,0,0,0,3},\n            {0,0,0,3,0,0,0,0,0,0,0,3},\n            {3,3,3,3,3,3,3,3,3,3,3,3}\n    };\n    // initial Value serves as starting Position\n    public int[] currPos = {6,1};\n\n    @Override\n    public String move(String moveCommandString) {\n        // no +,0 | ea 0,+ | so -,0 | we 0,-\n        // java arrays[y-axis][x-axis]\n\n        String numb = moveCommandString.substring(moveCommandString.indexOf(\",\")+1,moveCommandString.indexOf(\"]\"));\n        int steps = Integer.parseInt(numb);\n        while(steps!=0){\n            if(moveCommandString.contains(\"no\")){\n                if(currPos[0]+1 <= 8 && currPos[1]+1 <= 11){\n                    if((room[currPos[0]+1][currPos[1]]\n                       != room[currPos[0]+1][currPos[1]+1]\n                       || room[currPos[0]+1][currPos[1]]==0\n                       || room[currPos[0]+1][currPos[1]+1]==0)\n                       && currPos[0]+1 < 8){\n                        this.currPos[0] += 1;\n                    }\n                }\n            }\n            if(moveCommandString.contains(\"so\")){\n                if(currPos[1]+1 <= 11){\n                    if((room[currPos[0]][currPos[1]]\n                       != room[currPos[0]][currPos[1]+1]\n                       || room[currPos[0]][currPos[1]]==0\n                       || room[currPos[0]][currPos[1]+1]==0)\n                       && currPos[0]-1 >= 0){\n                        this.currPos[0] -= 1;\n                    }\n                }\n            }\n            if(moveCommandString.contains(\"ea\")){\n                if(currPos[0]+1 <= 8 && currPos[1]+1 <= 11){\n                    if((room[currPos[0]][currPos[1]+1]\n                       != room[currPos[0]+1][currPos[1]+1]\n                       || room[currPos[0]][currPos[1]+1]==0\n                       || room[currPos[0]+1][currPos[1]+1]==0)\n                       && currPos[1]+1 < 11){\n                        this.currPos[1] += 1;\n                    }\n                }\n            }\n            if(moveCommandString.contains(\"we\")){\n                if(currPos[0]+1 <= 8){\n                    if((room[currPos[0]][currPos[1]]\n                       != room[currPos[0]+1][currPos[1]]\n                       || room[currPos[0]][currPos[1]]==0\n                       || room[currPos[0]+1][currPos[1]]==0)\n                       && currPos[1]-1 >= 0){\n                        this.currPos[1] -= 1;\n                    }\n                }\n            }\n            steps--;\n        }\n        String retPos = \"(\"+currPos[1]+\",\"+currPos[0]+\")\";\n        return retPos;\n    }\n}\n"}, {"source": "student", "name": "student21", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "student", "name": "student23", "file_name": "Border.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Border {\n    Coordinate start;\n    Coordinate end;\n    String axis;\n\n    public Border (Coordinate start, Coordinate end, String axis) {\n        if (start.getX() < end.getX() || start.getY() < end.getY()) {\n            this.start = start;\n            this.end = end;\n        } else {\n            this.start = end;\n            this.end = start;\n        }\n\n        this.axis = axis;\n    }\n\n    @Override\n    public String toString() {\n        return \"Start: \" + start + \" End: \" + end + \" Axis:\" + axis;\n    }\n}\n"}, {"source": "student", "name": "student23", "file_name": "Coordinate.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Coordinate {\n    private int x;\n    private int y;\n\n    public Coordinate (int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public void setX(int x) {\n        this.x = x;\n    }\n\n    public void incrementX (int amount) {\n        this.x += amount;\n    }\n\n    public void decrementX (int amount) {\n        this.x -= amount;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public void setY(int y) {\n        this.y = y;\n    }\n\n    public void incrementY (int amount) {\n        this.y += amount;\n    }\n\n    public void decrementY (int amount) {\n        this.y -= amount;\n    }\n\n\n    @Override\n    public String toString() {\n        return \"(\" + this.x + \",\" + this.y + \")\";\n    }\n}\n"}, {"source": "student", "name": "student23", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.security.InvalidParameterException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Exercise0 implements Moveable {\n\n    private static final boolean enableLogging = true;\n\n    // Configure Defaults\n    private final Coordinate startPosition = new Coordinate(0, 2);\n    private final int gridHeight = 9;\n    private final int gridWidth = 12;\n    private final Border[] borders = {\n            new Border(new Coordinate(3, 0), new Coordinate(3, 3), \"y\"),\n            new Border(new Coordinate(5, 0), new Coordinate(5, 4), \"y\"),\n            new Border(new Coordinate(7, 5), new Coordinate(7, 9), \"y\"),\n            new Border(new Coordinate(4, 5), new Coordinate(7, 5), \"x\")\n    };\n\n    // Robot Position\n    private final Coordinate position;\n\n    public Exercise0() {\n        this.position = startPosition;\n    }\n\n    @Override\n    public String moveTo(String moveCommandString) {\n        Border relevantBorder;\n        String direction = \"\";\n        int amount = 0;\n\n        // use Regex to parse command String to get direction (e.g. 'ea') and movement amount\n        Pattern pattern = Pattern.compile(\"\\\\[(.*)(?:,)(.*)]\");\n        Matcher matcher = pattern.matcher(moveCommandString);\n        while (matcher.find()) {\n            direction = matcher.group(1);\n            amount = Integer.parseInt(matcher.group(2));\n        }\n\n        if (enableLogging) {\n            System.out.println(\"Start Position: (\" + this.position.getX() + \",\" + this.position.getY() + \")\");\n            System.out.println(\"move Command: \" + moveCommandString);\n        }\n\n        switch (direction) {\n            case \"no\": {\n                relevantBorder = this.getFirstRelevantBorder(\"y\");\n                this.position.incrementY(amount);\n                this.clampPositionToBorder(relevantBorder, \"+y\");\n            }\n            break;\n            case \"ea\": {\n                relevantBorder = this.getFirstRelevantBorder(\"x\");\n                this.position.incrementX(amount);\n                this.clampPositionToBorder(relevantBorder, \"+x\");\n            }\n            break;\n            case \"so\": {\n                relevantBorder = this.getFirstRelevantBorder(\"y\");\n                this.position.decrementY(amount);\n                this.clampPositionToBorder(relevantBorder, \"-y\");\n            }\n            break;\n            case \"we\": {\n                relevantBorder = this.getFirstRelevantBorder(\"x\");\n                this.position.decrementX(amount);\n                this.clampPositionToBorder(relevantBorder, \"-x\");\n            }\n            break;\n            default:\n                throw new InvalidParameterException();\n        }\n\n        this.clampPositionToGrid();\n\n        if (enableLogging) {\n            System.out.println(\"End Position: (\" + this.position.getX() + \",\" + this.position.getY() + \")\");\n            System.out.println(\"--------\");\n        }\n\n        return \"(\" + this.position.getX() + \",\" + this.position.getY() + \")\";\n    }\n\n    private void clampPositionToGrid() {\n        if (this.position.getX() > this.gridWidth - 1) this.position.setX(this.gridWidth - 1);\n        if (this.position.getY() > this.gridHeight - 1) this.position.setY(this.gridHeight - 1);\n        if (this.position.getX() < 0) this.position.setX(0);\n        if (this.position.getY() < 0) this.position.setY(0);\n    }\n\n    /**\n     * Clamp the position to respect impenetrable borders\n     *\n     * @param border       the border that has to be respected\n     * @param movementAxis the direction of the movement\n     */\n    private void clampPositionToBorder(Border border, String movementAxis) {\n        if (enableLogging) {\n            System.out.println(\"Position before Clamp: \" + this.position);\n            System.out.println(\"Movement: \" + movementAxis);\n            System.out.println(\"Border: \" + border);\n        }\n\n        if (border != null) {\n            switch (movementAxis) {\n                case \"+x\": {\n                    if (border.start.getX() <= this.position.getX()) this.position.setX(border.start.getX() - 1);\n                    break;\n                }\n                case \"+y\": {\n                    if (border.start.getY() <= this.position.getY()) this.position.setY(border.start.getY() - 1);\n                    break;\n                }\n                case \"-x\": {\n                    if (border.start.getX() >= this.position.getX()) this.position.setX(border.start.getX());\n                    break;\n                }\n                case \"-y\": {\n                    if (border.start.getY() <= this.position.getY()) this.position.setY(border.start.getY());\n                    break;\n                }\n                default:\n                    throw new InvalidParameterException();\n            }\n        }\n\n        if (enableLogging) {\n            System.out.println(\"Position after Border Clamp: \" + this.position);\n        }\n    }\n\n    /**\n     * @return get the nearest Border that is relevant to the next movement\n     */\n    private Border getFirstRelevantBorder(String axis) {\n        Border[] relevantBorders = getRelevantBorders(axis);\n        return relevantBorders.length > 0 ? relevantBorders[0] : null;\n    }\n\n    /**\n     * @return Array with all borders that lie on the given axis and that are reachable by a straight move along the axis\n     */\n    private Border[] getRelevantBorders(String movementAxis) {\n        ArrayList<Border> relevantBorders = new ArrayList<>();\n\n        switch (movementAxis) {\n            case \"x\": {\n                Border[] bordersByAxis = this.getRelevantBordersByAxis(\"y\");\n                for (Border border : bordersByAxis) {\n                    if (border.start.getY() <= this.position.getY() && border.end.getY() >= this.position.getY() + 1)\n                        relevantBorders.add(border);\n                }\n                break;\n            }\n            case \"y\": {\n                Border[] bordersByAxis = this.getRelevantBordersByAxis(\"x\");\n                for (Border border : bordersByAxis) {\n                    if (border.start.getX() <= this.position.getX() && border.end.getX() >= this.position.getX() + 1)\n                        relevantBorders.add(border);\n                }\n                break;\n            }\n            default:\n                throw new InvalidParameterException();\n        }\n\n        return relevantBorders.toArray(Border[]::new);\n    }\n\n    /**\n     * @param axis axis in the grid\n     * @return Array with all Borders that lie on the given axis\n     */\n    private Border[] getRelevantBordersByAxis(String axis) {\n        Border[] relevantBorders = Arrays.stream(this.borders).filter(n -> n.axis.equals(axis)).toArray(Border[]::new);\n\n        switch (axis) {\n            case \"x\": {\n                Arrays.sort(relevantBorders, Comparator.comparingInt(b -> b.start.getY()));\n                break;\n            }\n            case \"y\": {\n                Arrays.sort(relevantBorders, Comparator.comparingInt(b -> b.start.getX()));\n                break;\n            }\n            default:\n                throw new InvalidParameterException();\n        }\n\n        return relevantBorders;\n    }\n}\n"}, {"source": "student", "name": "student23", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String moveTo(String moveCommandString);\n}\n"}, {"source": "student", "name": "student25", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport org.springframework.data.util.Pair;\n\n\nimport javax.persistence.criteria.CriteriaBuilder;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\n\n\npublic class Exercise0 implements GoAble {\n\n    private final int wide = 12;\n    private final int lenght = 8;\n    private boolean first = true;\n    private int currX = 11;\n    private int currY = 7;\n    private ArrayList<Pair<Pair<Integer,Integer>,Pair<Integer,Integer>>> borders = new ArrayList<Pair<Pair<Integer,Integer>,Pair<Integer,Integer>>>();\n    private ArrayList<Pair<Pair<Integer,Integer>,Pair<Integer,Integer>>> allBorders = new ArrayList<Pair<Pair<Integer,Integer>,Pair<Integer,Integer>>>();\n\n\n\n\n\n\n\n    @Override\n    public String goTo(String goCommandString) {\n        if(first){\n            this.first = false;\n            borders.add(Pair.of(Pair.of(6,2),Pair.of(6,5)));\n            borders.add(Pair.of(Pair.of(5,5),Pair.of(6,5)));\n            borders.add(Pair.of(Pair.of(5,5),Pair.of(5,6)));\n            borders.add(Pair.of(Pair.of(5,6),Pair.of(12,6)));\n\n            for(Pair<Pair<Integer,Integer>,Pair<Integer,Integer>> border: borders){\n                Pair<Integer,Integer> tmp1 = border.getFirst();\n                Pair<Integer,Integer> tmp2 = border.getSecond();\n                if(tmp1.getFirst() == tmp2.getFirst()){\n                    for(int i = tmp1.getSecond(); i < tmp2.getSecond(); i++) {\n                        allBorders.add(Pair.of(Pair.of(tmp1.getFirst(),i),Pair.of(tmp2.getFirst(),i+1)));\n                    }\n                }\n                if(tmp1.getSecond() == tmp2.getSecond()){\n                    for(int i = tmp1.getFirst(); i < tmp2.getFirst(); i++){\n                        allBorders.add(Pair.of(Pair.of(i,tmp1.getSecond()),Pair.of(i+1,tmp2.getSecond())));\n                    }\n                }\n\n            }\n            for (Pair<Pair<Integer,Integer>,Pair<Integer,Integer>> border : allBorders) {\n            }\n        }\n        goCommandString = goCommandString.substring(1,goCommandString.length()-1);\n        String[] parts = goCommandString.split(\",\");\n        String direction = parts[0];\n        String steps = parts[1];\n        for(int i = 0; i < Integer.parseInt(steps); i++){\n            int tmpX = this.currX;\n            int tmpY = this.currY;\n            Pair<Pair<Integer,Integer>,Pair<Integer,Integer>> tmpBorder;\n            switch (direction){\n                case \"no\":\n                    if(tmpY+1 == lenght) break;\n                    tmpBorder = Pair.of(Pair.of(currX,currY+1),Pair.of(currX+1,currY+1));\n                    if(!allBorders.contains(tmpBorder)){\n                        currY++;\n                    } break;\n                case \"ea\":\n                    if(tmpX+1 == wide) break;\n                    tmpBorder = Pair.of(Pair.of(currX+1,currY),Pair.of(currX+1,currY+1));\n                    if(!allBorders.contains(tmpBorder)){\n                        currX++;\n                    } break;\n                case \"so\":\n                    if(tmpY-1 == -1) break;\n                    tmpBorder = Pair.of(Pair.of(currX,currY),Pair.of(currX+1,currY));\n                    if(!allBorders.contains(tmpBorder)){\n                        currY--;\n                    } break;\n                case \"we\":\n                    if(tmpX-1 == -1) break;\n                    tmpBorder = Pair.of(Pair.of(currX,currY),Pair.of(currX,currY+1));\n                    if(!allBorders.contains(tmpBorder)){\n                        currX--;\n                    } break;\n            }\n        }\n        return \"(\"+currX+\",\"+currY+\")\";\n    }\n}\n"}, {"source": "student", "name": "student25", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "student", "name": "student26", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n\n    private int x = 5;\n    private int y = 3;\n\n\n    @Override\n    public String walk(String walkCommandString) {\n\n        int input_x = 0;\n        int input_y = 0;\n\n        //String entwirren\n\n        int i = Integer.parseInt(walkCommandString.substring(4, walkCommandString.length()).replace(']', ' ').trim());\n        switch(walkCommandString.substring(1,3)) {\n            case \"no\": input_y = i;break;\n            case \"ea\": input_x = i;break;\n            case \"so\": input_y = i *-1;break;\n            case \"we\": input_x = i *-1;break;\n        }\n\n\n        /*Horizontal Waende\n        1-5 / 6\n        1-5 / 5\n        -----------\n        3-8 / 2\n        3-8 / 3\n        -----------\n        min x / 0\n        max x / 7\n        */\n\n        int temp_x = x + input_x;\n        int temp_y = y + input_y;\n\n        if (input_x == 0){\n            if(y <= 2 && temp_y >= 3 && temp_x >= 3 && temp_x <= 8){\n                temp_y = 2;\n            }\n            else if(y >= 3 && temp_y <= 2 && temp_x >= 3 && temp_x <= 8){\n                temp_y = 3;\n            }\n\n\n            else if(y <= 5 && temp_y >= 6 && temp_x >= 1 && temp_x <= 5){\n                temp_y = 5;\n            }\n            else if(y >= 6 && temp_y <= 5 && temp_x >= 1 && temp_x <= 5){\n                temp_y = 6;\n            }\n\n\n            else if (temp_y > 7){\n                temp_y = 7;\n            }\n            else if (temp_y < 0){\n                temp_y = 0;\n            }\n            y = temp_y;\n        }\n\n\n        /*Vertical Waende\n        3 / 1-2\n        4 / 1-2\n        -----------\n        5 / 2-7\n        6 / 2-7\n        -----------\n        min 0 / x\n        max 11 / x\n        */\n\n        else if (input_y == 0){\n            if(y <= 2 && temp_y >= 1 && x <= 3 && temp_x >= 4){\n                temp_x = 3;\n            }\n            else if(y <= 2 && temp_y >= 1 && x >= 4 && temp_x <= 3){\n                temp_x = 4;\n            }\n\n\n\n            else if(temp_y <= 7 && temp_y >= 2 && x <= 5 && temp_x >= 6) {\n                temp_x = 5;\n            }\n            else if(temp_y <= 7 && temp_y >= 2 && x >= 6 && temp_x <= 5){\n                temp_x = 6;\n            }\n\n            else if (temp_x > 11){\n                temp_x = 11;\n            }\n            else if (temp_x < 0){\n                temp_x = 0;\n            }\n            x = temp_x;\n        }\n        return (\"(\" +temp_x + \",\" + temp_y + \")\");\n\n    }\n}\n"}, {"source": "student", "name": "student26", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walk(String walkCommandString);\n}\n"}, {"source": "student", "name": "student27", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport javax.validation.constraints.NotNull;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Exercise0 implements Walkable {\n\n    private int x = 11;\n    private int y = 7;\n\n    //private ArrayList<String> firstBlockade;\n    private List<String> firstBlockade = Arrays.asList(\"(6,2)\", \"(6,3)\", \"(6,4)\", \"(6,5)\");\n    private List<String> secondBlockade = Arrays.asList(\"(6,5)\",\"(5,5)\" );\n    private List<String> thirdBlockade = Arrays.asList(\"(4,5)\",\"(5,5)\");\n    private List<String> fourthBlockade = Arrays.asList(\"(6,6)\", \"(7,6)\", \"(8,6)\", \"(9,6)\", \"(10,6)\",\"(11,6)\",\"(12,6)\");\n\n\n    @Override\n    public String walkTo(String walkCommandString) {\n        //throw new UnsupportedOperationException();\n        StringBuilder numberOfSteps = new StringBuilder();\n        String resultString = \"(\"+ x + \",\" + y + \")\";\n\n\n\n        //checks if the string-parameter contains a correct direction\n        if(walkCommandString.contains(\"no\") || walkCommandString.contains(\"ea\") || walkCommandString.contains(\"so\")\n                || walkCommandString.contains(\"we\")){\n\n\n\n            //reads the digits in the String and converts it to an int\n            for(char s : walkCommandString.toCharArray()){\n                if(Character.isDigit(s))\n                    numberOfSteps.append(s);\n\n            }\n            String stringSteps = numberOfSteps.toString();\n            int intSteps = Integer.parseInt(stringSteps);\n\n\n            if(walkCommandString.contains(\"no\")){\n                if(intSteps == 0){return resultString;}\n\n                if(intSteps == 1){\n                    y++;\n                    resultString = \"(\" + x + \",\" + y + \")\";\n                    if(!secondBlockade.contains(resultString) && !fourthBlockade.contains(resultString)){\n                        return resultString;\n                    }else{\n                        resultString = \"(\" + x + \",\" + y + \")\";\n                        return resultString;\n                    }\n                }\n\n                y++;\n                resultString = \"(\" + x + \",\" + y + \")\";\n                for(int i=0; i<intSteps; i++){\n                    if(!secondBlockade.contains(resultString) && !fourthBlockade.contains(resultString)){\n                        y++;\n                        resultString = \"(\" + x + \",\" + y + \")\";\n                    } else {\n                        resultString = \"(\" + x + \",\" + y + \")\";\n                        break;\n                    }\n                }\n\n                if(y > 7){\n                    y=7;\n                    resultString = \"(\" + x + \",\" + y + \")\";\n                }\n\n            } else if (walkCommandString.contains(\"so\")){\n\n                for(int i=0; i<intSteps; i++){\n                    if(!secondBlockade.contains(resultString) && !fourthBlockade.contains(resultString)){\n                        y--;\n                        resultString = \"(\" + x + \",\" + y + \")\";\n                    } else {\n                        resultString = \"(\" + x + \",\" + y + \")\";\n                        break;\n                    }\n                }\n\n                if(y<0){\n                    y=0;\n                    resultString = \"(\" + x + \",\" + y + \")\";\n                }\n\n\n            } else if (walkCommandString.contains(\"ea\")){\n                if(intSteps ==0){return resultString;}\n\n                if(intSteps == 1){\n                    x++;\n                    resultString = \"(\" + x + \",\" + y + \")\";\n                    if(!firstBlockade.contains(resultString) && !thirdBlockade.contains(resultString)){\n                        x--;\n                        resultString = \"(\" + x + \",\" + y + \")\";\n                        return resultString;\n                    }else{\n\n                        return resultString;\n                    }\n                }\n\n                x++;\n                resultString = \"(\" + x + \",\" + y + \")\";\n                for(int i=0; i<intSteps-1; i++){\n                    if(!firstBlockade.contains(resultString) && !thirdBlockade.contains(resultString)){\n                        x++;\n                        resultString = \"(\" + x + \",\" + y + \")\";\n                    } else {\n                        x--;\n                        resultString = \"(\" + x + \",\" + y + \")\";\n                        break;//\n                    }\n                }\n\n\n                if(x > 11){\n                    x=11;\n                    resultString = \"(\" + x + \",\" + y + \")\";\n                }\n\n            } else if(walkCommandString.contains(\"we\")){\n                /*x-=intSteps;*/\n                for(int i=0; i<intSteps; i++){\n                    if(!firstBlockade.contains(resultString) && !thirdBlockade.contains(resultString)){\n                        x--;\n                        resultString = \"(\" + x + \",\" + y + \")\";\n                    } else{\n                        resultString = \"(\" + x + \",\" + y + \")\";\n                        break;}\n                }\n\n                if(x<0){\n                    x=0;\n                    resultString = \"(\" + x + \",\" + y + \")\";\n                }\n            }\n\n\n        }\n        //resultString = \"(\" + x + \",\" + y + \")\";\n\n        return resultString;\n    }\n}"}, {"source": "student", "name": "student27", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "student", "name": "student28", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\n//public class Exercise0 implements Walkable {\n\n//    @Override\n//    public String walk(String walkCommandString) {\n//        throw new UnsupportedOperationException();\n//    }\n//}\n \npublic class Exercise0 implements Walkable {\n\t\n    int xPos = 0;\n    int yPos = 2;\n    \n    int[] left = {0,0,0,9}; //x1,y1,x2,y2\n    int[] right = {12,0,12,9};\n    int[] up = {0,9,12,9};\n    int[] down = {0,0,12,0};\n    int[] wall1 = {3,0,3,3};\n    int[] wall2 = {5,0,5,4};\n    int[] wall3 = {4,5,7,5}; \n    int[] wall4 = {7,5,7,9};\n    \n    int[][] walls = {left,right,up,down,wall1,wall2,wall3,wall4};\n\n\n    @Override\n    public String walk(String walkCommandString) {\t\t\t // \"[so,2]\"\n    \t\n    \t walkCommandString = walkCommandString.substring(1); // \"so,2]\"\n         String[] temp = walkCommandString.split(\",\");       // \"so\" & \"2]\"\n         String direction = temp[0];                         // \"so\"\n         temp = temp[1].split(\"]\");                          // \"2\" & \"\"\n         int stepCount = Integer.parseInt(temp[0]);          //  2\n\n         for(int i = 0; i <= stepCount; i++){\n        \t \n             if(direction == \"we\"){\n                 for(int[] each : walls) {\n                \t if( (each[0] == each[2] ) && (each[0] == xPos) && (Math.abs(yPos-(each[1]+each[3])/2) <= (Math.abs(each[1]-(each[1]+each[3])/2)))) {  \n                \t\t return \"(\" + xPos + \",\" + yPos + \")\";\n                \t }\n                \t else { xPos--;}\n                 }\n             }\n             \n             if(direction == \"ea\"){\n                 for(int[] each : walls) {\n                \t if( (each[0] == each[2] ) && (each[0] == xPos + 1) && (Math.abs(yPos-(each[1]+each[3])/2) <= (Math.abs(each[1]-(each[1]+each[3])/2)))) {\n                \t\t return \"(\" + xPos + \",\" + yPos + \")\";\n                \t }\n                \t else { xPos-++;}\n                 }\n             }\n             \n             if(direction == \"no\"){\n                 for(int[] each : walls) {\n                \t if( (each[1] == each[3] ) && (each[1] == yPos + 1) && (Math.abs(xPos-(each[0]+each[2])/2) <= (Math.abs(each[0]-(each[0]+each[2])/2)))) {\n                \t\t return \"(\" + xPos + \",\" + yPos + \")\";\n                \t }\n                \t else { yPos++;}\n                 }\n             }\n             \n             if(direction == \"so\"){\n                 for(int[] each : walls) {\n                \t if( (each[1] == each[3] ) && (each[1] == yPos) && (Math.abs(xPos-(each[0]+each[2])/2) <= (Math.abs(each[0]-(each[0]+each[2])/2)))) {\n                \t\t return \"(\" + xPos + \",\" + yPos + \")\";\n                \t }\n                \t else { yPos--;}\n                 }\n             }\n         }\n         return \"(\" + xPos + \",\" + yPos + \")\";\n    }\n}\n"}, {"source": "student", "name": "student28", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walk(String walkCommandString);\n}\n"}, {"source": "student", "name": "student3", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\n\npublic class Exercise0 implements Walkable {\n\n    /*\n    x= 8  => 0..7\n    y= 11 => 0..10\n     */\n    private int  achseX = 9;\n\n    private int achseY = 12;\n\n    private int achseXminus1 = achseX-1;\n    private int achseYminus1 = achseY-1;\n\n    private int feld[][] = new int[achseY][achseX];\n\n    //aktuelle Positions des Roboters\n    private int position[] = {7,7};\n\n\n    @Override\n    public String walk(String moveCommandString) {\n\n        felden();\n\n        //Extrahieren der Richtung\n        // String richtung = (moveCommandString.substring(1, 3));\n        String richtung = (moveCommandString.substring((moveCommandString.indexOf('[') + 1), (moveCommandString.indexOf(','))));\n        // Extrahieren der Bewegungseinheiten\n        // bewegungseinheiten = Integer.parseInt(moveCommandString.substring(4, 5));\n        int  bewegungseinheiten = Integer.parseInt(moveCommandString.substring((moveCommandString.indexOf(',') + 1), (moveCommandString.indexOf(']'))));\n\n\n        //Kontrollkram, sp\u00e4ter weg\n        System.out.println();\n        System.out.println();\n        System.out.println(\"Position  Zeile: \" + position[0]);\n        System.out.println(\"Position  Spalte: \" + position[1]);\n        System.out.println(\"Position Richtung: \" + richtung);\n        System.out.println(\"Position Bewegungseinheiten: \" + bewegungseinheiten);\n\n\n        switch (richtung){\n\n\n            case \"no\": {\n\n                /*\n                bewegen nach norden\n\n                -------\n                1.1 pr\u00fcfen, ob ich bereits oben bin\n                1.2 bewegung ist inhalt von position[1] um eine zeile erh\u00f6ht\n                vergleich das mit dem grid, ob da mauer ist\n                wenn ja nicht bewegen\n                wenn nein bewegen\n                ------\n\n                 */\n\n                do{\n\n                    //check ob in oberster Zeile also position[1] == 7\n                    //statt break auch einfach ien return machen, geht auch\n                    if (position[1] == 7) break;\n\n                    //System.out.println(\"Wert position0: \"+position[0]+\" Wert postion1 +1:  \"+(position[1]+1));\n\n                    int temp_feldwert = feld[position[0]][(position[1]+1)];\n\n                    //System.out.println(\"Wert temp_feld: \"+temp_feldwert);\n\n\n                    int posplus2=position[1]+2;\n                    if(posplus2>=7) posplus2=7;\n                    int temp_feldwert2 = feld[position[0]][posplus2];\n\n                    //System.out.println(\"Wert temp_feld2: \"+temp_feldwert2);\n\n                    int posplus3=position[1]+1;\n                    if(posplus3>=7) posplus3=7;\n                    int temp_feldwert3 = feld[position[0]+1][posplus3];\n\n                    //System.out.println(\"Wert temp_feld3: \"+temp_feldwert3);\n\n                    if(temp_feldwert==0 ||((temp_feldwert==1 && temp_feldwert2==1)&&(temp_feldwert3==0))){\n                        position[1]=position[1]+1;\n                    }else break;\n\n\n                    bewegungseinheiten--;\n                } while(bewegungseinheiten>0);\n\n            }break;\n\n\n            //--------------------------------------------------------------------------------\n            //--------------------------------------------------------------------------------\n            //--------------------------------------------------------------------------------\n            //--------------------------------------------------------------------------------\n\n\n            case \"ea\":{\n\n                do{\n\n                    //statt break auch einfach ien return machen, geht auch\n                    if (position[0] == 10) break;\n\n                    //System.out.println(\"Wert position0 +1:   \"+(position[0]+1)+\" Wert postion1: \"+(position[1]));\n\n                    int temp_feldwert = feld[position[0]+1][(position[1])];\n\n                    //System.out.println(\"Wert temp_feld: \"+temp_feldwert);\n\n                    int posplus2=position[0]+2;\n                    if(posplus2>=10) posplus2=10;\n                    int temp_feldwert2 = feld[posplus2][(position[1])];\n\n                    //System.out.println(\"Wert temp_feld2: \"+temp_feldwert2);\n\n                    int posplus3=position[0]+1;\n                    if(posplus3>=10) posplus3=10;\n                    int temp_feldwert3 = feld[posplus3][position[1]+1];\n\n                    //System.out.println(\"Wert temp_feld3: \"+temp_feldwert3);\n\n                    if(temp_feldwert==0 || (temp_feldwert==1 && temp_feldwert2==1 && temp_feldwert3==0) ){\n                        position[0]=position[0]+1;\n                    }else break;\n\n\n                    bewegungseinheiten--;\n                } while(bewegungseinheiten>0);\n\n\n\n            }break;\n\n            //--------------------------------------------------------------------------------\n            //--------------------------------------------------------------------------------\n            //--------------------------------------------------------------------------------\n            //--------------------------------------------------------------------------------\n\n\n            case \"we\":{\n\n                do{\n\n                    //statt break auch einfach ien return machen, geht auch\n                    if (position[0] == 0) break;\n\n                      //System.out.println(\"Wert position0 -1:   \"+(position[0]-1)+\" Wert postion1: \"+(position[1]));\n\n                    int temp_feldwert = feld[position[0]-1][(position[1])];\n\n                    //System.out.println(\"Wert temp_feld: \"+temp_feldwert);\n\n\n                    int posplus2=position[0]-2;\n                    if(posplus2<=0) posplus2=0;\n                    int temp_feldwert2 = feld[posplus2][(position[1])];\n\n                    //System.out.println(\"Wert temp_feld2: \"+temp_feldwert2);\n\n                    int posplus3=position[1]-1;\n                    if(posplus3<=0) posplus3=0;\n                    int temp_feldwert3 = feld[position[0]-1][posplus3];\n\n                    //System.out.println(\"Wert temp_feld3: \"+temp_feldwert3);\n\n\n                    boolean temp1 =temp_feldwert==0;\n                    boolean temp2 =(temp_feldwert==1 && temp_feldwert2==1);\n                    boolean temp3 =temp_feldwert2==0;\n                    boolean temp4=(temp_feldwert==1&&temp_feldwert3==1);\n                    boolean temp6=(feld[position[0]][position[1]] == 1);\n                    boolean temp5=(temp1 && temp3 && temp6);\n\n                    if((temp1 || temp2) || temp4 || temp3){\n                        if(temp3 && temp4 ) {\n                            position[0]=position[0]-1;\n                            break;\n                        }else if (temp5) break;\n\n                        position[0]=position[0]-1;\n                    }else break;\n\n                    bewegungseinheiten--;\n                } while(bewegungseinheiten>0);\n\n            }break;\n\n\n            //--------------------------------------------------------------------------------\n            //--------------------------------------------------------------------------------\n            //--------------------------------------------------------------------------------\n            //--------------------------------------------------------------------------------\n\n\n\n            case \"so\":{\n\n                do{\n\n                    if (position[1] == 0) break;\n\n                             System.out.println(\"Wert position0: \"+position[0]+\" Wert postion1 -1:  \"+(position[1]-1));\n\n                    int temp_feldwert = feld[position[0]][(position[1]-1)];\n\n                    //System.out.println(\"Wert temp_feld: \"+temp_feldwert);\n\n                    int posplus2=position[1]-2;\n                    if(posplus2<=0) posplus2=0;\n                    int temp_feldwert2 = feld[position[0]][posplus2];\n\n                    //System.out.println(\"Wert temp_feld2: \"+temp_feldwert2);\n\n                    int posplus3=position[0]-1;\n                    if(posplus3<=0) posplus3=0;\n                    int temp_feldwert3 = feld[posplus3][position[1]-1];\n\n                    //System.out.println(\"Wert temp_feld3: \"+temp_feldwert3);\n\n                    int posplus4=position[1];\n                    if(posplus4<=0) posplus4=0;\n                    int temp_feldwert4 = feld[position[0]][posplus4];\n\n\n                    //System.out.println(\"Wert temp_feld4: \"+temp_feldwert4);\n\n\n                    boolean temp1 =temp_feldwert==0;\n                    boolean temp2 =(temp_feldwert==1 && temp_feldwert2==1);\n                    boolean temp3 =temp_feldwert2==0;\n                    boolean temp4=(temp_feldwert==1&&temp_feldwert3==1);\n                    boolean temp5=(temp1 && temp3 && temp_feldwert3 == 0 && temp_feldwert4==1);\n\n                    if((temp1 || temp2) || temp4 || temp3){\n                        if(temp3 && temp4) {\n                            position[1]=position[1]-1;\n                            break;\n                        }else if(temp5)\n                            break;\n\n\n\n                        position[1]=position[1]-1;\n                    }else break;\n\n                    /*if(temp_feldwert==0){\n                        position[1]=position[1]-1;\n                    }else break;\n\n                     */\n                    bewegungseinheiten--;\n                } while(bewegungseinheiten>0);\n\n            }break;\n\n\n            default:{\n                System.out.println(\"Keine richtige Richtung zum richten, \\ndamit ist das Richten der Richtung nicht m\u00f6glich\");\n            }break;\n\n        }\n        return (\"(\"+position[0]+\",\"+position[1]+\")\");\n    }\n\n\n\n    public void felden(){\n\n        for (int x = 0; x < achseY; x++) {\n            for (int y = 0; y < achseX; y++) {\n                feld[x][y]=0;\n\n                //Wand Zeilen nur Norden S\u00fcden abfragen als Horizontal\n                //  wand1 = \"(2,6)-(6,6)\";\n                // wand2 = \"(2,1)-(9,1)\";\n\n                //Wand Spalten Nur Osten Westen abfragen also Vertikal\n                // wand3 = \"(2,1)-(2,5)\";\n                //  wand4 = \"(10,1)-(10,7)\";\n\n                //Wand1\n                if((y==6)&&((x>=2)&&(x<=6))) feld[x][y]=1;\n                //Wande2\n                if((y==1)&&((x>=2)&&(x<=9))) feld[x][y]=1;\n\n\n                //Wand3\n                if((x==2)&&((y>=1)&&(y<=5))) feld[x][y]=1;\n                //Wand4\n                if((x==10)&&((y>=1)&&(y<=7))) feld[x][y]=1;\n            }\n        }\n    }\n}"}, {"source": "student", "name": "student3", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walk(String walkCommandString);\n}\n"}, {"source": "student", "name": "student30", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class Exercise0 implements GoAble {\n\n\n    static int [][] spaceship = new int[12][9];\n    int startx = 7;\n    int starty = 7;\n\n   public static void startpunktmarkieren(){\n       spaceship[7][7] = 2;\n\n\n\n   }\n\n\n    public static void waendebauen(){\n        //wand 1\n        for(int x = 1; x < 8; x++){\n                    spaceship[10][x] = 1;\n        }\n\n        //wand2\n         for(int x = 2; x <=8; x++){\n                    spaceship[x][1] = 3;\n        }\n\n        //wand3\n         for(int x = 1; x <=6; x++){\n                    spaceship[2][x] = 1;\n        }\n        //wand4\n         for(int x = 2; x <=7; x++){\n                    spaceship[x][6] = 3;\n        }\n         //rand\n        for(int x = 0; x < 12; x++){\n            spaceship[x][0] = 5;\n        }\n        for(int x = 0; x < 12; x++){\n            spaceship[x][8] = 4;\n        }\n        for(int x = 0; x < 9; x++){\n            spaceship[11][x] = 4;\n        }\n        for(int x = 0; x < 9; x++){\n            spaceship[0][x] = 4;\n        }\n\n\n    }\n\n\n\n\n    @Override\n    public String go(String goCommandString) {\n\n       waendebauen();\n       char zs = goCommandString.charAt(4);\n       int zahl = Integer.parseInt(String.valueOf(zs));\n\n       String richtung=\"\"+goCommandString.toCharArray()[1]+goCommandString.toCharArray()[2]+\"\";\n\n\n       if(richtung.equals(\"no\")){\n           for (int i = 1; i <= zahl; i++) {\n               if (starty < 7  && spaceship[startx][starty+1] != 3) {\n                   starty ++;\n               }\n           }\n       }\n        if (richtung.equals(\"so\")) {\n            for (int i = 1; i <= zahl; i++) {\n                if(starty >= 1  && startx < spaceship.length - 1 && spaceship[startx+1][starty] != 3 || starty >= 1  && spaceship[startx][starty] != 3 ) {\n                        starty--;\n                    }\n                }\n        }\n            if (richtung.equals(\"ea\")) {\n                for(int i = 1; i <= zahl; i++ ) {\n                if ( startx <= spaceship.length && startx >= 0 && starty <= spaceship[0].length && spaceship[startx][starty] != 1\n                        && spaceship[startx+1][starty] != 4 && spaceship[startx+1][starty] != 1) {\n                    startx ++;\n                }\n            }\n        }\n        if(richtung.equals(\"we\")) {\n            for (int i = 1; i <= zahl; i++) {\n                if (spaceship[startx][starty] != 4 && spaceship[startx][starty] != 1 && startx < spaceship.length) {\n                    startx --;\n                }\n            }\n        }\n       String endposition = \"(\"+ String.valueOf(startx)+\",\" + String.valueOf(starty)+ \")\";\n\n        System.out.println(richtung);\n        System.out.println(endposition);\n\n\n        return endposition;\n    }\n\n    public static void main (String[] args) {\n\n        System.out.println(spaceship.length);\n        waendebauen();\n        startpunktmarkieren();\n        for ( int zeile = 0; zeile < spaceship.length; zeile++ )\n        {\n            System.out.print(\"Zeile \" + zeile + \": \");\n            for ( int spalte=0; spalte < spaceship[zeile].length; spalte++ )\n                System.out.print( spaceship[zeile][spalte] + \" \");\n            System.out.println();\n        }\n\n\n    }\n\n\n\n}\n\n\n\n"}, {"source": "student", "name": "student30", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String go(String goCommandString);\n\n}\n"}, {"source": "student", "name": "student32", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n    private int xPos = 3;\n    private int yPos = 0;\n    final private Integer[][] hBorders = {{0,0,11},{3,4,7},{4,1,8},{7,0,11}};\n    final private Integer[][] vBorders = {{0,0,7},{3,0,3},{7,0,2},{11,0,7}};\n\n\n\n\n    @Override\n    public String go(String goCommandString) {\n        String[] commands = goCommandString.substring(1, goCommandString.length()-1).split(\",\");\n        String direction = commands[0];\n        int steps = Integer.parseInt(commands[1]);\n\n        switch (direction){\n            case \"no\":\n                for (int i = 0; i < steps; i++) {\n                    if(!moveNorth()) break;\n                    System.out.println(\"(\"+xPos+\",\"+yPos+\")\u2b06\");\n                }\n                break;\n            case \"ea\":\n                for (int i = 0; i < steps; i++) {\n                    if(!moveEast()) break;\n                    System.out.println(\"(\"+xPos+\",\"+yPos+\")\u27a1\");\n                }\n                break;\n            case \"so\":\n                for (int i = 0; i < steps; i++) {\n                    if(!moveSouth()) break;\n                    System.out.println(\"(\"+xPos+\",\"+yPos+\")\u2b07\");\n                }\n                break;\n            case \"we\":\n                for (int i = 0; i < steps; i++) {\n                    if(!moveWest()) break;\n                    System.out.println(\"(\"+xPos+\",\"+yPos+\")\u2b05\");\n                }\n                break;\n            default: return null;\n        }\n\n        return \"(\"+xPos+\",\"+yPos+\")\";\n    }\n\n    private boolean moveNorth(){\n        for (Integer[] hBorder : hBorders) {\n            if (yPos + 1 == hBorder[0]) {\n                if (hBorder[1] <= xPos && hBorder[2] >= xPos) {\n                    return false;\n                }\n            }\n        }\n        yPos++;\n        return true;\n    }\n\n    private boolean moveSouth(){\n        for (Integer[] hBorder : hBorders) {\n            if (yPos == hBorder[0]) {\n                if (hBorder[1] <= xPos && hBorder[2] >= xPos + 1) {\n                    return false;\n                }\n            }\n        }\n        yPos--;\n        return true;\n    }\n\n    private boolean moveEast(){\n        for (Integer[] vBorder : vBorders) {\n            if (xPos + 1 == vBorder[0]) {\n                if (vBorder[1] <= yPos && vBorder[2] >= yPos + 1) {\n                    return false;\n                }\n            }\n        }\n        xPos++;\n        return true;\n    }\n\n    private boolean moveWest(){\n        for (Integer[] vBorder : vBorders) {\n            if (xPos == vBorder[0]) {\n                if (vBorder[1] <= yPos && vBorder[2] >= yPos + 1) {\n                    return false;\n                }\n            }\n        }\n        xPos--;\n        return true;\n    }\n}\n"}, {"source": "student", "name": "student32", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String go(String goCommandString);\n}\n"}, {"source": "student", "name": "student33", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n    int x = 4;\n    int y = 0;\n    String initialPosition = \"(4,0)\";\n\n\n\n    @Override\n    public String moveTo(String moveCommandString) {\n        String movement = moveCommandString.substring(1,moveCommandString.length()-1);\n        String[] moving = movement.split(\",\");\n        String directionMove = moving[0];  testetsetsragdsagdsgdgaesttest,M;\n        int stepToMove= Integer.parseInt(moving[1]);\n\n        switch (directionMove){\n            case \"no\":\n                if(x==0 || x==4 || x>= 7) {\n                    if((y+stepToMove)>7){\n                        y = 7;\n                    }\n\n                    else y+=stepToMove;\n                }\n\n                if(x >=1 && x <= 3 || x>= 5 && x<=6 || y>=0 && y<=5){\n                    if((y+stepToMove)>5){\n                        y=5;\n                    }\n\n                    else y+=stepToMove;\n                }\n\n                if((y==6|| y==7) && x>=1 && x<=3 && (x==5|| x==6)){\n                    if((y+stepToMove) >7){\n                        y = 7;\n                    }\n\n                    else y+=stepToMove;\n                }\n                System.out.println(\"x=\" +x+ \"y=\" +y);\n                break;\n\n            case \"so\":\n                if(x==0 || x==4 || x >= 7 && x<=10) {\n                    if((y-stepToMove)<0){\n                        y = 0;\n                    }\n\n                    else y-=stepToMove;\n                }\n\n                if(x >=1 && x <= 3 || x>= 5 && x<=6 || y>=0 && y<=5){\n                    if((y-stepToMove)<0){\n                        y= 0;\n                    }\n\n                    else y-=stepToMove;\n                }\n\n                if((y==6|| y==7) && x>=1 && x<=3 || (x==5|| x==6)){\n                    if((y-stepToMove) <6){\n                        y = 6;\n                    }\n\n                    else y-=stepToMove;\n                }\n                System.out.println(\"x=\" +x+ \"y=\" +y);\n                break;\n            case \"ea\":\n                if(y>=0 && y<=5 && x == 0) {\n                    x = 0;\n                }\n\n                if((y==6 || y==7) && x>=0 && x<= 10){\n                    if((x+stepToMove) > 10){\n                        x= 10;\n                    }\n\n                    else x+= stepToMove;\n                }\n\n                if(x>=7 && x<=10 && y>= 1 && y<= 5){\n                    if((x+stepToMove) > 10){\n                        x = 10;\n                    }\n\n                    else x+= stepToMove;\n                }\n\n                if(y== 0 && x >= 1 && x<=10){\n                    if((x+stepToMove) > 10){\n                        x = 10;\n                    }\n\n                    else x+= stepToMove;\n                }\n\n                if(y>=1 && y <= 5 && x >= 1 && x <= 6){\n                    if((x+stepToMove) > 6){\n                        x = 6;\n                    }\n\n                    else x+= stepToMove;\n                }\n                System.out.println(\"x=\" +x+ \"y=\" +y);\n                break;\n            case \"we\":\n                if(y>=0 && y<=5 && x== 0) {\n                    x = 0;\n                }\n\n                if((y==6 || y==7) && x>=0 && x<= 10){\n                    if((x-stepToMove) < 0){\n                        x= 0;\n                    }\n\n                    else x-= stepToMove;\n                }\n\n                if(x>=7 && x<=10 && y>= 1 && y<= 5){\n                    if((x-stepToMove) < 7){\n                        x = 7;\n                    }\n\n                    else x-= stepToMove;\n                }\n\n                if(y== 0 && x >= 1 && x<=10){\n                if((x-stepToMove) < 1){\n                    x = 1;\n                }\n\n                else x-= stepToMove;\n            }\n\n            if(y>=1 && y <= 5 && x >= 1 && x <= 6){\n                if((x-stepToMove) < 1){\n                    x = 1;\n                }\n\n                else x-= stepToMove;\n            }\n            System.out.println(\"x=\" +x+ \"y=\" +y);\n            break;\n\n        }\n        return \"(\" + this.x +\",\"+ this.y +\")\";\n    }\n}\n"}, {"source": "student", "name": "student33", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String moveTo(String moveCommandString);\n}\n"}, {"source": "student", "name": "student34", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport lombok.AllArgsConstructor;\nimport org.springframework.stereotype.Component;\nimport thkoeln.st.st2praktikum.droid.MaintenanceDroid;\nimport thkoeln.st.st2praktikum.map.LinearSystem;\nimport thkoeln.st.st2praktikum.map.Map;\nimport thkoeln.st.st2praktikum.parser.MovementSerializer;\nimport thkoeln.st.st2praktikum.parser.Parser;\n\n@Component\n@AllArgsConstructor\npublic class Exercise0 implements Moveable {\n\n    private final Map map;\n    private final MaintenanceDroid droid;\n    private final MovementSerializer serializer;\n\n    public Exercise0() {\n        this.map = Map.defaultMap();\n        this.droid = new MaintenanceDroid(map, MaintenanceDroid.defaultPosition(), new LinearSystem());\n        serializer = new MovementSerializer();\n    }\n\n    @Override\n    public String move(String moveCommandString) {\n        var movement = Parser.getInstance().parse(moveCommandString);\n        this.droid.move(movement);\n        return serializer.serialize(this.droid.getPosition());\n    }\n}\n"}, {"source": "student", "name": "student34", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "student", "name": "student36", "file_name": "Direction.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic enum Direction {\n    NORTH,\n    EAST,\n    SOUTH,\n    WEST;\n}\n"}, {"source": "student", "name": "student36", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.Arrays;\n\npublic class Exercise0 implements Walkable {\n    /*\n    Maschine konstruieren\n    Startposition angeben\n    Feld angeben\n    W\u00e4nde bestimmen\n     */\n\n    private MiningMachine miningMachine = new MiningMachine(4,0, new MiningField(11,8, Arrays.asList(\n            new Walls(1,6,4,6),\n            new Walls(5,6,7,6),\n            new Walls(1,0,1,6),\n            new Walls(7,2,7,6)\n    )));\n    @Override\n    public String walkTo(String walkCommandString) {\n        return miningMachine.moveMiningMachine(walkCommandString);\n    }\n\n\n}\n"}, {"source": "student", "name": "student36", "file_name": "MiningField.java", "code": "package thkoeln.st.st2praktikum.exercise;\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.List;\n\n@Getter\n@Setter\n@AllArgsConstructor\n\npublic class MiningField {\n    private Integer x_size;\n    private Integer y_size;\n    private List<Walls> walls;\n}\n"}, {"source": "student", "name": "student36", "file_name": "MiningMachine.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.springframework.data.util.Pair;\n\n\n@Getter\n@Setter\n@AllArgsConstructor\n\npublic class MiningMachine {\n    private Integer miningPosX;\n    private Integer miningPosY;\n    private MiningField myMiningField;\n\n    // #################################################################################################################\n    // ################################################### Bewegung  ###################################################\n    // #################################################################################################################\n    public String moveMiningMachine(String command) {\n        Pair<Direction,Integer> move = analyse(command);\n        Integer newPosition;\n\n        // ################################################### Norden  #################################################\n        if (move.getFirst() == Direction.NORTH) {\n            // 1) Eine vorl\u00e4ufige Postion wird gesetzt (Entweder Ende des Feldes oder die miningPosY zuz\u00fcglich der Bewegung\n            newPosition = Math.min(miningPosY + move.getSecond(), myMiningField.getY_size() - 1);\n\n            /*\n            2) Alle W\u00e4nde checken:\n            Wenn eine horizontale Wand und Wand im Norden und auf gleicher X-Koordinate wie die Maschine\n            und die vorl\u00e4ufige Postion ist weiter weg, dann wird eine neue Position gesetzt\n            (Y-Koordinate, da Norden)\n            */\n\n            for (Walls walls : myMiningField.getWalls()) {\n                if (walls.getFirstY() == walls.getLastY() && walls.getFirstY() > miningPosY && walls.getFirstX() <= miningPosX && walls.getLastX() > miningPosX && walls.getFirstY() <= newPosition)\n                    newPosition = walls.getFirstY()-1;\n            }\n            miningPosY = newPosition;\n        }\n\n        // ################################################### S\u00fcden  ##################################################\n        //gleiche Vorgehensweise wie im Norden\n        if (move.getFirst() == Direction.SOUTH) {\n            newPosition = Math.max(miningPosY - move.getSecond(), 0);\n\n            for (Walls walls : myMiningField.getWalls()) {\n                if (walls.getFirstY() == walls.getLastY() && walls.getFirstY() <= miningPosY && walls.getFirstX() <= miningPosX && walls.getLastX() > miningPosX && walls.getFirstY() > newPosition)\n                    newPosition = walls.getFirstY();\n            }\n            miningPosY = newPosition;\n        }\n\n        // ################################################### Westen  ##################################################\n        if (move.getFirst() == Direction.WEST) {\n\n            newPosition = Math.max(miningPosX - move.getSecond(), 0);\n\n            /*\n            2) Alle W\u00e4nde checken:\n            Wenn eine vertikale Wand und Wand im Westen und auf gleicher Y-Koordinate wie die Maschine\n            und die vorl\u00e4ufige Postion ist weiter weg, dann wird eine neue Position gesetzt\n            (X-Koordinate, da Westen)\n            */\n\n            for (Walls walls : myMiningField.getWalls()) {\n                if (walls.getFirstX() == walls.getLastX() && walls.getFirstX() <= miningPosX && walls.getFirstY() <= miningPosY && walls.getLastY() > miningPosY && walls.getFirstX() > newPosition)\n                    newPosition = walls.getFirstX();\n            }\n            miningPosX = newPosition;\n        }\n\n        // ################################################### Osten  ##################################################\n        //gleiche Vorgehensweise wie im Westen\n        if (move.getFirst() == Direction.EAST) {\n            newPosition = Math.min(miningPosX + move.getSecond(), myMiningField.getX_size() - 1);\n\n\n            for (Walls walls : myMiningField.getWalls()) {\n                if (walls.getFirstX() == walls.getLastX() && walls.getFirstX() > miningPosX && walls.getFirstY() <= miningPosY && walls.getLastY() > miningPosY && walls.getFirstX() <= newPosition)\n                    newPosition = walls.getFirstX()-1;\n            }\n            miningPosX = newPosition;\n        }\n\n        System.out.println(\"Position: (\"+miningPosX+\",\"+miningPosY+\")\");\n        return Position(miningPosX,miningPosY);\n    }\n\n\n\n    // ################################################## Analyse ######################################################\n    static public Pair<Direction,Integer> analyse(String command){\n        String direction = command.substring(command.indexOf(\"[\")+1,command.indexOf(\",\"));\n        Integer steps = Integer.parseInt(command.substring(command.indexOf(\",\")+1,command.indexOf(\"]\")));\n\n        if (direction.equals(\"no\")) return Pair.of(Direction.NORTH,steps);\n        if (direction.equals(\"so\")) return Pair.of(Direction.SOUTH,steps);\n        if (direction.equals(\"ea\")) return Pair.of(Direction.EAST,steps);\n        if (direction.equals(\"we\")) return Pair.of(Direction.WEST,steps);\n\n        throw new IllegalArgumentException(\"Illegal command: \"+command);\n    }\n\n    static public String Position(Integer posX, Integer posY){\n        return \"(\" + posX + \",\"+ posY + \")\";\n    }\n\n\n}\n"}, {"source": "student", "name": "student36", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "student", "name": "student36", "file_name": "Walls.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Getter\n@Setter\n@AllArgsConstructor\npublic class Walls {\n    private Integer firstX;\n    private Integer firstY;\n    private Integer lastX;\n    private Integer lastY;\n}"}, {"source": "student", "name": "student37", "file_name": "Droid.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Droid {\n    private int x = 1;\n    private int y = 7;\n\n    Map map = new Map();\n\n\n}\n"}, {"source": "student", "name": "student37", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n    int x = 1;\n    int y = 7;\n\n    int[][] mauernx = {{4,3}};\n    int[][] mauerny = {{3, 3}, {3, 4}, {3, 5}, {3, 6}, {3, 7}, {3, 8}, {3, 9},{5,0},{5,1},{6,3},{6,2},{6,1},{6,0}};\n\n    Mauer[] wall;\n    public Exercise0 () {\n        wall= new Mauer[14];\n        wall[0]=new Mauer(3,3,true);\n        wall[1]=new Mauer(3,4,true);\n        wall[2]=new Mauer(3,5,true);\n        wall[3]=new Mauer(3,6,true);\n        wall[4]=new Mauer(3,7,true);\n        wall[5]=new Mauer(3,8,true);\n        wall[6]=new Mauer(3,3,false);\n        wall[7]=new Mauer(4,3,false);\n        wall[8]=new Mauer(5,0,true);\n        wall[9]=new Mauer(5,1,true);\n        wall[10]=new Mauer(6,0,true);\n        wall[11]=new Mauer(6,1,true);\n        wall[12]=new Mauer(6,2,true);\n        wall[13]=new Mauer(6,3,true);\n    }\n// 3,3 3,9\n    @Override\n    public String walk(String walkCommandString) {\n        walkCommandString= walkCommandString.substring(1,walkCommandString.length()-1);\n        String[] com = walkCommandString.split(\",\");\n        boolean pablo = false;\n        for (int i=0; Integer.parseInt(com[1])>i; i++) {\n            switch (com[0]){\n                case \"no\":\n                    for (Mauer ww: wall) {\n                        if (x==ww.x && y+1== ww.y && !ww.isVertical) {\n                            pablo=true;\n                        }\n                    }\n                    if (!pablo) {\n                        y++;\n                    }\n\n                    break;\n                case \"ea\":\n                    for (Mauer ww: wall) {\n                        if (y==ww.y && x+1== ww.x && ww.isVertical) {\n                            pablo=true;\n                        }\n                    }\n                    if (!pablo) {\n                        x++;\n                    }\n\n                    break;\n                    case \"su\":\n                case \"so\":\n                    for (Mauer ww: wall) {\n                        if (y==0 || x==ww.x && y== ww.y && !ww.isVertical) {\n                        pablo=true;\n                    }\n                }\n                    if (!pablo) {\n                        y--;\n                    }\n\n                    break;\n\n\n                case \"we\":\n                    for (Mauer ww: wall) {\n                        if (x==ww.x && y== ww.y && ww.isVertical) {\n                            pablo=true;\n                        }\n                    }\n                    if (!pablo) {\n                        x--;\n                    }\n\n                    break;\n            }\n        }\n        System.out.println(com[0]+\"(\"+x+\",\"+y+\")\");\n\n        return \"(\"+x+\",\"+y+\")\";\n\n    }\n}\n"}, {"source": "student", "name": "student37", "file_name": "Map.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Setter\n@Getter\npublic class Map {\n    private int x = 12;\n    private int y = 9;\n\n    int[][] map = new int[x][y];\n\n\n\n}\n\n"}, {"source": "student", "name": "student37", "file_name": "Mauer.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Mauer  {\n    int x;\n    int y;\n    boolean isVertical;\n\n    public Mauer(int x, int y, boolean isVertical) {\n        this.x=x;\n        this.y=y;\n        this.isVertical=isVertical;\n    }\n\n}\n"}, {"source": "student", "name": "student37", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\n\n\npublic interface Walkable {\n    String walk(String walkCommandString);\n\n}\n"}, {"source": "student", "name": "student38", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nclass Cell{\n    int x;\n    int y;\n    boolean wNO;\n    boolean wEA;\n    boolean wSO;\n    boolean wWE;\n\n    public Cell(int x, int y, boolean wNO, boolean wEA, boolean wSO, boolean wWE){\n        this.x = x;\n        this.y = y;\n        this.wNO = wNO;\n        this.wEA = wEA;\n        this.wSO = wSO;\n        this.wWE = wWE;\n    }\n}\n\npublic class Exercise0 implements Moveable {\n\n    Cell[][] map;\n    int currentX = 5;\n    int currentY = 3;\n\n    @Override\n    public String move(String moveCommandString) {\n        if(map == null)\n            this.initMap();\n\n        String[] command = moveCommandString.substring(moveCommandString.indexOf(\"[\")+1,moveCommandString.indexOf(\"]\")).split((\",\"));\n\n        currentY = Math.abs(currentY-(map.length-1));\n\n        int tempX = currentX;\n        int tempY = currentY;\n        switch (command[0]){\n            case \"no\":\n                for (int i = currentY; i < currentY + Integer.parseInt(command[1]); i++){\n                    if(!map[tempY][tempX].wNO && tempY > 0)\n                        tempY--;\n                    else\n                        break;\n                }\n                break;\n            case \"ea\":\n                for (int j = currentX; j < currentX + Integer.parseInt(command[1]); j++){\n                    if(!map[tempY][tempX].wEA && tempX < map[tempY].length-1)\n                        tempX++;\n                    else\n                        break;\n                }\n                break;\n            case \"so\":\n                for (int i = currentY; i > currentY - Integer.parseInt(command[1]); i--){\n                    if(!map[tempY][tempX].wSO && tempY < map.length-1)\n                        tempY++;\n                    else\n                        break;\n                }\n                break;\n            case \"we\":\n                for (int j = currentX; j > currentX - Integer.parseInt(command[1]); j--){\n                    if(!map[tempY][tempX].wWE && tempX > 0)\n                        tempX--;\n                    else\n                        break;\n                }\n                break;\n        }\n        currentX = tempX;\n        currentY = Math.abs(tempY-(map.length-1));\n        return \"(\" +  currentX + \",\" + currentY + \")\";\n    }\n\n    private void initMap(){\n        //Creating the map of Cells\n        map = new Cell[8][12];\n        for (int i = 0; i < map.length; i++){\n            for (int j = 0; j < map[i].length; j++){\n                map[i][j] = new Cell(j,i,false,false,false,false);\n            }\n        }\n        //Creating obstacles in map\n        for (int i = 5; i < 7; i++){\n            map[i][3].wEA = true;\n            map[i][4].wWE = true;\n        }\n        for (int j = 3; j < 9; j++){\n            map[4][j].wSO = true;\n            map[5][j].wNO = true;\n        }\n        for (int i = 0; i < 6; i++){\n            map[i][5].wEA = true;\n            map[i][6].wWE = true;\n        }\n        for (int j = 1; j < 6; j++){\n            map[1][j].wSO = true;\n            map[2][j].wNO = true;\n        }\n    }\n}\n"}, {"source": "student", "name": "student38", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "student", "name": "student39", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n    int x_position = 1;\n    int y_position = 7;\n    int[][] map = new int[12][9];\n\n    public Exercise0(){\n        map[3][8] = 1;\n        map[3][7] = 1;\n        map[3][6] = 1;\n        map[3][5] = 1;\n        map[3][4] = 1;\n        map[3][3] = 3;\n        map[4][3] = 2;\n        map[5][0] = 1;\n        map[5][1] = 1;\n        map[6][0] = 1;\n        map[6][1] = 1;\n        map[6][2] = 1;\n        map[6][3] = 1;\n    }\n    @Override\n    public String goTo(String goCommandString) {\n        int steps = 0;\n        int new_y = y_position;\n        int new_x = x_position;\n        if(goCommandString.length()==6)\n            steps = Character.getNumericValue(goCommandString.charAt(4));\n        else if(goCommandString.length()==7)\n            steps = Character.getNumericValue(goCommandString.charAt(4)) * 10 + Character.getNumericValue(goCommandString.charAt(5));\n        else\n            throw new IllegalArgumentException(\"Wrong command.\");\n\n        if(goCommandString.charAt(1)=='s'){\n            new_y = y_position-steps;\n            for(int i = 0; i <= steps;i++){\n                if(y_position-i < 0){\n                    new_y = 0;\n                    break;\n                }\n                else if(map[x_position][y_position-i] == 2 || map[x_position][y_position-i] == 3) {\n                    new_y = y_position - i;\n                    break;\n                }\n            }\n        }\n        else if(goCommandString.charAt(1) == 'n'){\n            new_y = y_position+steps;\n            for(int i = 0; i <= steps;i++){\n\n                if(y_position+i > 8){\n                    new_y = 8;\n                    break;\n                }\n                else if(map[x_position][y_position+i] == 2 || map[x_position][y_position+i] == 3) {\n                    new_y = y_position + i - 1;\n                    break;\n                }\n            }\n        }\n        else if(goCommandString.charAt(1)=='e'){\n            new_x = x_position+steps;\n            for(int i = 0; i <= steps;i++){\n                if(x_position+i > 11){\n                    new_x = 11;\n                    break;\n                }\n                else if(map[x_position+i][y_position] == 1 || map[x_position+i][y_position] == 3) {\n                    new_x = x_position + i - 1;\n                    break;\n                }\n\n            }\n        }\n        else if(goCommandString.charAt(1) == 'w'){\n            new_x = x_position-steps;\n            for(int i = 0; i <= steps;i++){\n                if(x_position-i < 0){\n                    new_x = 0;\n                    break;\n                }\n                else if(map[x_position-i][y_position] == 1 || map[x_position-i][y_position] == 3) {\n                    new_x = x_position - i;\n                    break;\n                }\n            }\n        }\n        else\n            throw new IllegalArgumentException(\"Wrong direction.\");\n\n        x_position = new_x;\n        y_position = new_y;\n        return \"(\"+x_position+\",\"+y_position+\")\";\n    }\n}\n\n"}, {"source": "student", "name": "student39", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "student", "name": "student40", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n\n    private class Cell{\n        Cell(int x, int y, int walltype){\n            x_ = x;\n            y_ = y;\n            wt = walltype;\n        }\n\n        int x_;\n        int y_;\n        int wt;\n    }\n\n    private int x = 11;\n    private int y = 7;\n    private int max_x = 11;\n    private int max_y = 7;\n    private int min_x = 0;\n    private int min_y = 0;\n\n    // 0 = wall North\n    // 1 = wall West\n    // 2 = wall East\n    // 3 = wall South\n    private Cell[] walls = {\n            new Cell(11, 6, 3),\n            new Cell(10, 6, 3),\n            new Cell( 9, 6, 3),\n            new Cell( 8, 6, 3),\n            new Cell( 7, 6, 3),\n            new Cell( 6, 6, 3),\n            new Cell( 5, 6, 3),\n\n            new Cell(11, 5, 0),\n            new Cell(10, 5, 0),\n            new Cell( 9, 5, 0),\n            new Cell( 8, 5, 0),\n            new Cell( 7, 5, 0),\n            new Cell( 6, 5, 0),\n            new Cell( 5, 5, 0),\n\n            new Cell(4, 5, 2),\n            new Cell(5, 5, 1),\n            new Cell(5, 5, 3),\n            new Cell(5, 4, 0),\n\n            new Cell(5, 4, 2),\n            new Cell(5, 3, 2),\n            new Cell(5, 2, 2),\n\n            new Cell(6, 4, 1),\n            new Cell(6, 3, 1),\n            new Cell(6, 2, 1)\n\n    };\n\n    @Override\n    public String goTo(String goCommandString) {\n        // 0 = move North\n        // 1 = move West\n        // 2 = move East\n        // 3 = move South\n        int move = 99;\n        int move_amount = 0;\n        int temp_max_x = max_x;\n        int temp_min_x = min_x;\n        int temp_max_y = max_y;\n        int temp_min_y = min_y;\n\n        goCommandString = goCommandString.replace(\"[\", \"\");\n        goCommandString = goCommandString.replace(\"]\", \"\");\n\n        String[] exploded = goCommandString.split(\",\");\n\n        move_amount = Integer.parseInt(exploded[1]);\n        // the direction is either no (north), ea (east), so (south), or we (west).\n        switch(exploded[0]){\n            case \"no\":{\n                move = 0;\n                break;\n            }\n            case \"ea\":{\n                move = 2;\n                break;\n            }\n            case \"so\":{\n                move = 3;\n                break;\n            }\n            case \"we\":{\n                move = 1;\n                break;\n            }\n        }\n\n\n        for (int i = 0; i < walls.length; i++) {\n            Cell wall = walls[i];\n\n            if( wall.wt != move ) // skip all walls that do not matter on the current move\n                continue;\n\n            switch(move){\n                case 0:{\n                    if( x == wall.x_ ){\n                        if( y <= wall.y_ ) {\n                            if (wall.y_ < temp_max_y)\n                                temp_max_y = wall.y_;\n                        }\n                    }\n                    break;\n                }\n                case 1:{\n                    if( y == wall.y_ ) {\n                        if (x >= wall.x_) {\n                            if (wall.x_ > temp_min_x)\n                                temp_min_x = wall.x_;\n                        }\n                    }\n                    break;\n                }\n                case 2:{\n                    if( y == wall.y_ ) {\n                        if (x <= wall.x_) {\n                            if (wall.x_ < temp_max_x)\n                                temp_max_x = wall.x_;\n                        }\n                    }\n                    break;\n                }\n                case 3:{\n                    if( x == wall.x_ ){\n                        if( y >= wall.y_ ) {\n                            if (wall.y_ > temp_min_y) {\n                                temp_min_y = wall.y_;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n\n        switch(move){\n            case 0:{\n                y += move_amount;\n                break;\n            }\n            case 1:{\n                x -= move_amount;\n                break;\n            }\n            case 2:{\n                x += move_amount;\n                break;\n            }\n            case 3:{\n                y -= move_amount;\n                break;\n            }\n        }\n\n        x = clamp(temp_min_x, temp_max_x, x);\n        y = clamp(temp_min_y, temp_max_y, y);\n        return \"(\" + x + \",\" + y + \")\";\n    }\n    private int clamp(int min, int max, int val){\n        if( val > max )\n            return max;\n\n        if( val < min )\n            return min;\n\n        return val;\n    }\n}\n"}, {"source": "student", "name": "student40", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "student", "name": "student45", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n\n    final int WIDTH = 12;\n    final int HEIGHT = 9;\n\n    private Field[][] area = new Field[HEIGHT][WIDTH];\n    private int start_x = 8;\n    private int start_y = 5;\n\n\n    public Exercise0() {\n        init();\n        printField();\n    }\n\n    @Override\n    public String goTo(String goCommandString) {\n        String str = goCommandString\n                .replace(\"[\", \"\")\n                .replace(\"]\", \"\");\n        String[] command = str.split(\",\");\n\n        return goTo(command[0], Integer.parseInt(command[1]));\n    }\n\n    public String goTo(String direction, int steps) {\n        int amount = 0;\n\n        switch (direction){\n            case \"no\":\n                while (amount < steps && hasNoBorder(start_x, start_y - amount, direction))\n                    amount++;\n                start_y -= amount;\n                break;\n\n            case \"ea\":\n                while (amount < steps && hasNoBorder(start_x + amount, start_y, direction))\n                    amount++;\n                start_x += amount;\n                break;\n\n            case \"so\":\n                while (amount < steps && hasNoBorder(start_x, start_y + amount, direction))\n                    amount++;\n                start_y += amount;\n                break;\n\n            case \"we\":\n                while (amount < steps && hasNoBorder(start_x - amount, start_y, direction))\n                    amount++;\n                start_x -= amount;\n                break;\n\n            default:\n                return \"invalid command.\";\n        }\n\n        return String.format(\"(%d,%d)\", start_x, HEIGHT-1 - start_y);\n    }\n\n    private boolean hasNoBorder(int x, int y, String border) {\n        switch (border){\n            case \"no\":\n                return !area[y][x].north;\n            case \"ea\":\n                return !area[y][x].east;\n            case \"so\":\n                return !area[y][x].south;\n            default:\n                return !area[y][x].west;\n        }\n    }\n\n    class Field {\n        private boolean north, east, south, west;\n\n        public void set(String border){\n            switch (border){\n                case \"no\":\n                    north = true;\n                    break;\n                case \"ea\":\n                    east = true;\n                    break;\n                case \"so\":\n                    south = true;\n                    break;\n                case \"we\":\n                    west = true;\n            }\n        }\n    }\n\n    private void init() {\n        // init area\n        for (int y = 0; y < HEIGHT; y++) {\n            for (int x = 0; x < WIDTH; x++) {\n                area[y][x] = new Field();\n            }\n        }\n\n        // set top frame border\n        for (int x = 0; x < WIDTH; x++) {\n            area[0][x].set(\"no\");\n        }\n\n        // set right frame border\n        for (int y = 0; y < HEIGHT; y++) {\n            area[y][WIDTH - 1].set(\"ea\");\n        }\n\n        // set bottom frame border\n        for (int x = 0; x < WIDTH; x++) {\n            area[HEIGHT - 1][x].set(\"so\");\n        }\n\n        // set left frame border\n        for (int y = 0; y < HEIGHT; y++) {\n            area[y][0].set(\"we\");\n        }\n\n        // #1 wall\n        for (int y = 2; y < 8; y++) {\n            area[y][3].set(\"ea\");\n            area[y][4].set(\"we\");\n        }\n\n        // #2 wall\n        for (int y = 4; y < 7; y++) {\n            area[y][5].set(\"ea\");\n            area[y][6].set(\"we\");\n        }\n\n        // #3 wall\n        for (int y = 3; y < 7; y += 3) {\n            area[y][6].set(\"so\");\n            area[y][7].set(\"so\");\n            area[y][8].set(\"so\");\n\n            area[y + 1][6].set(\"no\");\n            area[y + 1][7].set(\"no\");\n            area[y + 1][8].set(\"no\");\n        }\n    }\n\n    private void printField(){\n        String tmp = \"\";\n\n        for (int y = 0; y < HEIGHT; y++) {\n            for (int x = 0; x < WIDTH; x++) {\n                if (area[y][x].north)\n                    tmp += \"n\";\n                else\n                    tmp += \"_\";\n\n                if (area[y][x].east)\n                    tmp += \"e\";\n                else\n                    tmp += \"_\";\n\n                if (area[y][x].west)\n                    tmp += \"w\";\n                else\n                    tmp += \"_\";\n\n                if (area[y][x].south)\n                    tmp += \"s\";\n                else\n                    tmp += \"_\";\n\n                System.out.printf(\"%s \", tmp);\n                tmp = \"\";\n            }\n            System.out.println();\n        }\n    }\n}\n"}, {"source": "student", "name": "student45", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "student", "name": "student47", "file_name": "Dot.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\n\n    public class Dot {\n        int X;\n        int Y;\n\n\n        public Dot(int X, int Y) {\n            this.X = X;\n            this.Y = Y;\n        }\n    }\n\n\n"}, {"source": "student", "name": "student47", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n\n\npublic class Exercise0 implements Walkable {\n\nDot startpunkt = new Dot (5,3);\n\n\n/*\n    IntStream verticalEDGE1 = IntStream.range(2,8); // @ X = 6\n    IntStream verticalEDGE2 = IntStream.range(1,3); // @ X = 4\n    IntStream horizontalEDGE1 =  IntStream.range(3,9); //@ Y = 3\n    IntStream horizontalEDGE2 =  IntStream.range(1,6); //@ Y = 6\n\n */\n         /* borders\n         (Y >= 0 && Y <=8 ) @X=0 /outer left border\n                            @X=12/outer right border\n          (X>=0 && X <= 12) @Y=0 /bottom border\n                            @Y=8 /top border\n          */\n\n\n    @Override\n    public String walk(String walkCommandString) {\n\n        System.out.println(\"punkt:\"+startpunkt.X+\",\"+startpunkt.Y);\n\n        String input = removeFirstandLast(walkCommandString);\n        System.out.println(\"incoming STRING: \"+input);\n\n        String[] inputArray = input.split(\",\");\n        System.out.println(\"command: \"+Arrays.toString(inputArray));\n\n        String input1 = inputArray[0];\n        System.out.println(\"direction: \"+input1);\n\n        int input2 = Integer.parseInt(inputArray[1]);\n        System.out.println( \"Strecke: \"+input2);\n\n\n\n\n\n        switch(input1) {\n            case (\"we\"):for(int i = 0; i<input2;i++){\n\n                /*if(startpunkt.X == 4 && startpunkt.Y >= 1 && startpunkt.Y <= 3){\n                    System.out.println(\"vertical barrier reached\");\n                    break;\n                }\n                \n                 */\n                if(startpunkt.X == 6 && startpunkt.Y >= 2 && startpunkt.Y <= 8){\n                    System.out.println(\"vertical barrier reached\");\n                    break;\n                }\n\n                if(startpunkt.X==0 && startpunkt.Y >= 0 && startpunkt.Y <=8 ){\n                    System.out.println(\"outer left border reached\");\n                    break;\n                }\n                startpunkt.X--;\n            }\n                break;\n\n            case (\"so\"):for(int i = 0; i<input2;i++) {\n\n                if(startpunkt.Y == 3 && startpunkt.X >= 3 && startpunkt.X <= 9){\n                    System.out.println(\"horizontal barrier reached\");\n                    break;\n                }\n                if(startpunkt.Y == 6 && startpunkt.X >= 1 && startpunkt.X <= 6){\n                    System.out.println(\"horizontal barrier reached\");\n                    break;\n                }\n\n                if(startpunkt.Y==0 && startpunkt.X >= 0 && startpunkt.X <=12 ){\n                    System.out.println(\"bottom border reached\");\n                    break;\n                }\n\n                startpunkt.Y--;\n            }\n                break;\n\n            case (\"ea\"):for(int i = 0; i<input2;i++) {\n\n                if(startpunkt.X+1 == 4 && startpunkt.Y >= 1 && startpunkt.Y <= 3){\n                    System.out.println(\"vertikal barrier reached\");\n                    break;\n                }\n                if(startpunkt.X+1 == 6 && startpunkt.Y >= 2 && startpunkt.Y <= 8){\n                    System.out.println(\"vertikal barrier reached\");\n                    break;\n                }\n\n                if(startpunkt.X+1==0 && startpunkt.Y >= 0 && startpunkt.Y <=8 ){\n                    System.out.println(\"outer right border reached\");\n                    break;\n                }\n                startpunkt.X++;\n            }\n                break;\n\n            case (\"no\"):for(int i = 0; i<input2;i++) {\n\n                if(startpunkt.Y+1 == 3 && startpunkt.X >= 3 && startpunkt.X <= 9){\n                    System.out.println(\"horizontal barrier reached\");\n                    break;\n                }\n                if(startpunkt.Y+1 == 6 && startpunkt.X >= 1 && startpunkt.X <= 6){\n                    System.out.println(\"horizontal barrier reached\");\n                    break;\n                }\n\n                if(startpunkt.Y+1==8 && startpunkt.X >= 0 && startpunkt.X <=12 ){\n                    System.out.println(\"top border reached\");\n                    break;\n                }\n\n                startpunkt.Y++;\n            }\n\n\n                break;\n        }\n\n        System.out.println(\"neuer punkt: \"+\"(\"+startpunkt.X +\",\"+ startpunkt.Y+\")\");\n        return \"(\"+startpunkt.X +\",\"+ startpunkt.Y+\")\";\n    }\n    public static String\n    removeFirstandLast(String str)\n    {\n\n        // Creating a StringBuilder object\n        StringBuilder sb = new StringBuilder(str);\n\n        // Removing the last character\n        // of a string\n        sb.deleteCharAt(str.length() - 1);\n\n        // Removing the first character\n        // of a string\n        sb.deleteCharAt(0);\n\n        // Converting StringBuilder into a string\n        // and return the modified string\n        return sb.toString();\n    }\n    public static String\n\n    addFirstandLast(String str)\n    {\n\n        // Creating a StringBuilder object\n        StringBuilder sb = new StringBuilder(str);\n\n        sb.insert(0,\"(\").append(\")\");\n\n        // Converting StringBuilder into a string\n        // and return the modified string\n        return sb.toString();\n    }\n\n\n}\n"}, {"source": "student", "name": "student47", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walk(String walkCommandString);\n}\n"}, {"source": "student", "name": "student50", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\n\npublic class Exercise0 implements GoAble {\n    // \uacbd\uacc4\uc120 \uae4c\uc9c0\ub294 \ud5c8\uc6a9\uc774\ub098, \uacbd\uacc4\uc120\uc774\ub098 map \uc790\uccb4\ub97c \ub118\uc5b4 \uac00\ub294 \uac8c \ubd88\uac00\ub2a5.\n    // \ub300\uac01\uc120\uc73c\ub85c \uc6c0\uc9c1\uc774\uc9c0 \uc54a\ub294\ub2e4. \uc67c \uc624 \uc704 \uc544\ub798 \ub85c\ub9cc \uc6c0\uc9c1\uc778\ub2e4.\n\n    int x = 7;\n    int y = 7;\n\n    String position;\n\n    @Override\n    public String go(String goCommandString) {\n\n        if(goCommandString.contains(\"no\")){\n            String intStr =  goCommandString.replaceAll(\"[^0-9]\",\"\");\n            int zahl = Integer.parseInt(intStr);\n\n            if( y == 0) {\n                y = y + zahl;\n                if( y > 8) {\n                    y = 7;\n                }\n\n                if( x >= 2 && x <= 9){\n                    y = 0;\n                }\n            }\n            else if( y >= 1 && y <= 5){\n                y = y + zahl;\n                if( y > 8) {\n                    y = 7;\n                }\n\n                if( x >= 2 && x <= 6){\n                    if( y > 6){\n                        y = 6;\n                    }\n                }\n            }\n\n          /*  if( y > 8) {\n                y = 7;\n            }\n*/\n\n        }\n        else if(goCommandString.contains(\"so\")){\n            String intStr =  goCommandString.replaceAll(\"[^0-9]\",\"\");\n            int zahl = Integer.parseInt(intStr);\n\n            if( y >= 6 ){\n                y = y - zahl;\n                if( x >= 2 && x <= 6){\n                    if( y < 6){\n                        y = 6;\n                    }\n                }\n                if( x >= 7 && x <= 9){\n                    if( y < 0) {\n                        y = 1;\n                    }\n                }\n                if( y < 0) {\n                    y = 0;\n                }\n            }\n\n            else if( y >= 1 && y <= 5){\n                y = y - zahl;\n                if( y < 0) {\n                    y = 0;\n                }\n                if( x >= 2 && x <= 9){\n                    if( y <= 0){\n                        y = 1;\n                    }\n                }\n            }\n            //y = y - zahl;\n            /*if( y < 0) {\n                y = 0;\n            }\n*/\n        }\n        else if(goCommandString.contains(\"we\")){\n            String intStr =  goCommandString.replaceAll(\"[^0-9]\",\"\");\n            int zahl = Integer.parseInt(intStr);\n\n\n            if( x <= 1){\n                x = x - zahl;\n                if( x < 0){\n                    x = 0;\n                }\n            }\n            else if( x >= 2 && x <= 9){\n                x = x - zahl;\n                if( y >= 1 && y <= 5){\n                    if(x < 2) {\n                        x = 2;\n                    }\n                }\n            }\n            else{\n                x = 10;\n            }\n\n          /*  x = x - zahl;\n\n            if( x < 0 ){\n                x = 0;\n            }\n*/\n\n\n        }\n        else if(goCommandString.contains(\"ea\")){\n            String intStr =  goCommandString.replaceAll(\"[^0-9]\",\"\");\n            int zahl = Integer.parseInt(intStr);\n\n            if( x < 2) {\n                x = x + zahl;\n                if( y >= 1 && y <= 5) {\n                    if(x > 2){\n                        x = 1;\n                    }\n                }\n            }\n            else if( x >= 2 && x <= 9){\n                x = x + zahl;\n                if( y >= 1 && y <= 7){\n                    if( x > 10){\n                        x = 9;\n                    }\n                }\n\n            }\n            else{\n                x = 10;\n            }\n\n            //x = x + zahl;\n\n         /*  if( y >= 1 && y <= 5) {\n                if(x > 2){\n                    x = 1;\n                }\n            }\n\n            if( x > 10){\n                x = 10;\n            }\n*/\n        }\n\n        // wall\n    /*    if( 2 <= x && x <= 6) {\n            if (y > 6) {\n                y = 5;\n            }\n        }*/\n\n        position = \"(\" +x+\",\"+y+\")\";\n\n        return position;\n    }\n\n}\n"}, {"source": "student", "name": "student50", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String go(String goCommandString);\n}\n"}, {"source": "student", "name": "student52", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport lombok.AllArgsConstructor;\n\nimport java.util.ArrayList;\n\npublic class Exercise0 implements Moveable {\n    Cords cords = new Cords(1,7);\n    ArrayList<Barrier> barriers = createBarriers();\n\n    @Override\n    public String move(String moveCommandString) {\n        var s = moveCommandString.replace(\"[\",\"\").replace(\"]\",\"\").split(\",\");\n        var dir = Direction.valueOf(s[0]);\n        var steps = Integer.parseInt(s[1]);\n\n        for (int i = 0; i < steps; i++) { moveStep(dir); }\n\n        var debug = moveCommandString + \" -> \" + cords.toString();\n        System.out.println(debug);\n        return cords.toString();\n    }\n\n    private void moveStep(Direction dir){\n        for (Barrier b : barriers){ if (b.blocks(dir)) return; }\n\n        if (dir == Direction.no) cords.y++;\n        if (dir == Direction.ea) cords.x++;\n        if (dir == Direction.so) cords.y--;\n        if (dir == Direction.we) cords.x--;\n    }\n\n    enum Direction {\n        no, ea, so, we\n    }\n\n    @AllArgsConstructor()\n    public class Cords {\n        public Integer x; public Integer y;\n        @Override\n        public String toString() {\n            return \"(\" + x.toString() + \",\" + y.toString() + \")\";\n        }\n    }\n\n    @AllArgsConstructor\n    public class Barrier{\n        public Cords start;\n        public Cords end;\n\n        public Boolean blocks(Direction dir){\n            var b = false;\n            if (dir == Direction.no && start.y == cords.y + 1 && cords.x >= start.x && cords.x < end.x)\n                b = true;\n            if (dir == Direction.ea && start.x == cords.x + 1 && cords.y >= start.y && cords.y < end.y)\n                b = true;\n            if (dir == Direction.so && start.y.equals(cords.y) && cords.x >= start.x && cords.x < end.x)\n                b = true;\n            if (dir == Direction.we && start.x.equals(cords.x) && cords.y >= start.y && cords.y < end.y)\n                b = true;\n            return b;\n        }\n    }\n\n\n    private Barrier horLine(Integer st, Integer end, Integer y){\n        return new Barrier(new Cords(st,y), new Cords(end,y));\n    }\n    private Barrier verLine(Integer st, Integer end, Integer x){\n        return new Barrier(new Cords(x,st), new Cords(x,end));\n    }\n\n    private ArrayList<Barrier> createBarriers(){\n        var l = new ArrayList<Barrier>();\n\n        l.add(verLine(0,9,0));\n        l.add(verLine(0,9,12));\n        l.add(horLine(0,12,0));\n        l.add(horLine(0,12,9));\n\n        l.add(verLine(3,9,3));\n        l.add(verLine(0,2,5));\n        l.add(verLine(0,4,6));\n\n        l.add(horLine(3,5,3));\n\n        return l;\n    }\n\n}\n"}, {"source": "student", "name": "student52", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "student", "name": "student54", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\n\nimport org.junit.jupiter.params.shadow.com.univocity.parsers.conversions.Conversion;\nimport org.xmlunit.util.Convert;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Exercise0 implements GoAble {\n\n    class Position\n    {\n        int x;\n        int y;\n\n        public Position(int x, int y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    class Wall\n    {\n        Position start;\n        Position end;\n\n        // h - horizontally\n        // v - vertically\n        char orientation;\n\n        public Wall(Position start, Position end, char orientation)\n        {\n            this.start = start;\n            this.end = end;\n            this.orientation = orientation;\n        }\n    }\n\n    class Cell\n    {\n        boolean south;\n        boolean west;\n\n        public Cell()\n        {\n            south = false;\n            west = false;\n        }\n    }\n\n    public class Grid\n    {\n        int width;\n        int height;\n        List<Wall> walls;\n        Cell [][] grid;\n\n        public Grid(int width, int height, List<Wall> walls)\n        {\n            this.width = width;\n            this.height = height;\n            this.walls = walls;\n            grid = new Cell[width][height];\n        }\n\n        public void fill_with_cells()\n        {\n            for (int x = 0; x < width; x++)\n            {\n                for(int y = 0; y < height; y++)\n                {\n                    grid[x][y] = new Cell();\n                }\n            }\n        }\n\n        public void buildWalls()\n        {\n            for(int i=0; i<walls.size(); i++)\n            {\n                if(walls.get(i).orientation == 'v')\n                {\n                    for (int y = walls.get(i).start.y; y < walls.get(i).end.y; y++)\n                    {\n                        grid[walls.get(i).start.x][y].west = true;\n                    }\n                }\n                else\n                {\n                    for (int x = walls.get(i).start.x; x < walls.get(i).end.x; x++)\n                    {\n                        grid[x][walls.get(i).start.y].south = true;\n                    }\n                }\n            }\n        }\n    }\n\n\n\n\n\n    int grid_width = 12;\n    int grid_height = 9;\n\n    List<Wall> walls;\n\n    public Position current_position = new Position(1,7);\n    public Grid grid;\n\n    public Exercise0()\n    {\n        walls = new ArrayList<>();\n        walls.add(new Wall(new Position(5,0), new Position(5,2), 'v'));\n        walls.add(new Wall(new Position(6,0), new Position(6,4), 'v'));\n        walls.add(new Wall(new Position(3,3), new Position(3,9), 'v'));\n        walls.add(new Wall(new Position(3,3), new Position(5,3), 'h'));\n\n        grid = new Grid(grid_width, grid_height, walls);\n        grid.fill_with_cells();\n        grid.buildWalls();\n\n    }\n\n    String build_return_string(Position position)\n    {\n        return \"(\" + position.x + \",\" + position.y + \")\";\n    }\n\n\n    @Override\n    public String go(String goCommandString) {\n\n        String direction = goCommandString.substring(1,3);\n        int steps = Integer.parseInt(goCommandString.substring(4,goCommandString.length()-1));\n\n\n        for(int i = 0; i < steps; i++)\n        {\n            switch ((direction))\n            {\n                case \"no\":\n                {\n                    if(current_position.y + 1 <= grid_height)\n                    {\n                        if(!grid.grid[current_position.x][current_position.y+1].south)\n                        {\n                            current_position.y += 1;\n                        }\n                        else\n                        {\n                            return build_return_string(current_position);\n                        }\n                    }\n                    else\n                    {\n                        return build_return_string(current_position);\n                    }\n                }\n                break;\n                case \"ea\":\n                {\n                    if(current_position.x + 1 <= grid_width)\n                    {\n                        if(!grid.grid[current_position.x+1][current_position.y].west)\n                        {\n                            current_position.x += 1;\n                        }\n                        else\n                        {\n                            return build_return_string(current_position);\n                        }\n                    }\n                    else\n                    {\n                        return build_return_string(current_position);\n                    }\n                }\n                break;\n                case \"so\":\n                {\n                    if(current_position.y - 1 >= 0)\n                    {\n                        if(!grid.grid[current_position.x][current_position.y].south)\n                        {\n                            current_position.y -= 1;\n                        }\n                        else\n                        {\n                            return build_return_string(current_position);\n                        }\n                    }\n                    else\n                    {\n                        return build_return_string(current_position);\n                    }\n                }\n                break;\n                case \"we\":\n                {\n                    if(current_position.x - 1 >= 0)\n                    {\n                        if(!grid.grid[current_position.x][current_position.y].west)\n                        {\n                            current_position.x -= 1;\n                        }\n                        else\n                        {\n                            return build_return_string(current_position);\n                        }\n                    }\n                    else\n                    {\n                        return build_return_string(current_position);\n                    }\n                }\n                break;\n            }\n        }\n        return build_return_string(current_position);\n    }\n}\n"}, {"source": "student", "name": "student54", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String go(String goCommandString);\n}\n"}, {"source": "student", "name": "student55", "file_name": "Exercise0.java", "code": "/*Atidy-uprobotisusedtotidyuparoom-collectgarbage,sortstuff,etc.\nInmilestone0,youhavethetasktosteersuchatidy-uprobotacrossaroomwithobstacles.\nTheroomissquare-shaped.Inthefollowingimage,youseeahowtheroomismodelledasa\nsystemofcells.*/\n\npackage thkoeln.st.st2praktikum.exercise;\n\n\n        public class Exercise0 implements GoAble{\n\n        Integer x=5;\n        Integer y=3;\n\n@Override\npublic String goTo(String goCommandString){\n\n\n        int steps=Integer.parseInt(String.valueOf(goCommandString.charAt(4)));\n\n\n        if(goCommandString.charAt(1)=='n'){\n\n\n        if(x>=3&&x<=8){\n            if(y<3){\n                if(y+steps>=2){\n                y=2;\n                return\"(\"+x+\",\"+y+\")\";\n                }\n            }\n        }\n\n        if(x>0&&x<=5){\n            if(y<6){\n                if(y+steps>=5){\n                    y=5;\n                    return\"(\"+x+\",\"+y+\")\";\n                }\n            }\n        }\n\n            if (x == 4 && y == 0) {\n                y = 0;\n                return\"(\"+x+\",\"+y+\")\";\n            }\n\n        if(y+steps>=7){\n            y=7;\n            return\"(\"+x+\",\"+y+\")\";\n        }\n\n\n\n        y+=steps;\n        return\"(\"+x+\",\"+y+\")\";\n\n        }\n\n\n\n\n\n        if(goCommandString.charAt(1)=='e'){\n\n            if(y==1||y==2){\n                if(x<4){\n                    if(x+steps>3){\n                        x=3;\n                        return\"(\"+x+\",\"+y+\")\";\n                    }\n                }\n            }\n\n            if(y>=2&&y<=7){\n                if(x<6){\n                    if(x+steps>5){\n                        x=5;\n                        return\"(\"+x+\",\"+y+\")\";\n                    }\n                }\n            }\n\n            if(x>11){\n                x=11;\n                return\"(\"+x+\",\"+y+\")\";\n            }\n            if(x>0&&x<5){\n                if(y==6){\n                    x=0;\n                    return\"(\"+x+\",\"+y+\")\";\n                }\n            }\n\n        x+=steps;\n        return\"(\"+x+\",\"+y+\")\";\n\n        }\n\n\n\n\n\n\n        if(goCommandString.charAt(1)=='s'){\n\n            if(x>=1&&x<=5){\n                if(y>=6){\n                    if(y-steps<=5){\n                        y=6;\n                        return\"(\"+x+\",\"+y+\")\";\n                    }\n                }\n            }\n\n            if(x>=3&&y<=8){\n                if(y>=3){\n                    if(y-steps<3){\n                        y=3;\n                        return\"(\"+x+\",\"+y+\")\";\n                    }\n                }\n             }\n\n            if(y-steps<0){\n                y=0;\n                return\"(\"+x+\",\"+y+\")\";\n            }\n\n        y-=steps;\n        return\"(\"+x+\",\"+y+\")\";\n        }\n\n\n\n\n        if(goCommandString.charAt(1)=='w'){\n\n            if(y>=2&&y<=7){\n                if(x>5){\n                    if(x-steps<=6){\n                        y=6;\n                        return\"(\"+x+\",\"+y+\")\";\n                    }\n                }\n            }\n\n        if(y==1||y==2){\n            if(x>3){\n                if(x-steps<=4){\n                    x=4;\n                    return\"(\"+x+\",\"+y+\")\";\n                }\n            }\n        }\n\n        if(x-steps<=0){\n            x=0;\n            return\"(\"+x+\",\"+y+\")\";\n        }\n                x-=steps;\n                return\"(\"+x+\",\"+y+\")\";\n            }\n\n            return\"(\"+x+\",\"+y+\")\";\n            }\n        }\n\n"}, {"source": "student", "name": "student55", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "student", "name": "student55", "file_name": "Obstacle.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Obstacle {\n     public Obstacle(){\n\n    }\n\n};"}, {"source": "student", "name": "student55", "file_name": "Room.java", "code": "//A room is divided into cells by an x- and y-coordinate system, each starting\n//at 0.\npackage thkoeln.st.st2praktikum.exercise;\n\npublic class Room {\n    public Room(){\n\n    }\n}"}, {"source": "student", "name": "student56", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class Exercise0 implements Moveable {\n\n    Integer horizontal = 5;\n    Integer vertikal   = 3;\n\n    @Override\n    public String move(String moveCommandString) {\n/*\n        String barrier1 = \"(1,6)-(5,6)\";\n        String barrier2 = \"(3,3)-(8,3)\";\n        String barrier3 = \"(4,1)-(4,2)\";\n        String barrier4 = \"(6,2)-(6,7)\";\n\n */\n\n\n\n\n\n        int steps = Integer.parseInt(String.valueOf(moveCommandString.charAt(4)));\n\n\n        if ( moveCommandString.charAt(1) == 'n') {\n\n\n            if (horizontal >= 3 && horizontal <= 8) {\n                if (vertikal < 3) {\n                    if (vertikal + steps >= 2) {\n                        vertikal = 2;\n                        return \"(\"+horizontal+\",\"+vertikal+\")\";\n                    }\n                }\n            }\n\n            if ( horizontal >= 1 && horizontal <= 5) {\n                if ( vertikal < 7 ){\n                    if ( vertikal + steps >= 7){\n                        vertikal = 6;\n                        return \"(\"+horizontal+\",\"+vertikal+\")\";\n                    }\n                }\n            }\n\n            if (vertikal + steps > 7) {\n                vertikal = 7;\n                return \"(\"+horizontal+\",\"+vertikal+\")\";\n            }\n\n\n\n                vertikal += steps;\n                return \"(\"+horizontal+\",\"+vertikal+\")\";\n\n        }\n\n\n\n\n\n        if ( moveCommandString.charAt(1) == 'e'){\n\n            if ( vertikal == 1 || vertikal == 2 ) {\n                if (horizontal < 4) {\n                    if (horizontal + steps > 3) {\n                        horizontal = 3;\n                        return \"(\"+horizontal+\",\"+vertikal+\")\";\n                    }\n                }\n            }\n\n            if (vertikal >= 2 && vertikal <= 7) {\n                if (horizontal < 6) {\n                    if (horizontal + steps > 5) {\n                        horizontal = 5;\n                        return \"(\"+horizontal+\",\"+vertikal+\")\";\n                    }\n                }\n            }\n\n            if ( horizontal > 11 ){\n                horizontal = 11;\n                return \"(\"+horizontal+\",\"+vertikal+\")\";\n            }\n\n                horizontal += steps;\n                return \"(\"+horizontal+\",\"+vertikal+\")\";\n\n        }\n\n\n\n\n\n\n        if ( moveCommandString.charAt(1) == 's'){\n\n            if ( horizontal >=1 && horizontal <= 5 ){\n                if ( vertikal > 5){\n                    if ( vertikal - steps < 6){\n                        vertikal = 6;\n                        return \"(\"+horizontal+\",\"+vertikal+\")\";\n                    }\n                }\n            }\n\n            if ( horizontal >= 3 && horizontal <= 8){\n                if (vertikal > 2 ){\n                    if ( vertikal - steps < 3){\n                        vertikal = 3;\n                        return \"(\"+horizontal+\",\"+vertikal+\")\";\n                    }\n                }\n            }\n\n            if ( vertikal - steps < 0 ){\n                vertikal = 0;\n                return \"(\"+horizontal+\",\"+vertikal+\")\";\n            }\n\n                vertikal -= steps;\n                return \"(\"+horizontal+\",\"+vertikal+\")\";\n        }\n\n\n\n\n        if ( moveCommandString.charAt(1) == 'w'){\n\n            if (vertikal >= 2 && vertikal <= 7){\n                if ( horizontal > 5 ){\n                    if ( horizontal - steps < 6){\n                        vertikal = 6;\n                        return \"(\"+horizontal+\",\"+vertikal+\")\";\n                    }\n                }\n            }\n\n            if ( vertikal == 1 || vertikal == 2  ){\n                if ( horizontal > 3){\n                    if ( horizontal - steps < 4) {\n                        horizontal = 4;\n                        return \"(\"+horizontal+\",\"+vertikal+\")\";\n                    }\n                }\n            }\n\n            if ( horizontal - steps <= 0 ){\n                horizontal = 0;\n                return \"(\"+horizontal+\",\"+vertikal+\")\";\n            }\n                horizontal -= steps;\n                return \"(\"+horizontal+\",\"+vertikal+\")\";\n        }\n\n        return \"(\"+horizontal+\",\"+vertikal+\")\";\n    }\n}\n"}, {"source": "student", "name": "student56", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "student", "name": "student59", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\nimport java.util.ArrayList;\npublic class Exercise0 implements GoAble {\n\n    private static final String INITIAL = \"(4,0)\";\n    private static final String[] BORDERS = {\"(7,1)-(7,6)\",\"(5,6)-(7,6)\",\"(1,6)-(3,6)\",\"(1,0)-(1,6)\"}; //, \"(0,0)-(0,8)\",\"(0,8)-(11,8)\",\"(11,0)-(11,8)\",\"(0,0)-(11,0)\"\n\n    private boolean first = true;\n    private String varNewPostion;\n    ArrayList<String> orderedBorders = new ArrayList<String>();\n\n    @Override\n    public String go(String goCommandString) {\n\n        if(this.first) {\n            this.varNewPostion = INITIAL;\n            this.first = false;\n\n            for (String border: BORDERS) {\n                //(0,1)\n                String[] border_item = border.split(\"-\");\n                String border_item_start_raw = border_item[0].substring(1, border_item[0].length() - 1);\n                String[] border_item_start = border_item_start_raw.split(\",\");\n                String border_item_end_raw = border_item[1].substring(1, border_item[1].length() - 1);\n                String[] border_item_end = border_item_end_raw.split(\",\");\n                if(Integer.parseInt(border_item_start[0]) == Integer.parseInt(border_item_end[0])){\n                    for (int i = Integer.parseInt(border_item_start[1]); i < Integer.parseInt(border_item_end[1])+1; i++) {\n                        String border_item_item = \"(\"+border_item_start[0]+\",\"+i+\")\";\n                        this.orderedBorders.add(border_item_item);\n                    }\n                }\n                if(Integer.parseInt(border_item_start[1]) == Integer.parseInt(border_item_end[1])){\n                    for (int i = Integer.parseInt(border_item_start[0]); i < Integer.parseInt(border_item_end[0])+1; i++) {\n                        String border_item_item = \"(\"+i+\",\"+border_item_start[1]+\")\";\n                        this.orderedBorders.add(border_item_item);\n                    }\n                }\n                this.orderedBorders.add(\"|-|\");\n            }\n//            System.out.println(this.orderedBorders);\n        }\n\n        //Convert new_postion String into Array [0]-> x direction\n        //                                      [1]-> y direction\n        String new_postion_raw = this.varNewPostion.substring(1, this.varNewPostion.length() - 1);\n        String[] new_position = new_postion_raw.split(\",\");\n\n        this.varNewPostion = \"(\"+new_position[0]+\",\"+new_position[1]+\")\";\n\n        //Convert String into Array [0]-> movement direction\n        //                          [1]-> movement power\n        String movement_raw = goCommandString.substring(1, goCommandString.length() - 1);\n        String[] movement = movement_raw.split(\",\");\n        int power = Integer.parseInt(movement[1]);\n\n        this.varNewPostion = this.move(movement[0], power, new_position);\n\n        return this.varNewPostion;\n    }\n\n    /**\n     *\n     * @param direction no, ea, so, we\n     * @param power anzahl der felder die sich bewegt werden soll\n     * @param position aktuelle position\n     * @return neue position\n     */\n    private String move(String direction, int power, String[] position) {\n\n        for(int i=0;i<power;i++){\n            System.out.println(\"----------------\");\n            System.out.print(\"Akutelle Position: \");\n            System.out.println(\"(\"+position[0]+\",\"+position[1]+\")\");\n            System.out.print(\"direction: \");\n            System.out.println(direction);\n            System.out.print(\"power: \");\n            System.out.println(power);\n            //Check Border in Direction\n            // -> Border yes no\n            if(borderCheck(direction, position)) {\n                return \"(\"+position[0]+\",\"+position[1]+\")\";\n            }else{\n                switch (direction) {\n                    case \"no\":\n                        position[1] = Integer.parseInt(position[1])+1+\"\";\n                        break;\n                    case \"ea\":\n                        position[0] = Integer.parseInt(position[0])+1+\"\";\n                        break;\n                    case \"so\":\n                        position[1] = Integer.parseInt(position[1])-1+\"\";\n                        break;\n                    case \"we\":\n                        position[0] = Integer.parseInt(position[0])-1+\"\";\n                        break;\n                }\n            }\n        }\n        return \"(\"+position[0]+\",\"+position[1]+\")\";\n    }\n\n    /**\n     *\n     * @param direction no, ea, so, we\n     * @param position aktuelle position bevor man movt\n     * @return boolean ob border im weg ist oder nicht\n     */\n    private boolean borderCheck(String direction, String[] position) {\n\n        boolean result = false;\n        String maybeBorderStart;\n        String maybeBorderEnd;\n\n        switch (direction) {\n            case \"no\":\n                if(Integer.parseInt(position[1])+1 == 8){\n                    result = true;\n                }\n                break;\n            case \"ea\":\n                if(Integer.parseInt(position[0])+1 == 11){\n                    result = true;\n                }\n                break;\n            case \"so\":\n                if(Integer.parseInt(position[1])-1 == -1){\n                    result = true;\n                }\n                break;\n            case \"we\":\n                if(Integer.parseInt(position[0])-1 == -1){\n                    result = true;\n                }\n                break;\n        }\n\n        if(result){\n            return result;\n        }\n\n\n        switch (direction) {\n            case \"no\":\n                maybeBorderStart = \"(\"+position[0]+\",\"+(Integer.parseInt(position[1])+1)+\")\";\n                maybeBorderEnd = \"(\"+(Integer.parseInt(position[0])+1)+\",\"+(Integer.parseInt(position[1])+1)+\")\";\n                System.out.println(maybeBorderStart);\n                System.out.println(maybeBorderEnd);\n                result = borderSearch(maybeBorderStart, maybeBorderEnd);\n                break;\n            case \"ea\":\n                maybeBorderStart = \"(\"+(Integer.parseInt(position[0])+1)+\",\"+Integer.parseInt(position[1])+\")\";\n                maybeBorderEnd = \"(\"+(Integer.parseInt(position[0])+1)+\",\"+(Integer.parseInt(position[1])+1)+\")\";\n                result = borderSearch(maybeBorderStart, maybeBorderEnd);\n                System.out.println(maybeBorderStart);\n                System.out.println(maybeBorderEnd);\n                break;\n            case \"so\":\n                maybeBorderStart = \"(\"+position[0]+\",\"+Integer.parseInt(position[1])+\")\";\n                maybeBorderEnd = \"(\"+(Integer.parseInt(position[0])+1)+\",\"+Integer.parseInt(position[1])+\")\";\n                result = borderSearch(maybeBorderStart, maybeBorderEnd);\n                System.out.println(maybeBorderStart);\n                System.out.println(maybeBorderEnd);\n                break;\n            case \"we\":\n                maybeBorderStart = \"(\"+position[0]+\",\"+Integer.parseInt(position[1])+\")\";\n                maybeBorderEnd = \"(\"+Integer.parseInt(position[0])+\",\"+(Integer.parseInt(position[1])+1)+\")\";\n                result = borderSearch(maybeBorderStart, maybeBorderEnd);\n                System.out.println(maybeBorderStart);\n                System.out.println(maybeBorderEnd);\n                break;\n        }\n        return result;\n    }\n\n    /**\n     *\n     * @param start Start-Koordinate der Maybe-Border\n     * @param ende End-Koordinate der Maybe-Border\n     * @return  true oder false , ob border oder nicht\n     */\n    private boolean borderSearch(String start, String ende){\n\n        if(this.orderedBorders.contains(start)){\n            int startIndex = this.orderedBorders.indexOf(start);\n            System.out.println(this.orderedBorders.get(startIndex));\n            System.out.println(this.orderedBorders.get(startIndex+1));\n            if(!this.orderedBorders.get(startIndex + 1).equals(\"|-|\")){\n                System.out.println(this.orderedBorders.get(startIndex+1).equals(ende));\n                return this.orderedBorders.get(startIndex+1).equals(ende);\n            }\n        }\n        return false;\n    }\n\n}\n"}, {"source": "student", "name": "student59", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String go(String goCommandString);\n}\n"}, {"source": "student", "name": "student62", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\nint x= 8;\nint y=3;\nWall[] borders;\n    public Exercise0(){\n        borders = new Wall[15];\n        borders[0] = new Wall(4,1,true);\n        borders[1] = new Wall(4,2 ,true);\n        borders[2] = new Wall(4,3 ,true);\n        borders[3] = new Wall(4,4 ,true);\n        borders[4] = new Wall(4,5 ,true);\n        borders[5] = new Wall(4,6 ,true);\n        borders[6] = new Wall(6,2 ,true);\n        borders[7] = new Wall(6,3,true);\n        borders[8] = new Wall(6,4,true);\n        borders[9] = new Wall(6,2,false);\n        borders[10] = new Wall(6,5,false);\n        borders[11] = new Wall(7,2,false);\n        borders[12] = new Wall(7,5,false);\n        borders[13] = new Wall(8,2,false);\n        borders[14] = new Wall(8,5,false);\n    }\n    @Override\n    public String walk(String walkCommandString) {\n        walkCommandString = walkCommandString.substring(1, walkCommandString.length() - 1);\n        String[] commands = walkCommandString.split(\",\");\n        boolean stop=false;\n        for(int i=0;i<Integer.parseInt(commands[1]);i++){\n            switch (commands[0]){\n                case \"no\":\n                    for (Wall w:borders) {\n                        if(w.x==x&&w.y==y+1&&!w.vertical){\n                            stop=true;\n                        }\n                    }\n                    if(!stop) y+=1;\n                    break;\n                case \"ea\":\n                    for (Wall w:borders) {\n                        if(w.x==x+1&&w.y==y&&w.vertical){\n                            stop=true;\n                        }\n                    }\n                    if(!stop) x+=1;\n                    break;\n                case \"so\":\n                    for (Wall w:borders) {\n                        if(w.x==x&&w.y==y&&!w.vertical){\n                            stop=true;\n                        }\n                    }\n                    if(!stop) y-=1;\n                    break;\n                case \"we\":\n                    for (Wall w:borders) {\n                        if(w.x==x&&w.y==y&&w.vertical){\n                            stop=true;\n                        }\n                    }\n                    if(!stop) x-=1;\n                    break;\n            }\n        }\n        return \"(\"+x+\",\"+y+\")\";\n    }\n}\n"}, {"source": "student", "name": "student62", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic abstract interface Walkable {\n    String walk(String walkCommandString);\n}\n"}, {"source": "student", "name": "student62", "file_name": "Wall.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Wall {\n    int x;\n    int y;\n    boolean vertical;\n\n    public Wall(int parx ,int pary,boolean v){\n        x=parx;\n        y=pary;\n        vertical=v;\n    }\n}\n"}, {"source": "student", "name": "student63", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n\n    int x = 1;\n    int y = 7;\n\n    @Override\n    public String walkTo(String walkCommandString) {\n        String s = walkCommandString;\n        s = s.replaceAll(\"\\\\D+\",\"\");\n        int n = Integer.parseInt(s);\n        for (int i=0; i<n; i++) {\n            if (walkCommandString.charAt(1)=='n') {\n                if (x==3 || x==4 && y==2) {\n                    i=n;\n                } else if (y<8) {\n                    y++;\n                }\n            } else if (walkCommandString.charAt(1)=='s') {\n                if (x==3 || x==4 && y==3) {\n                    i=n;\n                } else if (y>0) {\n                    y--;\n                }\n            } else if (walkCommandString.charAt(1)=='e') {\n                if ((x==2 && y>=3 && y<=8) || (x==4 && y==0 || y==1) || (x==5 && y>=0 && y<=3)) {\n                    i=n;\n                } else if (x<11) {\n                    x++;\n                }\n            } else if (walkCommandString.charAt(1)=='w') {\n                if ((x==3 && y>=3 && y<=8) || (x==5 && y==0 || y==1) || (x==6 && y>=0 && y<=3)) {\n                    i=n;\n                } else if (x>0) {\n                    x--;\n                }\n            }\n        }\n        return \"(\" + x + \",\" + y + \")\";\n\n        /*int x = 1;\n        int y = 7;\n        int steps = walkCommandString.charAt(4);\n        if(walkCommandString.charAt(1)=='n') {\n            y+=steps;\n            if (y>8) {\n                y=8;\n            }\n        } else if(walkCommandString.charAt(1)=='s') {\n            y-=steps;\n            if (y<0) {\n                y=0;\n            }\n        } else if(walkCommandString.charAt(1)=='e') {\n            x+=steps;\n            if (x>11) {\n                x=11;\n            }\n        } else if(walkCommandString.charAt(1)=='w') {\n            x-=steps;\n            if (x<0) {\n                x=0;\n            }\n        }\n        return \"(\" + x + \",\" + y + \")\";*/\n    }\n}\n"}, {"source": "student", "name": "student63", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "student", "name": "student64", "file_name": "Boundary.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Boundary {\n\n    private Point startPoint;\n    private Point endPoint;\n\n    public Boundary(Point startPoint, Point endPoint) {\n        this.startPoint = startPoint;\n        this.endPoint = endPoint;\n    }\n\n    public boolean isVertical()\n    {\n        return this.startPoint.getX() == this.endPoint.getX();\n    }\n\n    public boolean isPointColliding(Point somePoint)\n    {\n        if(!this.isVertical())\n        {\n            if(this.endPoint.getY() != somePoint.getY())\n            {\n                return false;\n            }\n\n            System.out.println(String.format(\"PUNKT %d %d\", somePoint.getX(), somePoint.getY()));\n            return somePoint.getX() >= this.startPoint.getX() &&\n                    somePoint.getX() < this.endPoint.getX();\n        }\n\n        if(this.isVertical())\n        {\n            if(this.endPoint.getX() != somePoint.getX())\n            {\n                return false;\n            }\n\n            return somePoint.getY() >= this.startPoint.getY() &&\n                    somePoint.getY() < this.endPoint.getY();\n        }\n\n        return false;\n//\n//        int dxc = somePoint.getX() - startPoint.getX();\n//        int dyc = somePoint.getY() - startPoint.getY();\n//\n//        int dxl = endPoint.getX() - startPoint.getX();\n//        int dyl = endPoint.getY() - startPoint.getY();\n//\n//        int crosses = dxc * dyl - dyc * dxl;\n//\n//        return 0 == crosses;\n    }\n\n    public Point getStartPoint() {\n        return startPoint;\n    }\n\n    public Point getEndPoint() {\n        return endPoint;\n    }\n}\n\n"}, {"source": "student", "name": "student64", "file_name": "CleaningDevice.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class CleaningDevice {\n    private Point currentPosition;\n    private String lastDirection;\n\n    public CleaningDevice(Point initialPosition) {\n        this.currentPosition = initialPosition;\n        this.lastDirection = \"\";\n    }\n\n    public void moveByOneIn(String direction)\n    {\n        switch (direction)\n        {\n            case \"ea\":\n                this.currentPosition.addToX(1);\n                break;\n            case \"we\":\n                this.currentPosition.addToX(-1);\n                break;\n            case \"no\":\n                this.currentPosition.addToY(1);\n                break;\n            case \"so\":\n                this.currentPosition.addToY(-1);\n                break;\n        }\n\n        this.lastDirection = direction;\n    }\n\n    public Point getCurrentPosition()\n    {\n        return currentPosition;\n    }\n}\n"}, {"source": "student", "name": "student64", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Exercise0 implements Walkable {\n\n    private CleaningDevice cleaningDevice;\n\n    private Boundary[] boundaries;\n\n    public Exercise0() {\n        this.cleaningDevice = new CleaningDevice(\n                new Point(4, 0)\n        );\n\n        this.boundaries = new Boundary[8];\n\n\n        // Linke Flanke\n        this.boundaries[0] = new Boundary(\n                new Point(1, 0),\n                new Point(1, 6)\n        );\n        this.boundaries[1] = new Boundary(\n                new Point(1, 6),\n                new Point(4, 6)\n        );\n\n        // Rechts Flanke\n        this.boundaries[2] = new Boundary(\n                new Point(7, 1),\n                new Point(7, 6)\n        );\n        this.boundaries[3] = new Boundary(\n                new Point(5, 6),\n                new Point(7, 6)\n        );\n\n        // Raum\n        this.boundaries[4] = new Boundary(\n                new Point(0, 0),\n                new Point(12, 0)\n        );\n        this.boundaries[5] = new Boundary(\n                new Point(0, 8),\n                new Point(12, 8)\n        );\n        this.boundaries[6] = new Boundary(\n                new Point(0, 0),\n                new Point(0, 8)\n        );\n        this.boundaries[7] = new Boundary(\n                new Point(12, 0),\n                new Point(12, 8)\n        );\n    }\n\n    @Override\n    public String walk(String walkCommandString) {\n\n        System.out.println(walkCommandString);\n\n        this.decodeWalkCommandString(walkCommandString);\n\n        return String.format(\"(%d,%d)\", this.cleaningDevice.getCurrentPosition().getX(), this.cleaningDevice.getCurrentPosition().getY());\n    }\n\n    private void decodeWalkCommandString(String walkCommandString)\n    {\n        String walkCommandStringRegex = \"\\\\[(no|ea|so|we),([0-9]+)\\\\]\";\n        Pattern pattern = Pattern.compile(walkCommandStringRegex);\n\n        Matcher matcher = pattern.matcher(walkCommandString);\n\n        if (!matcher.matches())\n        {\n            return;\n        }\n\n        String direction = matcher.group(1);\n        int steps = Integer.parseInt(matcher.group(2));\n\n        for (int stepper = 0; stepper < steps; stepper++)\n        {\n            System.out.println(String.format(\"(%d,%d)\", this.cleaningDevice.getCurrentPosition().getX(), this.cleaningDevice.getCurrentPosition().getY()));\n            if(this.willDeviceCollideInDirection(direction))\n            {\n                break;\n            }\n\n            this.cleaningDevice.moveByOneIn(direction);\n        }\n    }\n\n    private boolean willDeviceCollideInDirection(String direction)\n    {\n        Point currentDevicePos = this.cleaningDevice.getCurrentPosition();\n\n        for (Boundary boundary: this.boundaries)\n        {\n            Point collidingPoint = new Point(currentDevicePos.getX(), currentDevicePos.getY());\n\n            switch (direction)\n            {\n                case \"ea\": // rechts\n                    if(!boundary.isVertical())\n                    {\n                        continue;\n                    }\n                    collidingPoint.setX(collidingPoint.getX() + 1);\n                    break;\n                case \"we\": // links\n                    if(!boundary.isVertical())\n                    {\n                        continue;\n                    }\n                    break;\n                case \"no\":\n                    if(boundary.isVertical())\n                    {\n                        continue;\n                    }\n                    collidingPoint.setY(collidingPoint.getY() + 1);\n                    break;\n                case \"so\":\n                    if(boundary.isVertical())\n                    {\n                        continue;\n                    }\n                    break;\n            }\n\n            if(boundary.isPointColliding(collidingPoint))\n            {\n                System.out.println(String.format(\"Colliding Boundary %d %d\", boundary.getStartPoint().getX(), boundary.getStartPoint().getY()));\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n"}, {"source": "student", "name": "student64", "file_name": "Point.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Point {\n\n    private int x;\n    private int y;\n\n\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void addToX(int x) {\n        this.x += x;\n    }\n\n    public void addToY(int y) {\n        this.y += y;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public void setX(int x) {\n        this.x = x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public void setY(int y) {\n        this.y = y;\n    }\n}\n"}, {"source": "student", "name": "student64", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walk(String walkCommandString);\n}\n"}, {"source": "student", "name": "student65", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.Vector;\n\npublic class Exercise0 implements GoAble {\n    Handle handle = new Handle();\n    public Exercise0() {}\n\n    @Override\n    public String goTo(String goCommandString) {\n        return handle.goTo(goCommandString);\n    }\n}\n"}, {"source": "student", "name": "student65", "file_name": "Field.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.Vector;\n\npublic class Field {\n    public Vector<Obstacle> getObstacles() {\n        return obstacles;\n    }\n\n    public void setObstacles(Vector<Obstacle> obstacles) {\n        this.obstacles = obstacles;\n    }\n\n    private Vector<Obstacle> obstacles;\n    Field(){\n        obstacles = new Vector<Obstacle>();\n        obstacles.add(new Obstacle(new Vector2d(0,0),new Vector2d(0,9)));\n        obstacles.add(new Obstacle(new Vector2d(0,9),new Vector2d(12,9)));\n        obstacles.add(new Obstacle(new Vector2d(12,0),new Vector2d(12,9)));\n        obstacles.add(new Obstacle(new Vector2d(0,0),new Vector2d(12,0)));\n\n        obstacles.add(new Obstacle(new Vector2d(3,0),new Vector2d(3,3)));\n        obstacles.add(new Obstacle(new Vector2d(5,0),new Vector2d(5,4)));\n        obstacles.add(new Obstacle(new Vector2d(4,5),new Vector2d(7,5)));\n        obstacles.add(new Obstacle(new Vector2d(7,5),new Vector2d(7,9)));\n    }\n}\n"}, {"source": "student", "name": "student65", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "student", "name": "student65", "file_name": "Handle.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Handle {\n    private Field field = new Field();\n    private MiningMachine miningMachine = new MiningMachine();\n\n    public String goTo(String goCommandString) {\n        int index = goCommandString.lastIndexOf(',');\n        int numberOfSteps = Integer.valueOf(String.valueOf(goCommandString.charAt(index + 1)));\n        if (numberOfSteps > 0) {\n            if (goCommandString.contains(\"no\")) {\n                miningMachine.moveNorth(field, numberOfSteps);\n            }\n            if (goCommandString.contains(\"ea\")) {\n                miningMachine.moveEast(field, numberOfSteps);\n            }\n            if (goCommandString.contains(\"so\")) {\n                miningMachine.moveSouth(field, numberOfSteps);\n            }\n            if (goCommandString.contains(\"we\")) {\n                miningMachine.moveWest(field, numberOfSteps);\n            }\n        }\n        return \"(\"+miningMachine.getxPos()+\",\"+miningMachine.getyPos()+\")\";\n    }\n}\n"}, {"source": "student", "name": "student65", "file_name": "MiningMachine.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.Vector;\n\npublic class MiningMachine implements Moveable{\n    private int xPos;\n    private int yPos;\n\n    public int getxPos() {\n        return xPos;\n    }\n\n    public void setxPos(int xPos) {\n        this.xPos = xPos;\n    }\n\n    public int getyPos() {\n        return yPos;\n    }\n\n    public void setyPos(int yPos) {\n        this.yPos = yPos;\n    }\n    public MiningMachine()\n    {\n        xPos=0;\n        yPos=2;\n    }\n    public void moveNorth(Field field, int numberOfSteps)\n    {\n        Vector<Obstacle> obstacles = field.getObstacles();\n        for(int i=0;i<numberOfSteps;i++)\n        {\n            boolean moveBlocked = false;\n            for(int obstIndex=0;obstIndex<obstacles.size();obstIndex++)\n            {\n                Obstacle obstacle = obstacles.elementAt(obstIndex);\n                if(obstacle.startP.y == obstacle.endP.y && obstacle.startP.x <= xPos && obstacle.endP.x > xPos && obstacle.startP.y == yPos + 1)\n                {\n                    moveBlocked = true;\n                }\n            }\n            if(!moveBlocked)\n            {\n                yPos++;\n            }\n        }\n    }\n    public void moveEast(Field field, int numberOfSteps)\n    {\n        Vector<Obstacle> obstacles = field.getObstacles();\n        for(int i=0;i<numberOfSteps;i++)\n        {\n            boolean moveBlocked = false;\n            for(int obstIndex=0;obstIndex<obstacles.size();obstIndex++)\n            {\n                Obstacle obstacle = obstacles.elementAt(obstIndex);\n                if(obstacle.startP.x == obstacle.endP.x && obstacle.startP.y <= yPos && obstacle.endP.y > yPos && obstacle.startP.x - 1 == xPos)\n                {\n                    moveBlocked = true;\n                }\n            }\n            if(!moveBlocked)\n            {\n                xPos++;\n            }\n        }\n    }\n    public void moveSouth(Field field, int numberOfSteps)\n    {\n        Vector<Obstacle> obstacles = field.getObstacles();\n        for(int i=0;i<numberOfSteps;i++)\n        {\n            boolean moveBlocked = false;\n            for(int obstIndex=0;obstIndex<obstacles.size();obstIndex++)\n            {\n                Obstacle obstacle = obstacles.elementAt(obstIndex);\n                if(obstacle.startP.y == obstacle.endP.y && obstacle.startP.x <= xPos && obstacle.endP.x > xPos && obstacle.startP.y == yPos)\n                {\n                    moveBlocked = true;\n                }\n            }\n            if(!moveBlocked)\n            {\n                yPos--;\n            }\n        }\n    }\n    public void moveWest(Field field, int numberOfSteps)\n    {\n        Vector<Obstacle> obstacles = field.getObstacles();\n        for(int i=0;i<numberOfSteps;i++)\n        {\n            boolean moveBlocked = false;\n            for(int obstIndex=0;obstIndex<obstacles.size();obstIndex++)\n            {\n                Obstacle obstacle = obstacles.elementAt(obstIndex);\n                if(obstacle.startP.x == obstacle.endP.x && obstacle.startP.y <= yPos && obstacle.endP.y > yPos && obstacle.startP.x == xPos)\n                {\n                    moveBlocked = true;\n                }\n            }\n            if(!moveBlocked)\n            {\n                xPos--;\n            }\n        }\n    }\n}\n"}, {"source": "student", "name": "student65", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    public void moveNorth(Field field, int numberOfSteps);\n    public void moveEast(Field field, int numberOfSteps);\n    public void moveSouth(Field field, int numberOfSteps);\n    public void moveWest(Field field, int numberOfSteps);\n}\n"}, {"source": "student", "name": "student65", "file_name": "Obstacle.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Obstacle {\n    public Vector2d startP;\n    public Vector2d endP;\n    public Obstacle(Vector2d startP, Vector2d endP)\n    {\n        this.startP=startP;\n        this.endP=endP;\n    }\n}\n"}, {"source": "student", "name": "student65", "file_name": "Vector2d.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Vector2d {\n    int x,y;\n    public Vector2d(int x, int y)\n    {\n        this.x=x;\n        this.y=y;\n    }\n}\n"}, {"source": "student", "name": "student66", "file_name": "Command.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport lombok.Getter;\n\n@Getter\npublic class Command {\n    private String direction;\n    private int steps;\n\n    public Command(String commandString){\n        String[] commandStringArray = commandString.split(\",\");\n        direction = commandStringArray[0].substring(1);\n        steps = Integer.parseInt(commandStringArray[1].substring(0, commandStringArray[1].length()-1));\n    }\n}\n"}, {"source": "student", "name": "student66", "file_name": "Coordinate.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport lombok.EqualsAndHashCode;\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Getter\n@Setter\n@EqualsAndHashCode\npublic class Coordinate {\n    private int x;\n    private int y;\n\n    public Coordinate(int x, int y){\n        this.x = x;\n        this.y = y;\n    }\n\n    @Override\n    public String toString(){\n        return \"(\" + x + \",\" + y + \")\";\n    }\n}\n"}, {"source": "student", "name": "student66", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\n\npublic class Exercise0 implements GoAble {\n\n    private Room room;\n    private Robot robot;\n\n    public Exercise0(){\n        room = new Room(12,9);\n        room.addWall(new Wall(new Coordinate(4,1), new Coordinate(4,7)));\n        room.addWall(new Wall(new Coordinate(6,2), new Coordinate(6,5)));\n        room.addWall(new Wall(new Coordinate(6,2), new Coordinate(9,2)));\n        room.addWall(new Wall(new Coordinate(6,5), new Coordinate(9,5)));\n        robot = new Robot(new Coordinate(8,3));\n    }\n\n\n    @Override\n    public String go(String goCommandString) {\n        Command command = new Command(goCommandString);\n        for(int i=0; i<command.getSteps(); i++) {\n            Coordinate newCoordinate = new Coordinate(robot.getPosition().getX(), robot.getPosition().getY());\n            switch (command.getDirection()) {\n                case (\"no\"):\n                    newCoordinate.setY(robot.getPosition().getY() + 1);\n                    break;\n                case (\"so\"):\n                    newCoordinate.setY(newCoordinate.getY() - 1);\n                    break;\n                case (\"ea\"):\n                    newCoordinate.setX(robot.getPosition().getX() + 1);\n                    break;\n                case (\"we\"):\n                    newCoordinate.setX(robot.getPosition().getX() - 1);\n                    break;\n            }\n            if (!robotHitsWall(command.getDirection(), newCoordinate) && robotStaysInRoom(newCoordinate)) {\n                robot.move(command.getDirection());\n            } else {\n                break;\n            }\n        }\n        return robot.getPosition().toString();\n    }\n\n    private boolean robotHitsWall(String direction, Coordinate newRobotPosition){\n        switch (direction) {\n            case(\"no\"):\n                for(Wall wall : room.getHorizontallyWalls()){\n                    if(wall.getWholeWall().contains(newRobotPosition) && !wall.getTo().equals(newRobotPosition)){\n                        return true;\n                    }\n                }\n                break;\n            case(\"so\"):\n                for(Wall wall : room.getHorizontallyWalls()){\n                    if(wall.getWholeWall().contains(robot.getPosition()) && !wall.getTo().equals(robot.getPosition())){\n                        return true;\n                    }\n                }\n                break;\n            case(\"ea\"):\n                for(Wall wall : room.getVerticallyWalls()){\n                    if(wall.getWholeWall().contains(newRobotPosition) && !wall.getTo().equals(newRobotPosition)){\n                        return true;\n                    }\n                }\n                break;\n            case(\"we\"):\n                for(Wall wall : room.getVerticallyWalls()){\n                    if(wall.getWholeWall().contains(robot.getPosition()) && !wall.getTo().equals(robot.getPosition())){\n                        return true;\n                    }\n                }\n                break;\n        }\n        return false;\n    }\n\n    private boolean robotStaysInRoom(Coordinate newCoordinate){\n        return newCoordinate.getX() >= 0 && newCoordinate.getX() < room.getLength() &&\n                newCoordinate.getY() >= 0 && newCoordinate.getY() < room.getWidth();\n    }\n}\n"}, {"source": "student", "name": "student66", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String go(String goCommandString);\n}\n"}, {"source": "student", "name": "student66", "file_name": "Robot.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport lombok.Getter;\n\n@Getter\npublic class Robot {\n    private Coordinate position;\n\n    public Robot(Coordinate position){\n        this.position = position;\n    }\n\n    public void move(String direction){\n        switch (direction){\n            case \"no\":\n                position.setY(position.getY()+1);\n                break;\n            case \"so\":\n                position.setY(position.getY()-1);\n                break;\n            case \"we\":\n                position.setX(position.getX()-1);\n                break;\n            case \"ea\":\n                position.setX(position.getX()+1);\n                break;\n        }\n    }\n}\n"}, {"source": "student", "name": "student66", "file_name": "Room.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport lombok.Getter;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n@Getter\npublic class Room {\n    private int length;\n    private int width;\n    private Set<Wall> verticallyWalls = new HashSet<>();\n    private Set<Wall> horizontallyWalls = new HashSet<>();\n\n    public Room(int length, int width){\n        this.length = length;\n        this.width = width;\n    }\n\n    public void addWall(Wall wall){\n        if(wallIsInsideRoom(wall)){\n            if(wall.getFrom().getX() == wall.getTo().getX()){\n                verticallyWalls.add(wall);\n            }else\n                if(wall.getFrom().getY() == wall.getTo().getY()){\n                    horizontallyWalls.add(wall);\n                }\n        }\n    }\n\n    private boolean wallIsInsideRoom(Wall wall){\n        return wall.getTo().getX() >= 0 && wall.getFrom().getX() >= 0 && wall.getTo().getY() >= 0 && wall.getFrom().getY() >= 0 &&\n                wall.getTo().getX() <= length && wall.getFrom().getX() <= length && wall.getTo().getY() <= width && wall.getFrom().getY() <= width;\n    }\n}\n"}, {"source": "student", "name": "student66", "file_name": "Wall.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport lombok.Getter;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n@Getter\npublic class Wall {\n    private Coordinate from;\n    private Coordinate to;\n    private Set<Coordinate> wholeWall = new HashSet<>();\n\n    public Wall(Coordinate from, Coordinate to) {\n        this.from = from;\n        this.to = to;\n        createWall();\n    }\n\n    private void createWall(){\n        if(from.getX() > to.getX()){\n            for(int i=0; i<=from.getX()-to.getX(); i++){\n                wholeWall.add(new Coordinate(to.getX()+i, from.getY()));\n            }\n        }else\n            if(from.getX() < to.getX()){\n                for(int i=0; i<=to.getX()-from.getX(); i++){\n                    wholeWall.add(new Coordinate(from.getX()+i, from.getY()));\n                }\n            }else\n                if(from.getY() >= to.getY()){\n                    for(int i=0; i<from.getY()-to.getY(); i++){\n                        wholeWall.add(new Coordinate(to.getX(), to.getY()+i));\n                    }\n                }else\n                    if(from.getY() < to.getY()) {\n                        for (int i = 0; i <= to.getY() - from.getY(); i++) {\n                            wholeWall.add(new Coordinate(from.getX(), from.getY()+i));\n                        }\n                    }\n    }\n\n    @Override\n    public String toString(){\n        return from.toString().concat(\"-\".concat(to.toString()));\n    }\n}\n"}, {"source": "student", "name": "student68", "file_name": "Barrier.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Getter\n@Setter\npublic class Barrier {\n    private Integer xStart;\n    private Integer yStart;\n    private Integer xEnd;\n    private Integer yEnd;\n\n    public Barrier (Integer xStart,Integer yStart, Integer xEnd, Integer yEnd){\n        this.xStart=xStart;\n        this.yStart=yStart;\n        this.xEnd=xEnd;\n        this.yEnd=yEnd;\n    }\n\n}\n"}, {"source": "student", "name": "student68", "file_name": "Direction.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic enum Direction {\n    NORTH,EAST,SOUTH,WEST;\n}\n"}, {"source": "student", "name": "student68", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\n\nimport org.springframework.data.util.Pair;\n\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Exercise0 implements Walkable {\n\n    //    private Robot robot = new Robot(7,7,new Map(11,8, new ArrayList<Barrier>(Arrays.asList(\n    //                new Barrier(2,6,7,6),    // Horizontal\n    //                new Barrier(2,1,10,1),   // Horizontal\n    //                new Barrier(2,1,2,6),    // Vertikal\n    //                new Barrier(10,1,10,8)   // Vertikal\n    //            ))));\n\n    // ================================= INITIALISIERUNG DES ROBOTER + MAP + BARRIEREN =================================\n    private Robot robot = new Robot(7,7,new Map(11,8, Arrays.asList(\n            new Barrier(2,6,7,6),    // Horizontal\n            new Barrier(2,1,10,1),   // Horizontal\n            new Barrier(2,1,2,6),    // Vertikal\n            new Barrier(10,1,10,8)   // Vertikal\n        )));\n\n\n    @Override\n    public String walk(String walkCommandString) {\n        return robot.moveRobot(walkCommandString);\n    }\n\n}\n"}, {"source": "student", "name": "student68", "file_name": "Map.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Getter\n@Setter\n@AllArgsConstructor\npublic class Map {\n    private Integer xSize;\n    private Integer ySize;\n    private List<Barrier> barriers;\n\n\n//    public Map (Integer xSize,Integer ySize, List<Barrier> barriers) {\n//        this.xSize = xSize;\n//        this.ySize = ySize;\n//        this.barriers = barriers;\n//    }\n\n}\n"}, {"source": "student", "name": "student68", "file_name": "Robot.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.springframework.data.util.Pair;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n@Getter\n@Setter\n@AllArgsConstructor\npublic class Robot {\n    private Integer robotPosX;\n    private Integer robotPosY;\n    private Map myMap;\n\n\n    // #################################################################################################################\n    // ################################################### MOVE ROBOT ##################################################\n    // #################################################################################################################\n    public String moveRobot(String command) {\n        Pair<Direction,Integer> move = parseCommand(command);                           // Kommando analysieren in Form von einem Pair  bsp. Pair(NORTH,2)\n        Integer stopPoint;\n        // =============================================================================================================\n        // ========================================== MOVE TO NORTH ====================================================\n        // =============================================================================================================\n        if (move.getFirst() == Direction.NORTH) {\n            // Setzen des vorl\u00e4ufigen StopPoint\n            stopPoint = Math.min(robotPosY + move.getSecond(), myMap.getYSize() - 1);  // StopPoint ist MapGrenze ODER robotPosY + Bewegung\n\n            // Alle Barrieren checken\n            for (Barrier barrier : myMap.getBarriers()) {\n                if (barrier.getYStart() == barrier.getYEnd()                            // Wenn horizontale Barriere\n                        && barrier.getYStart() > robotPosY                              // & Barriere liegt im n\u00f6rdlichen Bereich\n                        && barrier.getXStart() <= robotPosX                             // & Barriere liegt auf gleicher X-Koordinate wie der Roboter\n                        && barrier.getXEnd() > robotPosX                                // & Barriere liegt auf gleicher X-Koordinate wie der Roboter\n                        && barrier.getYStart() <= stopPoint)                            // & Barriere Schr\u00e4nkt Bewegung ein bzw. ist vorl\u00e4ufiger/vorheriger StopPoint ist weiter entfernt\n                    stopPoint = barrier.getYStart()-1;                                  // => Setzt neuen StopPoint\n                }\n\n            robotPosY = stopPoint;                                                       // Setzen der neuen Y-Position des Roboters\n        }\n\n        // =============================================================================================================\n        // ========================================== MOVE TO SOUTH ====================================================\n        // =============================================================================================================\n        if (move.getFirst() == Direction.SOUTH) {\n            // Setzen des vorl\u00e4ufigen StopPoint\n            stopPoint = Math.max(robotPosY - move.getSecond(), 0);                      // StopPoint ist MapGrenze ODER robotPosY - Bewegung\n\n            // Alle Barrieren checken\n            for (Barrier barrier : myMap.getBarriers()) {\n                if (barrier.getYStart() == barrier.getYEnd()                            // Wenn horizontale Barriere\n                        && barrier.getYStart() <= robotPosY                              // & Barriere liegt im s\u00fcdlichen Bereich\n                        && barrier.getXStart() <= robotPosX                             // & Barriere liegt auf gleicher X-Koordinate wie der Roboter\n                        && barrier.getXEnd() > robotPosX                                // & Barriere liegt auf gleicher X-Koordinate wie der Roboter\n                        && barrier.getYStart() > stopPoint)                             // & Barriere Schr\u00e4nkt Bewegung ein bzw. vorl\u00e4ufiger/vorheriger StopPoint ist weiter entfernt\n                    stopPoint = barrier.getYStart();                                    // => Setzt neuen StopPoint\n                }\n\n            robotPosY = stopPoint;                                                       // Setzen der neuen Y-Position des Roboters\n        }\n\n        // =============================================================================================================\n        // =========================================== MOVE TO WEST ====================================================\n        // =============================================================================================================\n        if (move.getFirst() == Direction.WEST) {\n            // Setzen des vorl\u00e4ufigen StopPoint\n            stopPoint = Math.max(robotPosX - move.getSecond(), 0);                      // StopPoint ist MapGrenze ODER robotPosX - Bewegung\n\n            // Alle Barrieren checken\n            for (Barrier barrier : myMap.getBarriers()) {\n                if (barrier.getXStart() == barrier.getXEnd()                            // Wenn vertikale Barriere\n                        && barrier.getXStart() <= robotPosX                              // & Barriere liegt im \u00f6stlichen Bereich\n                        && barrier.getYStart() <= robotPosY                             // & Barriere liegt auf gleicher Y-Koordinate wie der Roboter\n                        && barrier.getYEnd() > robotPosY                                // & Barriere liegt auf gleicher Y-Koordinate wie der Roboter\n                        && barrier.getXStart() > stopPoint)                             // & Barriere Schr\u00e4nkt Bewegung ein bzw. vorl\u00e4ufiger/vorheriger StopPoint ist weiter entfernt\n                    stopPoint = barrier.getXStart();                                    // => Setzt neuen StopPoint\n                }\n\n            robotPosX = stopPoint;                                                      // Setzen der neuen X-Position des Roboters\n        }\n\n        // =============================================================================================================\n        // =========================================== MOVE TO EAST ====================================================\n        // =============================================================================================================\n        if (move.getFirst() == Direction.EAST) {\n            // Setzen des vorl\u00e4ufigen StopPoint\n            stopPoint = Math.min(robotPosX + move.getSecond(), myMap.getXSize() - 1);  // StopPoint ist MapGrenze ODER robotPosX - Bewegung\n\n            // Alle Barrieren checken\n            for (Barrier barrier : myMap.getBarriers()) {\n                if (barrier.getXStart() == barrier.getXEnd()                            // Wenn vertikale Barriere\n                        && barrier.getXStart() > robotPosX                              // & Barriere liegt im \u00f6stlichen Bereich\n                        && barrier.getYStart() <= robotPosY                             // & Barriere liegt auf gleicher Y-Koordinate wie der Roboter\n                        && barrier.getYEnd() > robotPosY                                // & Barriere liegt auf gleicher Y-Koordinate wie der Roboter\n                        && barrier.getXStart() <= stopPoint)                             // & Barriere Schr\u00e4nkt Bewegung ein bzw. vorl\u00e4ufiger/vorheriger StopPoint ist weiter entfernt\n                    stopPoint = barrier.getXStart()-1;                                  // => Setzt neuen StopPoint\n                }\n            robotPosX = stopPoint;                                                      // Setzen der neuen X-Position des Roboters\n        }\n\n        System.out.println(\"Position: (\"+robotPosX+\",\"+robotPosY+\")\");\n        return ParsePosition(robotPosX,robotPosY);\n    }\n\n\n\n    // #################################################################################################################\n    // ################################################## PARSE COMMAND ################################################\n    // #################################################################################################################\n    static public Pair<Direction,Integer> parseCommand (String command){\n        String direction = command.substring(command.indexOf(\"[\")+1,command.indexOf(\",\"));\n        Integer cells = Integer.parseInt(command.substring(command.indexOf(\",\")+1,command.indexOf(\"]\")));\n        //System.out.println(\"Direction: \"  + direction + \"     cells: \" + cells);\n\n        if (direction.equals(\"no\"))\n            return Pair.of(Direction.NORTH,cells);\n\n        if (direction.equals(\"so\"))\n            return Pair.of(Direction.SOUTH,cells);\n\n        if (direction.equals(\"ea\"))\n            return Pair.of(Direction.EAST,cells);\n\n        if (direction.equals(\"we\"))\n            return Pair.of(Direction.WEST,cells);\n\n        throw new IllegalArgumentException(\"Illegal command: \"+command);\n    }\n\n\n\n    // #################################################################################################################\n    // ################################################## PARSE POSITION ###############################################\n    // #################################################################################################################\n    static public String ParsePosition (Integer posX, Integer posY){\n        return \"(\" + posX + \",\"+ posY + \")\";\n    }\n\n\n\n\n}\n"}, {"source": "student", "name": "student68", "file_name": "Test.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        stringMe(\"[no,4]\");\n    }\n\n    public static void stringMe(String command) {\n        //String direction = command.substring(command.indexOf(\"[\")+1,command.indexOf(\",\")-1);\n        //Integer cells = Integer.parseInt(command.substring(command.indexOf(\",\")+1,command.indexOf(\"]\")-1));\n        //System.out.println(\"Direction: \"  + direction + \"     cells: \" + cells);\n\n        System.out.println(command.indexOf(\"[\")+1);\n        System.out.println(command.substring(command.indexOf(\"[\")+1,command.indexOf(\",\")));\n        System.out.println(command.substring(command.indexOf(\",\")+1,command.indexOf(\"]\")));\n    }\n\n}\n"}, {"source": "student", "name": "student68", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walk(String walkCommandString);\n}\n"}, {"source": "student", "name": "student69", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Exercise0 implements Moveable {\n\n    List<String> tmp = new ArrayList<>();\n\n    int x = 0;\n    int y = 2;\n\n    @Override\n    public String move(String moveCommandString) {\n        tmp.clear();\n        String[] random = moveCommandString.split(\",\");\n\n        String richtung = random[0].replace(\"[\", \"\");\n        int anzahl = Integer.parseInt(random[1].replace(\"]\", \"\"));\n\n        List<String> HORIZONTAL = new ArrayList<>(Arrays.asList(\"(3,0)\", \"(3,1)\", \"(3,2)\", \"(5,0)\", \"(5,1)\", \"(5,2)\", \"(5,3)\",\n                \"(7,5)\", \"(7,6)\", \"(7,7)\", \"(7,8)\"));\n        List<String> VERTIKAL = new ArrayList<>(Arrays.asList(\"(4,5)\", \"(5,5)\", \"(6,5)\"));\n\n        switch (richtung) {\n            case \"no\":\n                norden(VERTIKAL, anzahl);\n                break;\n            case \"so\":\n                s\u00fcden(VERTIKAL, anzahl);\n                break;\n            case \"ea\":\n                osten(HORIZONTAL, anzahl);\n                break;\n            case \"we\":\n                westen(HORIZONTAL, anzahl);\n                break;\n        }\n        System.out.println(moveCommandString);\n        System.out.println(\"(\" + x + \",\" + y + \")\");\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    private void westen(List<String> HORIZONTAL, int anzahl) {\n        /*\n        Potentielle W\u00e4nde raussuchen\n         */\n        for (int i = 0; i < HORIZONTAL.size(); i++) {\n            String temporaer = HORIZONTAL.get(i); // -> (0,3)\n            String[] abc = temporaer.split(\",\"); // -> String bei ',' aufteilen -> [\"(0\", \"3)\"]\n            String def = abc[1].replace(\")\", \"\"); // -> Index 1 aus Array und Klammer entfernen -> \"3\"\n\n            if (Integer.parseInt(def) == y && // schauen ob potentielle wand selbe H\u00f6he ist\n                    Integer.parseInt(abc[0].replace(\"(\", \"\")) <= x && // schauen ob x von potentieller Wand kleiner gleich als aktuelles x ist\n                    (x - anzahl) < Integer.parseInt(abc[0].replace(\"(\", \"\"))) {  // schauen ob neue position gr\u00f6\u00dfer als x von potentieller Wand ist\n                tmp.add(temporaer); //Falls Bedingungen zutreffen, f\u00fcge die Wand der Tempor\u00e4ren Liste hinzu\n            }\n        }\n        if (tmp.size() == 0) { // falls keine W\u00e4nde gefunden wurden -> Neue position kann ohne Probleme gesetzt werden\n            x = x - anzahl;\n        } else {\n            // Liste mit den Potentiellen W\u00e4nden durchgehen und die gr\u00f6\u00dfte X Koordinate davon finden\n            int max = Integer.parseInt(tmp.get(0).split(\",\")[0].replace(\"(\", \"\")); // Beispiel -> (\"0,3\") -> 3\n            for (int i = 0; i < tmp.size(); i++) {\n                if (max < Integer.parseInt(tmp.get(i).split(\",\")[0].replace(\"(\", \"\"))) {\n                    max = Integer.parseInt(tmp.get(i).split(\",\")[0].replace(\"(\", \"\"));\n                }\n            }\n            x = max; // x = Der Koordinate der Wand setzen (Da man da stoppt)\n        }\n        if (x < 0) {\n            x = 0;\n        }\n    }\n\n    private void osten(List<String> HORIZONTAL, int anzahl) {\n        /*\n        Potentielle W\u00e4nde raussuchen\n         */\n        for (int i = 0; i < HORIZONTAL.size(); i++) {\n            String temporaer = HORIZONTAL.get(i); // -> (0,3)\n            String[] abc = temporaer.split(\",\"); // -> String bei ',' aufteilen -> [\"(0\", \"3)\"]\n            String def = abc[1].replace(\")\", \"\"); // -> Index 1 aus Array und Klammer entfernen -> \"3\"\n\n            if (Integer.parseInt(def) == y && // schauen ob potentielle wand selbe H\u00f6he ist\n                    Integer.parseInt(abc[0].replace(\"(\", \"\")) > x && // schauen ob x von potentieller Wand kleiner gleich als aktuelles x ist\n                    (x + anzahl) >= Integer.parseInt(abc[0].replace(\"(\", \"\"))) {  // schauen ob neue position gr\u00f6\u00dfer als x von potentieller Wand ist\n                tmp.add(temporaer); //Falls Bedingungen zutreffen, f\u00fcge die Wand der Tempor\u00e4ren Liste hinzu\n            }\n        }\n        if (tmp.size() == 0) { // falls keine W\u00e4nde gefunden wurden -> Neue position kann ohne Probleme gesetzt werden\n            x = x + anzahl;\n        } else {\n            // Liste mit den Potentiellen W\u00e4nden durchgehen und die gr\u00f6\u00dfte X Koordinate davon finden\n            int max = Integer.parseInt(tmp.get(0).split(\",\")[0].replace(\"(\", \"\")); // Beispiel -> (\"0,3\") -> 3\n            for (int i = 0; i < tmp.size(); i++) {\n                if (max > Integer.parseInt(tmp.get(i).split(\",\")[0].replace(\"(\", \"\"))) {\n                    max = Integer.parseInt(tmp.get(i).split(\",\")[0].replace(\"(\", \"\"));\n                }\n            }\n            x = max - 1; // x = Der Koordinate der Wand setzen (Da man da stoppt)\n        }\n        if (x > 12 - 1) {\n            x = 12 - 1;\n        }\n    }\n\n\n    private void s\u00fcden(List<String> VERTIKAL, int anzahl) {\n        for (int i = 0; i < VERTIKAL.size(); i++) {\n            String temporaer = VERTIKAL.get(i); // -> (0,3)\n            String[] abc = temporaer.split(\",\"); // -> String bei ',' aufteilen -> [\"(0\", \"3)\"]\n            String def = abc[0].replace(\"(\", \"\"); // -> Index 1 aus Array und Klammer entfernen -> \"3\"\n\n            if (Integer.parseInt(def) == x && // schauen ob potentielle wand selbe H\u00f6he ist\n                    Integer.parseInt(abc[1].replace(\")\", \"\")) <= y && // schauen ob x von potentieller Wand kleiner gleich als aktuelles x ist\n                    (y - anzahl) < Integer.parseInt(abc[1].replace(\")\", \"\"))) {  // schauen ob neue position gr\u00f6\u00dfer als x von potentieller Wand ist\n                tmp.add(temporaer); //Falls Bedingungen zutreffen, f\u00fcge die Wand der Tempor\u00e4ren Liste hinzu\n            }\n        }\n        if (tmp.size() == 0) { // falls keine W\u00e4nde gefunden wurden -> Neue position kann ohne Probleme gesetzt werden\n            y = y - anzahl;\n        } else {\n            // Liste mit den Potentiellen W\u00e4nden durchgehen und die gr\u00f6\u00dfte X Koordinate davon finden\n            int max = Integer.parseInt(tmp.get(1).split(\",\")[1].replace(\")\", \"\")); // Beispiel -> (\"0,3\") -> 3\n            for (int i = 0; i < tmp.size(); i++) {\n                if (max > Integer.parseInt(tmp.get(i).split(\",\")[1].replace(\")\", \"\"))) {\n                    max = Integer.parseInt(tmp.get(i).split(\",\")[1].replace(\")\", \"\"));\n                }\n            }\n            y = max; // x = Der Koordinate der Wand setzen (Da man da stoppt)\n        }\n        if (y < 0) {\n            y = 0;\n        }\n        System.out.println(y);\n\n    }\n\n    private void norden(List<String> VERTIKAL, int anzahl) {\n\n\n        for (int i = 0; i < VERTIKAL.size(); i++) {\n            String temporaer = VERTIKAL.get(i); // -> (0,3)\n            String[] abc = temporaer.split(\",\"); // -> String bei ',' aufteilen -> [\"(0\", \"3)\"]\n            String def = abc[0].replace(\"(\", \"\"); // -> Index 1 aus Array und Klammer entfernen -> \"3\"\n\n            if (Integer.parseInt(def) == x && // schauen ob potentielle wand selbe H\u00f6he ist\n                    Integer.parseInt(abc[1].replace(\")\", \"\")) > y && // schauen ob x von potentieller Wand kleiner gleich als aktuelles x ist\n                    (y + anzahl) >= Integer.parseInt(abc[1].replace(\")\", \"\"))) {  // schauen ob neue position gr\u00f6\u00dfer als x von potentieller Wand ist\n                tmp.add(temporaer); //Falls Bedingungen zutreffen, f\u00fcge die Wand der Tempor\u00e4ren Liste hinzu\n            }\n        }\n        if (tmp.size() == 0) { // falls keine W\u00e4nde gefunden wurden -> Neue position kann ohne Probleme gesetzt werden\n            y = y + anzahl;\n        } else {\n            // Liste mit den Potentiellen W\u00e4nden durchgehen und die gr\u00f6\u00dfte X Koordinate davon finden\n            int max = Integer.parseInt(tmp.get(1).split(\",\")[1].replace(\")\", \"\")); // Beispiel -> (\"0,3\") -> 3\n            for (int i = 0; i < tmp.size(); i++) {\n                if (max > Integer.parseInt(tmp.get(i).split(\",\")[1].replace(\")\", \"\"))) {\n                    max = Integer.parseInt(tmp.get(i).split(\",\")[1].replace(\")\", \"\"));\n                }\n            }\n            y = max - 1; // x = Der Koordinate der Wand setzen (Da man da stoppt)\n        }\n        if (y > 9 - 1) {\n            y = 9 - 1;\n        }\n\n    }\n}\n"}, {"source": "student", "name": "student69", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "student", "name": "student7", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n    int[] limit = new int[]{12,9};\n    int[] robot = {8, 3};\n    int[][] walls = {{4, 1, 4, 7}, {6, 2, 6, 5}, {6, 2, 9, 2} ,{6, 5, 9, 5}};\n\n    @Override\n    public String move(String moveCommandString) {\n        String result = result = \"(\"+robot[0]+\",\"+robot[1]+\")\";\n        String[] command = moveCommandString.substring(1,moveCommandString.length()-1).split(\",\");\n        int[]movement;\n        switch (command[0]){    //direction\n            case \"no\":\n                movement = new int[]{0, 1};\n                break;\n            case \"ea\":\n                movement = new int[]{1, 0};\n                break;\n            case \"so\":\n                movement = new int[]{0, -1};\n                break;\n            case \"we\":\n                movement = new int[]{-1, 0};\n                break;\n            default:\n                return result;\n        }\n        for (int i = 0; i < Integer.parseInt(command[1]); i++){ //walls\n            if(movement[1] == 1){\n                int dest = robot [1] + movement[1];\n                for (int[] elem: walls) {\n                    if(elem[1] == elem[3] && elem[3]  == dest\n                            && robot[0] >= elem[0] && robot[0] < elem[2]){\n                        return result;\n                    }\n                }\n            }if(movement[1] == -1){\n                for (int[] elem: walls) {\n                    if(elem[1] == elem[3] && elem[3]  == robot[1]\n                            && robot[0] >= elem[0] && robot[0] < elem[2]){\n                        return result;\n                    }\n                }\n            }if(movement[0] == 1){\n                int dest = robot [0] + movement[0];\n                for (int[] elem: walls) {\n                    if(elem[0] == elem[2] && elem[2]  == dest\n                            && robot[1] >= elem[1] && robot[1] < elem[3]){\n                        return result;\n                    }\n                }\n            }if(movement[0] == -1){\n                for (int[] elem: walls) {\n                    if(elem[0] == elem[2] && elem[2]  == robot[0]\n                            && robot[1] >= elem[1] && robot[1] < elem[3]){\n                        return result;\n                    }\n                }\n            }\n            if(robot[0] + movement[0] < 0 || robot[0] + movement[0] > limit[0]-1 || robot[1] + movement[1] < 0 || robot[1] + movement[1] > limit[1]-1)\n                return result;  //boundary\n            robot[0] += movement[0];\n            robot[1] += movement[1];\n            result = \"(\"+robot[0]+\",\"+robot[1]+\")\";\n        }\n        return result;\n    }\n}\n\n"}, {"source": "student", "name": "student7", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "student", "name": "student70", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Locale;\n\npublic class Exercise0 implements Walkable {\n\n    @Override\n    public String walk(String walkCommandString) {\n        String command[]=walkCommandString.replace(\"[\",\"\")\n                .replace(\"]\",\"\").split(\",\");\n        String dir=command[0];\n        int move =Integer.parseInt(command[1]);\n\n\n\n        startmove(dir,move);\n        return dvice.toString();\n    }\n\n\n    Point dvice;\n    int max_x = 10, max_y = 7;\n    List<Wall> wallList = new ArrayList<>();\n\n    public Exercise0() {\n        dvice = new Point(7, 7);\n\n        Point wallpoint1 = new Point(10, 8);\n        Point wallpoint2 = new Point(10, 1);\n        Point wallpoint3 = new Point(2, 1);\n        Point wallpoint4 = new Point(2, 6);\n        Point wallpoint5 = new Point(7, 6);\n        wallList.add(new Wall(wallpoint2, wallpoint1));\n        wallList.add(new Wall(wallpoint3, wallpoint2));\n        wallList.add(new Wall(wallpoint3, wallpoint4));\n        wallList.add(new Wall(wallpoint4, wallpoint5));\n\n    }\n\n    String startmove(String dir,int movment) {\n\n        switch (dir) {\n            case \"no\":\n                vertical(movment, 1);\n                break;\n            case \"so\":vertical(movment, -1);\n                break;\n            case \"ea\":horizontally(movment,1);\n                break;\n            case \"we\":horizontally(movment,-1);\n                break;\n        }\n        return \"\";\n    }\n\n    private void horizontally (int movment, int dr) {\n        int correct=0;if(dr>0)correct=1;\n\n        for (int i = 1; i <= movment; i++) {\n            boolean move = true;\n            // check if dvice rich the end of map\n            if (dvice.x + dr <= max_x && dvice.x + dr >= 0) {\n                for (Wall wall : wallList) {\n                    // check if wall vertically\n                    if (wall.getStart().getX() == wall.getEnd().getX()) {\n                        if (dvice.getX()+correct == wall.getStart().getX() && dvice.getY() >= wall.getStart().getY() && dvice.getY() < wall.getEnd().getY()) {\n                            move = false;\n                            break;\n                        }\n                    }\n\n\n                }\n            }else move = false;\n            if (move) dvice.setX(dvice.getX()+dr);\n            else break;\n\n        }\n\n\n    }\n\n\n\n    private void vertical(int movment, int dr) {\n        int correct=0;if(dr>0)correct=1;\n        for (int i = 1; i <= movment; i++) {\n            boolean move = true;\n            // check if dvice rich the end of map\n            if (dvice.y + dr <= max_y && dvice.y + dr >= 0) {\n                for (Wall wall : wallList) {\n                    // check if wall horizontally\n                    if (wall.getStart().getY() == wall.getEnd().getY()) {\n                        if (dvice.getY()+correct == wall.getStart().getY() && dvice.getX() >= wall.getStart().getX() && dvice.getX() < wall.getEnd().getX()) {\n                            move = false;\n                            break;\n                        }\n                    }\n\n\n                }\n            } else move = false;\n            if (move) dvice.setY(dvice.getY()+dr);\n            else break;\n\n        }\n\n\n    }\n\n\n}\n"}, {"source": "student", "name": "student70", "file_name": "Point.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\nimport lombok.Setter;\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Point {\n\n    @Setter\n    @Getter\n    int x,y;\n\n\n\n\n    @Override\n    public String toString() {\n        return \"(\" + x +\",\" + y +')';\n    }\n}\n"}, {"source": "student", "name": "student70", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walk(String walkCommandString);\n}\n"}, {"source": "student", "name": "student70", "file_name": "Wall.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\nimport lombok.Setter;\n\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Wall {\n\n    @Setter\n    @Getter\n    Point start,end;\n\n}\n"}, {"source": "student", "name": "student71", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport org.springframework.data.util.Pair;\n\nimport java.util.*;\n\npublic class Exercise0 implements GoAble {\n\n    private enum rotation{\n        North,\n        west,\n        south,\n        east\n    }\n\n    private class obstacle{\n        public int x1,x2;\n        public int y1,y2;\n\n        public obstacle(int x1,int y1,int x2,int y2){\n            this.x1 = x1;\n            this.x2 = x2;\n            this.y1 = y1;\n            this.y2 = y2;\n        }\n    }\n\n    private class Map{\n        public ArrayList<obstacle> obstacles = new ArrayList();\n        \n        public int sizeX = 11;\n        public int sizeY = 8;\n        \n        public Map(){\n            obstacles.add(new obstacle(4,1,4,6));\n            obstacles.add(new obstacle(6,2,8,2));\n            obstacles.add(new obstacle(6,5,8,5));\n            obstacles.add(new obstacle(6,2,6,4));\n        }\n    }\n\n    private int positionX = 8;\n    private int positionY = 3;\n\n    @Override\n    public String go(String goCommandString) {\n\n        if(goCommandString.toCharArray()[0] != '[' || goCommandString.toCharArray()[goCommandString.length()-1] != ']')\n            return null;\n\n        var rawString = goCommandString.substring(1,goCommandString.length()-1);\n\n        var rawRotation = rawString.split(\",\")[0];\n        var rawLength = rawString.split(\",\")[1];\n\n        rotation tempRotation;\n        Integer tempLength = Integer.parseInt(rawLength);\n        Map map = new Map();\n\n        \n        switch(rawRotation) {\n            case \"no\":\n                tempRotation = rotation.North;\n                break;\n            case \"ea\":\n                tempRotation = rotation.east;\n                break;\n            case \"so\":\n                tempRotation = rotation.south;\n                break;\n            case \"we\":\n                tempRotation = rotation.west;\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected value: \" + rawRotation);\n        }\n\n        switch (tempRotation) {\n            case south:\n                for (int i = 0; i < tempLength; i++) {\n                    for (var obstacle: map.obstacles ) {\n\n                        if(obstacle.x1 == obstacle.x2)\n                            continue;\n\n                        if(!(positionX >= obstacle.x1 && positionX <= obstacle.x2))\n                            continue;\n\n                        if(positionY == obstacle.y1)\n                            return String.format(\"(%d,%d)\",positionX,positionY);\n                    }\n                    positionY--;\n\n                    if(positionY == 0)\n                        return String.format(\"(%d,%d)\",positionX,positionY);\n                }\n                break;\n            case North:\n\n                for (int i = 0; i < tempLength; i++) {\n                    for (var obstacle: map.obstacles ) {\n\n                        if(obstacle.x1 == obstacle.x2)\n                            continue;\n\n                        if(!(positionX >= obstacle.x1 && positionX <= obstacle.x2))\n                            continue;\n\n                        if(positionY +1 == obstacle.y1)\n                            return String.format(\"(%d,%d)\",positionX,positionY);\n                    }\n                    positionY++;\n\n                    if(positionY == map.sizeY)\n                        return String.format(\"(%d,%d)\",positionX,positionY);\n                }\n                break;\n\n            case west:\n\n                for (int i = 0; i < tempLength; i++) {\n                    for (var obstacle: map.obstacles ) {\n\n                        if(obstacle.y1 == obstacle.y2)\n                            continue;\n\n                        if(!(positionY >= obstacle.y1 && positionY <= obstacle.y2))\n                            continue;\n\n                        if(positionX == obstacle.x1)\n                            return String.format(\"(%d,%d)\",positionX,positionY);\n                    }\n                    positionX--;\n\n                    if(positionX == 0)\n                        return String.format(\"(%d,%d)\",positionX,positionY);\n                }\n                break;\n\n            case east:\n\n                for (int i = 0; i < tempLength; i++) {\n                    for (var obstacle: map.obstacles ) {\n\n                        if(obstacle.y1 == obstacle.y2)\n                            continue;\n\n                        if(!(positionY >= obstacle.y1 && positionY <= obstacle.y2))\n                            continue;\n\n                        if(positionX +1 == obstacle.x1)\n                            return String.format(\"(%d,%d)\",positionX,positionY);\n                    }\n                    positionX++;\n\n                    if(positionX == map.sizeX)\n                        return String.format(\"(%d,%d)\",positionX,positionY);\n                }\n                break;\n        }\n        \n        \n        \n        return String.format(\"(%d,%d)\",positionX,positionY);\n    }\n\n\n}\n"}, {"source": "student", "name": "student71", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String go(String goCommandString);\n}\n"}, {"source": "student", "name": "student73", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n\n    public int[][] grid = new int[12][9];\n\n    //public int[] startPosition = {8,3};\n    public int[] currentPosition = {8,3};\n\n\n    public int[][] fillGrid (int x, int y) {\n        for (int i = 0; i < x; i++) {\n            for (int j = 0; j < y; j++) {\n                grid[i][j] = 1;\n            }\n        }\n        for (int i = 1; i <= 7; i++) {\n            grid[4][i] = 0;\n        }\n        for (int i = 2; i <= 5; i++) {\n            grid[6][i] = 0;\n        }\n        for (int i = 6; i <= 9; i++) {\n            grid[i][2] = 0;\n        }\n        for (int i = 6; i <= 9; i++) {\n            grid[i][5] = 0;\n        }\n        return grid;\n    }\n\n    public void showGrid (int[][] grid1) {\n        for (int i = 0; i < 12; i++) {\n            for (int j = 0; j< 9; j++) {\n                System.out.println(grid1[i][j]);\n            }\n        }\n    }\n\n    public void tellPosition() {\n        System.out.println(\"My x-position is \" + currentPosition[0]);\n        System.out.println(\"My y-position is \" + currentPosition[1]);\n    }\n\n    @Override\n    public String moveTo(String moveCommandString) {\n\n        int[][] room = fillGrid(12, 9);\n        //showGrid(room);\n        int stepsToDo = Integer.parseInt(moveCommandString.substring(moveCommandString.indexOf(',')+1,moveCommandString.indexOf(']'))); //vielleicht noch mit substring testen\n        String richtung = moveCommandString.substring(moveCommandString.indexOf('[')+1,moveCommandString.indexOf(','));\n        //tellPosition();\n        switch (richtung) {\n            case \"no\":\n                for(int i = 0; i < stepsToDo; i++) {\n                    if (currentPosition[1] == 8) {\n                        return \"(\" + Integer.toString(currentPosition[0]) + \",\" + Integer.toString(currentPosition[1]) + \")\";\n                    }\n                    if (room[currentPosition[0]][currentPosition[1] + 1] == 1) {\n                        currentPosition[1]++;\n                    } else if (room[currentPosition[0]+1][currentPosition[1]+1] == 1) {\n                        currentPosition[1]++;\n                    } else return \"(\" + Integer.toString(currentPosition[0]) + \",\" + Integer.toString(currentPosition[1]) + \")\";\n                } break;\n            case \"ea\":\n                for (int i = 0; i < stepsToDo; i++) {\n                    if (currentPosition[0] == 11) {\n                        return \"(\" + Integer.toString(currentPosition[0]) + \",\" + Integer.toString(currentPosition[1]) + \")\";\n                    }\n                    if (room[currentPosition[0]+1][currentPosition[1]] == 1) {\n                        currentPosition[0]++;\n                    } else if (room[currentPosition[0]+1][currentPosition[1]+1] == 1) {\n                        currentPosition[0]++;\n                    } else return \"(\" + Integer.toString(currentPosition[0]) + \",\" + Integer.toString(currentPosition[1]) + \")\";\n                } break;\n            case \"so\":\n                if (room[currentPosition[0]][currentPosition[1]] == 1 || room[currentPosition[0]+1][currentPosition[1]] == 1) {\n                    for (int i = 0; i < stepsToDo; i++) {\n                        if (currentPosition[1] == 0) {\n                            return \"(\" + Integer.toString(currentPosition[0]) + \",\" + Integer.toString(currentPosition[1]) + \")\";\n                        }\n                        if (room[currentPosition[0]][currentPosition[1] - 1] == 1) {\n                            currentPosition[1]--;\n                        } else if (room[currentPosition[0]][currentPosition[1] - 1] != 1) {\n                            currentPosition[1]--;\n                            if (room[currentPosition[0]+1][currentPosition[1]] != 1) {\n                                return \"(\" + Integer.toString(currentPosition[0]) + \",\" + Integer.toString(currentPosition[1]) + \")\";\n                            }\n                        }\n                     }\n                } else return \"(\" + Integer.toString(currentPosition[0]) + \",\" + Integer.toString(currentPosition[1]) + \")\";\n                break;\n            case \"we\":\n                if (room[currentPosition[0]][currentPosition[1]] == 1 || room[currentPosition[0]][currentPosition[1]+1] == 1) {\n                    for (int i = 0; i < stepsToDo; i++) {\n                        if (currentPosition[0] == 0) {\n                            return \"(\" + Integer.toString(currentPosition[0]) + \",\" + Integer.toString(currentPosition[1]) + \")\";\n                        }\n                        if(room[currentPosition[0]-1][currentPosition[1]] == 1) {\n                            currentPosition[0]--;\n                        } else if (room[currentPosition[0]-1][currentPosition[1]] != 1) {\n                            currentPosition[0]--;\n                            if(room[currentPosition[0]][currentPosition[1]+1] != 1) {\n                                return \"(\" + Integer.toString(currentPosition[0]) + \",\" + Integer.toString(currentPosition[1]) + \")\";\n                            }\n                        }\n                    }\n                } else return \"(\" + Integer.toString(currentPosition[0]) + \",\" + Integer.toString(currentPosition[1]) + \")\";\n                break;\n            default: break;\n        }\n        //tellPosition();\n        return \"(\" + Integer.toString(currentPosition[0]) + \",\" + Integer.toString(currentPosition[1]) + \")\";\n    }\n}\n"}, {"source": "student", "name": "student73", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String moveTo(String moveCommandString);\n}\n"}, {"source": "student", "name": "student76", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n\n    int x=1,y=7;\n    @Override\n    public String walkTo(String walkCommandString) {\n\n        int steps = Integer.parseInt(String.valueOf(walkCommandString.charAt(4)));\n\n        if(walkCommandString.charAt(1)=='n'){\n            if( (x < 3 && y <9) || ( x >= 5 && y < 9)){\n                if( y+steps > 8) y=8;\n                else y += steps;\n            }\n            else if((x < 5 && x >= 3) && y < 3){\n                if(y+steps > 2) y=2;\n                else y += steps;\n            }\n            else {\n                if(y+steps > 8) y=8;\n                else y += steps;\n            }\n        }\n\n        if(walkCommandString.charAt(1)=='s'){\n            if( (x < 3 && y >= 0) || (x >= 5 && y >= 0)){\n                if( y-steps < 0) y=0;\n                else y -= steps;\n            }\n            else if((x < 5 && x >= 3) ){\n                if( y >= 3) {\n                    if (y - steps < 3) y = 3;\n                    else y -= steps;\n                }\n                else{\n                    if (y - steps < 0) y = 0;\n                    else y -= steps;\n\n                }\n\n            }\n        }\n\n        if(walkCommandString.charAt(1)=='e'){\n            if( (x>=6 && x<=11) && (y>=0 && y<=3)){\n                if( x+steps > 11) x=11;\n                else x+=steps;\n            }\n\n            else if( (x>=3 && x<=11) && (y>=4 && y<=8)){\n                if( x+steps > 11) x=11;\n                else x+=steps;\n            }\n\n            else if(x==5 && (y>=0 && y<=1)){\n               x+=steps;\n               x=5;\n            }\n\n            else if((x>=3 && x<=5) && y==3 ){\n                if( x+steps > 5) x=5;\n                else x+=steps;\n            }\n\n            else if((x>=0 && x<=4) && (y>=0 && y<=1)){\n                if( x+steps > 4) x=4;\n                else x+=steps;\n            }\n            else if((x>=0 && x<=5) && y==2){\n                if( x+steps > 5) x=5;\n                else x+=steps;\n            }\n\n            else if((x>=0 && x<=2) && (y>=3 && y<=8)){\n                if( x+steps > 2) x=2;\n                else x+=steps;\n            }\n        }\n\n        if(walkCommandString.charAt(1)=='w'){\n\n            if( (x>=6 && x<=11) && (y>=0 && y<=3)){\n                if( x-steps < 6) x=6;\n                else x-=steps;\n            }\n\n            else if( (x>=3 && x<=11) && (y>=4 && y<=8)){\n                if( x-steps < 3) x=3;\n                else x-=steps;\n            }\n\n            else if(x==5 && (y>=0 && y<=1)){\n                //x-=steps;\n                x=5;\n            }\n\n            else if((x>=3 && x<=5) && y==3 ){\n                if( x-steps < 3) x=3;\n                else x-=steps;\n            }\n\n            else if((x>=0 && x<=4) && (y>=0 && y<=1)){\n                if( x-steps < 0) x=0;\n                else x-=steps;\n            }\n            else if((x>=0 && x<=5) && y==2){\n                if( x-steps < 0) x=0;\n                else x-=steps;\n            }\n\n            else if((x>=0 && x<=2) && (y>=3 && y<=8)){\n                if( x-steps < 0) x=0;\n                else x-=steps;\n            }\n        }\n\n\n        return \"(\"+x+\",\"+y+\")\";\n    }\n\n}\n\n"}, {"source": "student", "name": "student76", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "student", "name": "student77", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Walkable {\n    private static double round (double value) {\n        int scale = (int) Math.pow(10, 2);\n        return (double) Math.round(value * scale) / scale;\n    }\n    public  double roombaPosition=8.3;\n    double[] wallArray ={4.1,4.2,4.3,4.4,4.5,4.6,4.7,6.2,6.3,6.4,6.5,7.2,7.5,8.2,8.5,9.2,9.5};\n\n    @Override\n    public String walkTo(String walkCommandString) {\n\n        int c=0;\n        String check = walkCommandString.substring(1,3);\n    int x = Integer.parseInt(walkCommandString.substring(4,5));\n        for (int y =0; y < x; y++){\n\n    switch (check){\n        case \"no\":\n            c = 0;\n            for (int i =0; i < wallArray.length; i++){\n                if (wallArray[i]== round(roombaPosition+0.1)){\n                    c++;\n                }\n                if (wallArray[i]==round(roombaPosition+1.1)){\n                    c++;\n                }\n            }\n            if(c!=2) roombaPosition = round(roombaPosition+0.1);\n            break;\n        case \"so\":\n            c= 0;\n            for (int i =0; i < wallArray.length; i++){\n\n                if (wallArray[i]== round(roombaPosition)){\n                    c++;\n                }\n                if (wallArray[i]==round(roombaPosition+1)){\n                    c++;\n                }\n            }\n\n            if (c!=2) roombaPosition = round(roombaPosition-0.1);\n            break;\n        case \"ea\":\n            c= 0;\n            for (int i =0; i < wallArray.length; i++){\n                if (wallArray[i]== round(roombaPosition+1.1)){\n                    c++;\n                }\n                if (wallArray[i]==round(roombaPosition+1)){\n                    c++;\n                }\n            }\n            if (c!=2) roombaPosition = roombaPosition+1;\n            break;\n        case \"we\":\n            c = 0;\n            for (int i =0; i < wallArray.length; i++){\n                if (wallArray[i]== round(roombaPosition)){\n                    c++;\n                }\n                if (wallArray[i]==round(roombaPosition+0.1)){\n                    c++;\n                }\n            }\n            if (c!=2) roombaPosition = round(roombaPosition-1);\n            break;\n    }\n        }\n    return (\"(\"+ Math.round(roombaPosition) +\",\"+ Math.round((roombaPosition-Math.round(roombaPosition))*10) +\")\");\n    }\n}\n"}, {"source": "student", "name": "student77", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "student", "name": "student79", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n    int x= 3;\n    int y= 0;\n\n    @Override\n    public String moveTo(String moveCommandString) {\n        // moveCommandString= [we,3]\n        String move= moveCommandString.substring(1,moveCommandString.length()-1);\n        String[] moving= move.split(\",\");\n        String richtung= moving[0];\n        int steps= Integer.parseInt(moving[1]);\n\n\n\n        if (\"no\".equals(richtung)) {\n            if ((x == 0 || x==8 ||x==9 ||x==10 || x == 11)){\n                if ((y + steps) > 7)\n                    y = 7;\n                else\n                    y += steps;\n            }\n            if (( x== 1 || x==2 || x == 3|| x == 7) && 0 <= y && y <= 3){\n                if ((y + steps) > 3)\n                    y = 3;\n                else\n                    y += steps;\n            }\n            if ((x==4 || x==5 ||x == 6) && 0<=y && y<=2){\n                if ((y + steps) > 2)\n                    y = 2;\n                else\n                    y += steps;\n            }\n\n            if ((x==4 || x==5 ||x == 6) && y == 3){\n                y = 3;\n            }\n\n            if (1 <= x && x <= 7 && y >= 4){\n                if ((y + steps) > 7)\n                    y = 7;\n                else\n                    y += steps;}\n\n                System.out.println(\"x =\"+x + \"y=\"+y);\n        } else if (\"so\".equals(richtung)) {\n            if ((x == 0 || x==8 ||x==9 ||x==10 || x == 11) && y >= 0){\n                if ((y - steps) < 0)\n                    y = 0;\n                else\n                    y -= steps;}\n\n            if (( x== 1 || x==2 || x == 3|| x == 7) && 0 <= y && y <= 3){\n                if ((y - steps) < 0)\n                    y = 0;\n                else\n                    y -= steps;}\n            if (4 <= x && x <= 6 && 0 <= y && y <= 2){\n                if ((y - steps) < 0)\n                    y = 0;\n                else\n                    y -= steps;}\n\n            if ((x==4 || x==5 ||x == 6) && y == 3){\n                y = 3;}\n            if (1 <= x && x <= 7 && y >= 4){\n                if ((y - steps) < 4)\n                    y = 4;\n                else\n                    y -= steps;}\n            System.out.println(\"x =\"+x + \"y=\"+y);\n        } else if (\"ea\".equals(richtung)) {\n            if (0 <= x && 3 <= y){\n                if ((x + steps) > 11)\n                    x = 11;\n                else\n                    x += steps;}\n            if (0 <= x && x <= 2 && 0 <= y && y <= 2){\n                if ((x + steps) > 2)\n                    x = 2;\n                else\n                    x += steps;}\n            if (3 <= x && x <= 6 && (y == 0 || y == 1)){\n                if ((x + steps) > 6)\n                    x = 6;\n                else\n                    x += steps;}\n            if (x >= 7 && (y == 0 || y == 1)){\n                if ((x + steps) > 11)\n                    x = 11;\n                else\n                    x += steps;}\n            if (x >= 3 && y == 2){\n                if ((x + steps) > 11)\n                    x = 11;\n                else\n                    x += steps;}\n            System.out.println(\"x =\"+x + \"y=\"+y);\n        } else if (\"we\".equals(richtung)) {\n            if (0 <= x && 3 <= y){\n                if ((x - steps) < 0)\n                    x = 0;\n                else\n                    x -= steps;}\n            if (0 <= x && x <= 2 && 0 <= y && y <= 2){\n                if ((x - steps) < 0)\n                    x = 0;\n                else\n                    x -= steps;}\n\n            if (3 <= x && x <= 6 && (y == 0 || y == 1)){\n                if ((x - steps) > 3)\n                    x = 3;\n                else\n                    x -= steps;}\n            if (x >= 7 && (y == 0 || y == 1)){\n                if ((x - steps) < 7)\n                    x = 7;\n                else\n                    x -= steps;}\n\n            if (x >= 3 && y == 2){\n                if ((x - steps) < 3)\n                    x = 3;\n                else\n                    x -= steps;}\n            System.out.println(\"x =\"+x + \"y=\"+y);\n        }\n\n    return \"(\"+ this.x +\",\"+ this.y+\")\";\n\n    }\n}\n"}, {"source": "student", "name": "student79", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String moveTo(String moveCommandString);\n\n}\n"}, {"source": "student", "name": "student8", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n\n    private int coordinateX = 3, coordinateY = 0;\n\n    public void setCoordinateX(int coordinateX) {\n        this.coordinateX = coordinateX;\n    }\n\n    public void setCoordinateY(int coordinateY) {\n        this.coordinateY = coordinateY;\n    }\n\n    private void checkIterationNorthWallSmash(int coordinateX, int coordinateY, int actionCount)\n    {\n        // under the first wall\n        if (coordinateY <= 3 && (coordinateX >= 4 && coordinateX <=7))\n        {\n            coordinateY+=actionCount;\n\n            if (coordinateY >= 3)\n                coordinateY = 2;\n            setCoordinateY(coordinateY);\n\n            // between wall 1 & 2\n        }else if (coordinateY == 3 && coordinateX >= 1 && coordinateX <= 7)\n        {\n            coordinateY = 3;\n            setCoordinateY(coordinateY);\n\n\n        }else if (coordinateY <= 3 && (coordinateX >= 1 && coordinateX <= 7) && !(coordinateX >= 4 && coordinateX <=7) )\n        {\n          coordinateY +=actionCount;\n          if (coordinateY > 3)\n          {\n              coordinateY = 3;\n          }\n          setCoordinateY(coordinateY);\n\n        } else if (coordinateY == 3 && !(coordinateX >= 1 && coordinateX <= 8))\n        {\n\n            coordinateY+=actionCount;\n            if (coordinateY > 11)\n                coordinateY = 11;\n                setCoordinateY(coordinateY);\n        } else\n        {\n            // abroad the two walls ==> boundary check\n            coordinateY += actionCount;\n            if (coordinateY > 7)\n                coordinateY = 7;\n                setCoordinateY(coordinateY);\n        }\n    }\n\n\n    private void checkIterationEastWallSmash(int coordinateX, int coordinateY, int actionCount)\n    {\n        // before the first wall\n        if (coordinateX <= 2 && (coordinateY >= 0 && coordinateY <= 2))\n        {\n            coordinateX += actionCount;\n\n            if (coordinateX >= 3)\n            {\n                coordinateX = 2;\n\n            }\n\n            setCoordinateX(coordinateX);\n            // between wall 1 & 2\n        }else if (coordinateX >= 3 && coordinateX <= 7 &&  (coordinateY >= 0 && coordinateY <= 1))\n        {\n\n            coordinateX+=actionCount;\n\n            if (coordinateX >= 7 )\n            {\n                coordinateX = 6;\n\n            }\n            setCoordinateX(coordinateX);\n\n            // abroad the walls ==> boundary check\n        }else\n        {\n            coordinateX += actionCount;\n            if (coordinateX >= 11)\n                coordinateX = 11;\n\n            setCoordinateX(coordinateX);\n        }\n    }\n\n    private void checkIterationSouthWallSmash(int coordinateX, int coordinateY, int actionCount)\n    {\n        if (coordinateY >= 4 && (coordinateX >= 1 && coordinateX <= 7))\n        {\n            coordinateY-=actionCount;\n            if (coordinateY <= 4)\n            {\n                coordinateY = 4;\n            }\n            setCoordinateY(coordinateY);\n\n        }else if (coordinateY == 3 && (coordinateX >= 4 && coordinateX <=6) )\n        {\n\n            coordinateY = 3;\n            setCoordinateY(coordinateY);\n\n        }else if (coordinateY == 3 && !(coordinateX >= 4 && coordinateX <=7))\n        {\n            coordinateY-=actionCount;\n            if (coordinateY < 0)\n                coordinateY = 0;\n\n            setCoordinateY(coordinateY);\n        }else\n        {\n            coordinateY-=actionCount;\n            if (coordinateY < 0)\n                coordinateY = 0;\n\n            setCoordinateY(coordinateY);\n        }\n\n    }\n\n    private void checkIterationWestWallSmash(int coordinateX, int coordinateY, int actionCount)\n    {\n        if (coordinateX >= 7 && (coordinateY >= 0 && coordinateY <= 1))\n        {\n            coordinateX -= actionCount;\n\n            if (coordinateX <= 7)\n            {\n                coordinateX = 7;\n            }\n\n            setCoordinateX(coordinateX);\n\n        }else if (coordinateX <= 7 && coordinateX >= 3 && (coordinateY <= 2))\n        {\n            coordinateX -= actionCount;\n\n            if (coordinateX <= 3)\n            {\n                coordinateX = 3;\n            }\n\n            setCoordinateX(coordinateX);\n\n\n\n        }else if (coordinateX <= 7 && coordinateX >= 3 && coordinateY == 3)\n        {\n\n            coordinateX -= actionCount;\n\n            if (coordinateX <= 0)\n            {\n                coordinateX = 0;\n            }\n\n            setCoordinateX(coordinateX);\n        } else if (coordinateX <= 7 && coordinateX >= 3 && !(coordinateY >= 0 && coordinateY <= 3))\n        {\n            coordinateX-=actionCount;\n\n            setCoordinateX(coordinateX);\n        }else\n        {\n            coordinateX-=actionCount;\n            if (coordinateX < 0)\n            {\n                coordinateX = 0;\n            }\n\n            setCoordinateX(coordinateX);\n        }\n\n\n    }\n\n    @Override\n    public String moveTo(String moveCommandString)\n    {\n\n        moveCommandString = moveCommandString.replace(\"[\",\"\");\n\n        moveCommandString = moveCommandString.replace(\"]\",\"\");\n\n        String[] movementCommand = moveCommandString.split(\",\");\n\n        String count = movementCommand[1];\n\n        int actionCount = Integer.parseInt(count);\n\n        String movementOrientation = movementCommand[0];\n\n\n        switch (movementOrientation)\n        {\n            case \"no\":\n                checkIterationNorthWallSmash(coordinateX,coordinateY,actionCount);\n                break;\n            case \"ea\":\n                checkIterationEastWallSmash(coordinateX,coordinateY,actionCount);\n                break;\n            case \"so\":\n                checkIterationSouthWallSmash(coordinateX,coordinateY,actionCount);\n                break;\n            case \"we\":\n                checkIterationWestWallSmash(coordinateX,coordinateY,actionCount);\n                break;\n        }\n\n\n\n\n\n          return \"(\"+coordinateX+\",\"+coordinateY+\")\";\n\n    }\n\n}\n\n"}, {"source": "student", "name": "student8", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable\n{\n    String moveTo(String moveCommandString);\n}\n"}, {"source": "student", "name": "student80", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\n\npublic class Exercise0 implements Walkable {\n    String robotPosition = \"3,0\";\n\n    @Override\n    public String walk(String walkCommandString) {\n        int xMax = 11;\n        int yMax = 7;\n        Boolean theBreak = false;\n\n        int commandsAmount = walkCommandString.length();\n\n        String[] verticalWallPostions = new String[]{\n                \"3,0\",\n                \"3,1\",\n                \"3,2\",\n                \"3,3\",\n                \"7,0\",\n                \"7,1\",\n                \"7,2\",\n        };\n        String[] horizontalWallPostions = new String[]{\n                \"4,3\",\n                \"5,3\",\n                \"6,3\",\n                \"7,3\",\n                \"1,4\",\n                \"2,4\",\n                \"3,4\",\n                \"4,4\",\n                \"5,4\",\n                \"6,4\",\n                \"7,4\",\n                \"8,4\",\n        };\n\n        if (walkCommandString.charAt(1) == 'n') {\n            StringBuilder intXRobotPosition = new StringBuilder();\n            StringBuilder intYRobotPosition = new StringBuilder();\n            StringBuilder integerString = new StringBuilder();\n            for (int i = 4; i < walkCommandString.length() - 1; i++) {\n                integerString.append(walkCommandString.charAt(i));\n            }\n            int steps = Integer.parseInt(integerString.toString());\n            for (int i = 2; i < robotPosition.length(); i++) {\n                intYRobotPosition.append(robotPosition.charAt(i));\n            }\n            int robotYPosition = Integer.parseInt(intYRobotPosition.toString());\n            if (robotPosition.charAt(1) == ',') {\n                intXRobotPosition.append(robotPosition.charAt(0));\n            } else {\n                intXRobotPosition.append(robotPosition.charAt(0));\n                intXRobotPosition.append(robotPosition.charAt(1));\n            }\n            int robotXPosition = Integer.parseInt(intXRobotPosition.toString());\n\n\n            for (int j = 1; j <= steps; j++) {\n                int temp = robotYPosition + 1;\n                String tempString = robotXPosition + \",\" + temp;\n                for (String horizontalWallPostion : horizontalWallPostions) {\n                    if (tempString.equals(horizontalWallPostion)) {\n                        theBreak = true;\n\n                    }\n                }\n                if (temp <= yMax && !theBreak) {\n                    robotYPosition += 1;\n                } else {\n                    break;\n                }\n            }\n            robotPosition = +robotXPosition + \",\" + robotYPosition;\n\n        }\n        if (walkCommandString.charAt(1) == 'e') {\n            StringBuilder intXRobotPosition = new StringBuilder();\n            StringBuilder intYRobotPosition = new StringBuilder();\n            StringBuilder integerString = new StringBuilder();\n            for (int i = 4; i < walkCommandString.length() - 1; i++) {\n                integerString.append(walkCommandString.charAt(i));\n            }\n            int steps = Integer.parseInt(integerString.toString());\n            for (int i = 2; i < robotPosition.length(); i++) {\n                intYRobotPosition.append(robotPosition.charAt(i));\n            }\n            int robotYPosition = Integer.parseInt(intYRobotPosition.toString());\n            if (robotPosition.charAt(1) == ',') {\n                intXRobotPosition.append(robotPosition.charAt(0));\n            } else {\n                intXRobotPosition.append(robotPosition.charAt(0));\n                intXRobotPosition.append(robotPosition.charAt(1));\n            }\n            int robotXPosition = Integer.parseInt(intXRobotPosition.toString());\n\n            for (int j = 1; j <= steps; j++) {\n                int temp = robotXPosition + 1;\n                String tempString = temp + \",\" + robotYPosition;\n                for (String verticalWallPostion : verticalWallPostions) {\n                    if (tempString.equals(verticalWallPostion)) {\n                        theBreak = true;\n\n                    }\n                }\n                if (temp <= xMax && !theBreak) {\n                    robotXPosition += 1;\n                } else {\n                    break;\n                }\n            }\n            robotPosition = +robotXPosition + \",\" + robotYPosition;\n\n        }\n        if (walkCommandString.charAt(1) == 's') {\n            StringBuilder intXRobotPosition = new StringBuilder();\n            StringBuilder intYRobotPosition = new StringBuilder();\n            StringBuilder integerString = new StringBuilder();\n            for (int i = 4; i < walkCommandString.length() - 1; i++) {\n                integerString.append(walkCommandString.charAt(i));\n            }\n            int steps = Integer.parseInt(integerString.toString());\n            for (int i = 2; i < robotPosition.length(); i++) {\n                intYRobotPosition.append(robotPosition.charAt(i));\n            }\n            int robotYPosition = Integer.parseInt(intYRobotPosition.toString());\n            if (robotPosition.charAt(1) == ',') {\n                intXRobotPosition.append(robotPosition.charAt(0));\n            } else {\n                intXRobotPosition.append(robotPosition.charAt(0));\n                intXRobotPosition.append(robotPosition.charAt(1));\n            }\n            int robotXPosition = Integer.parseInt(intXRobotPosition.toString());\n\n            for (int j = 1; j <= steps; j++) {\n                int temp = robotYPosition - 1;\n                String tempString = robotXPosition + \",\" + temp;\n                for (String horizontalWallPostion : horizontalWallPostions) {\n                    if (tempString.equals(horizontalWallPostion)) {\n                        theBreak = true;\n                        robotYPosition -= 1;\n\n                    }\n                }\n                if (temp >= 0 && !theBreak) {\n                    robotYPosition -= 1;\n                } else {\n                    break;\n                }\n            }\n            robotPosition = +robotXPosition + \",\" + robotYPosition;\n\n        }\n        if (walkCommandString.charAt(1) == 'w') {\n            StringBuilder intXRobotPosition = new StringBuilder();\n            StringBuilder intYRobotPosition = new StringBuilder();\n            StringBuilder integerString = new StringBuilder();\n            for (int i = 4; i < walkCommandString.length() - 1; i++) {\n                integerString.append(walkCommandString.charAt(i));\n            }\n            int steps = Integer.parseInt(integerString.toString());\n            for (int i = 2; i < robotPosition.length(); i++) {\n                intYRobotPosition.append(robotPosition.charAt(i));\n            }\n            int robotYPosition = Integer.parseInt(intYRobotPosition.toString());\n            if (robotPosition.charAt(1) == ',') {\n                intXRobotPosition.append(robotPosition.charAt(0));\n            } else {\n                intXRobotPosition.append(robotPosition.charAt(0));\n                intXRobotPosition.append(robotPosition.charAt(1));\n            }\n            int robotXPosition = Integer.parseInt(intXRobotPosition.toString());\n\n            for (int j = 1; j <= steps; j++) {\n                int temp = robotXPosition - 1;\n                String tempString = temp + \",\" + robotYPosition;\n                for (String verticalWallPostion : verticalWallPostions) {\n                    if (tempString.equals(verticalWallPostion)) {\n                        theBreak = true;\n                        robotXPosition -= 1;\n\n                    }\n                }\n                if (temp >= 0 && !theBreak) {\n                    robotXPosition -= 1;\n                } else {\n                    break;\n                }\n            }\n            robotPosition = +robotXPosition + \",\" + robotYPosition;\n\n\n        }\n\n\n        return \"(\" + robotPosition + \")\";\n    }\n}\n\n\n\n"}, {"source": "student", "name": "student80", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walk(String walkCommandString);\n}\n"}, {"source": "student", "name": "student82", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n\n\n    int px = 5;\n    int py = 3;\n    String[] mO = {\"(1,6)\",\"(2,6)\",\"(3,6)\",\"(4,6)\",\"(5,6)\",\"(3,3)\",\"(4,3)\",\"(5,3)\",\"(6,3)\",\"(7,3)\",\"(8,3)\"};\n    String[] mU = {\"(1,5)\",\"(2,5)\",\"(3,5)\",\"(4,5)\",\"(5,5)\",\"(3,2)\",\"(4,2)\",\"(5,2)\",\"(6,2)\",\"(7,2)\",\"(8,2)\"};\n    String[] mL = {\"(5,7)\",\"(5,6)\",\"(5,5)\",\"(5,4)\",\"(5,3)\",\"(5,2)\",\"(3,2)\",\"(3,1)\"};\n    String[] mR = {\"(6,7)\",\"(6,6)\",\"(6,5)\",\"(6,4)\",\"(6,3)\",\"(6,2)\",\"(4,2)\",\"(4,1)\"};\n\n\n\n    public String getDirection(String moveCommandString) {\n        return  moveCommandString.substring(1,3);\n\n    }\n\n    public int getPower(String moveCommandString) {\n        int i = moveCommandString.length();\n        return  Integer.parseInt(moveCommandString.substring(4,i-1));\n\n    }\n\n    @Override\n    public String move(String moveCommandString) {\n        System.out.println(moveCommandString);\n\n        int power = getPower(moveCommandString);\n        String direction = getDirection(moveCommandString);\n\n        for(int i = 0; i<power; i++){\n            if(py == 0 && direction.equals(\"so\")) {direction = \"\";}\n            if(py == 7 && direction.equals(\"no\")) {direction = \"\";}\n            if(px == 0 && direction.equals(\"we\")) {direction = \"\";}\n            if(px == 11 && direction.equals(\"ea\")) {direction = \"\";}\n\n            for (String s : mU) {\n                if (direction.equals(\"so\") && s.equals(\"(\"+px+\",\"+(py-1)+\")\")){\n                    direction = \"\";\n                    break;\n                }\n            }\n\n\n            for (String s : mO) {\n                if (direction.equals(\"no\") && s.equals(\"(\"+px+\",\"+(py+1)+\")\")){\n                    direction = \"\";\n                    break;\n                }\n            }\n\n\n            for (String s : mL) {\n                if (direction.equals(\"we\") && s.equals(\"(\"+(px-1)+\",\"+py+\")\")) {\n                    direction = \"\";\n                    break;\n                }\n            }\n\n            for (String s : mR) {\n                if (direction.equals(\"ea\") && s.equals(\"(\"+(px+1)+\",\"+py+\")\")){\n                    direction = \"\";\n                    break;\n                }\n            }\n\n\n            switch(direction){\n                case \"no\":\n                    py = py +1;\n                    break;\n                case \"ea\":\n                    px = px +1;\n                    break;\n                case \"so\":\n                    py = py -1;\n                    break;\n                case \"we\":\n                    px = px -1;\n                    break;\n                default:\n\n                    break;\n            }\n        }\n\n\n        System.out.println(px);\n        System.out.println(py);\n        return \"(\"+px+\",\"+py+\")\";\n    }\n\n    \n}\n"}, {"source": "student", "name": "student82", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "student", "name": "student83", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.ArrayList;\n\npublic class Exercise0 implements Walkable {\n    int x=11;\n    int y=7;\n    @Override\n    public String walkTo(String walkCommandString) {\n\n        String movement=walkCommandString.substring(1,walkCommandString.length()-1);\n        String[] walking=movement.split(\",\");\n        String direction=walking[0];\n        int steps= Integer.parseInt(walking[1]);\n\n        switch (direction){\n            case \"no\":\n                //1)\n                if (0<=x && x<=4 && 0<=y && y<=7){\n                    if ( (y+steps)>7)\n                        y=7;\n                    else\n                        y+=steps;\n                }\n                //2)\n                if (x==5 && 0<=y && y<=4){\n                    if ((y+steps)>4)\n                        y=4;\n                    else\n                        y+=steps;\n                }\n                //3)\n                if (x==5 && y==5){\n                    y=5;\n                }\n                //4)\n                if (6<=x && x<=11 && 0<=y && y<=5){\n                    if ((y+steps)>5)\n                        y=5;\n                    else\n                        y+=steps;\n                }\n                //5)\n                if (x>=5 &&x<=11 && y>=6 &&y<=7){\n                    if ((y+steps)>7)\n                        y=7;\n                    else\n                        y+=steps;\n                }break;\n\n            case \"so\":\n\n                if (0<=x && x<=4 && 0<=y && y<=7){\n                    if ( (y-steps)<0)\n                        y=0;\n                    else\n                        y-=steps;\n                }\n\n                if (x==5 && 0<=y && y<=4){\n                    if ((y-steps)<0)\n                        y=0;\n                    else\n                        y-=steps;\n                }\n\n                if (x==5 && y==5){\n                    y=5;\n                }\n\n                if (6<=x && x<=11 && 0<=y && y<=5){\n                    if ((y-steps)<0)\n                        y=0;\n                    else\n                        y-=steps;\n                }\n                //5)\n                if (x>=5 &&x<=11 && y>=6 &&y<=7){\n                    if ((y-steps)<6)\n                        y=6;\n                    else\n                        y-=steps;\n                }break;\n            case \"ea\":\n\n                if (0<=x && x<=11 && (y==6 || y==7 ||y==0 || y==1)){\n                    if ( (x+steps)>11)\n                        x=11;\n                    else\n                        x+=steps;\n                }\n\n                if (y==5 && 0<=x && x<=4){\n                    if ((x+steps)>4)\n                        x=4;\n                    else\n                        x+=steps;\n                }\n                if ((y==4||y==3||y==2) && 0<=x && x<=5){\n                    if ((x+steps)>5)\n                        x=5;\n                    else\n                        x+=steps;\n                }\n                if (5<=x&&x>=11 && y==5){\n                    if ((x+steps)>11)\n                        x=11;\n                    else\n                        x+=steps;\n                }\n                if (6<=x&&x>=11 && 0<=y&&y<=4){\n                    if ((x+steps)>11)\n                        x=11;\n                    else\n                        x+=steps;\n                }\n                break;\n            case \"we\":\n\n                if (0<=x && x<=11 && (y==6 || y==7 ||y==0 || y==1)){\n                    if ( (x-steps)<0)\n                        x=0;\n                    else\n                        x-=steps;\n                }\n                //2)\n                if (y==5 && 0<=x && x<=4){\n                    if ((x-steps)<0)\n                        x=0;\n                    else\n                        x-=steps;\n                }\n                if ((y==4||y==3||y==2) && 0<=x && x<=5){\n                    if ((x-steps)<0)\n                        x=0;\n                    else\n                        x-=steps;\n                }\n                if (5<=x&&x>=11 && y==5){\n                    if ((x-steps)<5)\n                        x=5;\n                    else\n                        x-=steps;\n                }\n                if (6<=x&&x>=11 && 0<=y&&y<=4){\n                    if ((x-steps)<6)\n                        x=6;\n                    else\n                        x-=steps;\n                }\n                break;\n        }\n        return \"(\" + this.x+\",\"+ this.y+ \")\" ;\n    }\n}"}, {"source": "student", "name": "student83", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}"}, {"source": "student", "name": "student84", "file_name": "Barrier.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Barrier {\n    Coordinate start;\n    Coordinate end;\n\n    public Barrier(Coordinate start, Coordinate end) {\n        this.start = start;\n        this.end = end;\n    }\n}\n"}, {"source": "student", "name": "student84", "file_name": "Coordinate.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Coordinate {\n    int x;\n    int y;\n\n    public Coordinate(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public String toString() {\n        return \"(\" + this.x + \",\" + this.y + \")\";\n    }\n}\n"}, {"source": "student", "name": "student84", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport com.sun.istack.Nullable;\n\nimport java.util.Arrays;\n\npublic class Exercise0 implements Walkable {\n\n    Coordinate robotPosition = new Coordinate(1, 7);\n    Barrier[] barriers = {\n            new Barrier(new Coordinate(0,0), new Coordinate(12, 0)),\n            new Barrier(new Coordinate(0, 0), new Coordinate(0, 9)),\n            new Barrier(new Coordinate(0, 9), new Coordinate(12, 9)),\n            new Barrier(new Coordinate(12, 0), new Coordinate(12, 9)),\n            new Barrier(new Coordinate(3, 3), new Coordinate(3, 9)),\n            new Barrier(new Coordinate(3, 3), new Coordinate(5, 3)),\n            new Barrier(new Coordinate(5, 0), new Coordinate(5, 2)),\n            new Barrier(new Coordinate(6, 0), new Coordinate(6, 4))\n    };\n\n    public Barrier[] getHorizontalBarriers() {\n       return Arrays.stream(this.barriers).filter(barrier -> barrier.start.y == barrier.end.y).toArray(Barrier[]::new);\n    }\n\n    public Barrier[] getVerticalBarriers() {\n        return Arrays.stream(this.barriers).filter(barrier -> barrier.start.x == barrier.end.x).toArray(Barrier[]::new);\n    }\n\n    public enum Direction {\n        no,\n        ea,\n        so,\n        we\n    }\n\n    @Override\n    public String walk(String walkCommandString) {\n        String[] walkCommands = walkCommandString.replace(\"[\", \"\").replace(\"]\", \"\").split(\",\");\n        Direction direction = Direction.valueOf(walkCommands[0]);\n        int steps = Integer.parseInt(walkCommands[1]);\n\n        Coordinate newPosition = new Coordinate(robotPosition.x, robotPosition.y);\n\n        switch (direction) {\n            case no:\n                newPosition.y += steps;\n                break;\n            case ea:\n                newPosition.x += steps;\n                break;\n            case so:\n                newPosition.y -= steps;\n                break;\n            case we:\n                newPosition.x -= steps;\n                break;\n        }\n\n        Coordinate wallCoordinateBetween = coordinateOfBarrierBetween(robotPosition, newPosition);\n\n        if(wallCoordinateBetween != null) {\n            newPosition = wallCoordinateBetween;\n            if (direction == Direction.ea) {\n                newPosition.x--;\n            } else if (direction == Direction.no) {\n                newPosition.y--;\n            }\n        }\n\n        this.robotPosition = newPosition;\n\n        System.out.println(\"Set robot position to \" + this.robotPosition.toString());\n        return this.robotPosition.toString();\n    }\n\n    @Nullable\n    public Coordinate coordinateOfBarrierBetween(Coordinate start, Coordinate end) {\n        if(start.x == end.x) {\n            // vertical movement\n            if (start.y > end.y) {\n                Coordinate tmp = start;\n                start = end;\n                end = tmp;\n            }\n            for(Barrier barrier: this.getHorizontalBarriers()) {\n                if((barrier.start.y > start.y && barrier.start.y <= end.y)) {\n                    // There is a barrier between start and end. Now we have to check if it is in the direct path\n                    if((barrier.start.x <= start.x && barrier.end.x > start.x)) {\n                        System.out.println(\"Something Between \" + start.toString() + \" and \" + end.toString());\n                        System.out.println(\"Wall coordinates: \" + barrier.start.toString() + \", \" + barrier.end.toString());\n                        return new Coordinate(start.x, barrier.start.y);\n                    }\n                }\n            }\n        } else {\n            // horizontal movement\n            if (start.x > end.x) {\n                Coordinate tmp = start;\n                start = end;\n                end = tmp;\n            }\n            for(Barrier barrier: this.getVerticalBarriers()) {\n                if((barrier.start.x > start.x && barrier.start.x <= end.x)) {\n                    // There is a barrier between start and end. Now we have to check if it is in the direct path\n                    if((barrier.start.y <= start.y && barrier.end.y > start.y)) {\n                        System.out.println(\"Something Between \" + start.toString() + \" and \" + end.toString());\n                        System.out.println(\"Wall coordinates: \" + barrier.start.toString() + \", \" + barrier.end.toString());\n                        return new Coordinate(barrier.start.x, start.y);\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n}\n"}, {"source": "student", "name": "student84", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walk(String walkCommandString);\n}\n"}, {"source": "student", "name": "student85", "file_name": "Dam.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Dam {\n\n\n    Position from, to;\n\n    public Dam() {\n    }\n\n    public Dam(Position from, Position to) {\n        this.from = from;\n        this.to = to;\n    }\n\n    public Position getFrom() {\n        return from;\n    }\n\n    public void setFrom(Position from) {\n        this.from = from;\n    }\n\n    public Position getTo() {\n        return to;\n    }\n\n    public void setTo(Position to) {\n        this.to = to;\n    }\n}"}, {"source": "student", "name": "student85", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Exercise0 implements GoAble {\n\n    Position cleaningdvice;\n    int endof_x = 11, endof_y = 8;\n    List<Dam> damList = new ArrayList<>();\n    public Exercise0() {\n        cleaningdvice = new Position(1, 7);\n        Position damposition1 = new Position(3, 3);\n        Position damposition2 = new Position(3, 9);\n        Position damposition3 = new Position(5, 3);\n        Position damposition4 = new Position(5, 0);\n        Position damposition5 = new Position(5, 2);\n        Position damposition6 = new Position(6, 0);\n        Position damposition7 = new Position(6, 4);\n        damList.add(new Dam(damposition1, damposition2));\n        damList.add(new Dam(damposition1, damposition3));\n        damList.add(new Dam(damposition4, damposition5));\n        damList.add(new Dam(damposition6, damposition7));\n    }\n\n\n    String run_commend(String direction, int steps) {\n        switch (direction) {\n            case \"no\":\n                up_and_down(steps, 1);\n                break;\n            case \"so\":\n                up_and_down(steps, -1);\n                break;\n            case \"ea\":\n                right_and_left(steps,1);\n                break;\n            case \"we\":\n                right_and_left(steps,-1);\n                break;\n        }\n        return \"\";\n    }\n\n    private void right_and_left(int movment, int right_or_left) {\n        int right=0;if(right_or_left>0)right=1;\n        for (int i = 1; i <= movment; i++) {\n            boolean can_move = true;\n            if (cleaningdvice.getX() + right_or_left <= endof_x && cleaningdvice.getX() + right_or_left >= 0) {\n                for (Dam dam : damList) {\n                    if (dam.getFrom().getX() == dam.getTo().getX()) {\n                        if (cleaningdvice.getX()+right == dam.getFrom().getX() && cleaningdvice.getY() >= dam.getFrom().getY() && cleaningdvice.getY() < dam.getTo().getY()) {\n                            can_move = false;\n                            break;\n                        }\n                    }\n                }\n            }else can_move = false;\n            if (can_move) cleaningdvice.setX(cleaningdvice.getX()+right_or_left);\n            else break;\n        }\n    }\n\n\n\n    private void up_and_down(int movment, int up_or_down) {\n        int up=0;if(up_or_down>0)up=1;\n        for (int i = 1; i <= movment; i++) {\n            boolean can_move = true;\n            if (cleaningdvice.getY() + up_or_down <= endof_y && cleaningdvice.getY() + up_or_down >= 0) {\n                for (Dam dam : damList) {\n                    if (dam.getFrom().getY() == dam.getTo().getY()) {\n                        if (cleaningdvice.getY()+up == dam.getFrom().getY() && cleaningdvice.getX() >= dam.getFrom().getX() && cleaningdvice.getX() < dam.getTo().getX()) {\n                            can_move = false;\n                            break;\n                        }\n                    }\n                }\n            } else can_move = false;\n            if (can_move) cleaningdvice.setY(cleaningdvice.getY()+up_or_down);\n            else break;\n        }\n    }\n\n\n    @Override\n    public String goTo(String walkCommandString) {\n        String newcommand[]=walkCommandString.replace(\"[\",\"\").replace(\"]\",\"\").split(\",\");\n        String direction=newcommand[0];\n        int steps =Integer.parseInt(newcommand[1]);\n\n\n\n        run_commend(direction,steps);\n        return cleaningdvice.toString();\n    }\n\n\n\n}\n"}, {"source": "student", "name": "student85", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "student", "name": "student85", "file_name": "Position.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Position {\n\n\n    int x,y;\n\n    public Position() {\n    }\n\n    public Position(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public void setX(int x) {\n        this.x = x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public void setY(int y) {\n        this.y = y;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + x +\",\" + y +')';\n    }\n}\n\n"}, {"source": "student", "name": "student86", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass Coord {\n    public Coord (Integer x, Integer y) {\n        this.x = x;\n        this.y = y;\n    }\n    public Integer x, y;\n\n    public Integer pathLength (Coord target) {\n        return  Math.abs(x - target.x) +\n                Math.abs(y - target.y);\n    }\n}\n\nclass Obstacle {\n    public Obstacle (Coord start, Coord end) {\n        this.start = start;\n        this.end = end;\n    }\n    public Coord start, end;\n\n    public Boolean isHorizontal () { return start.y.equals(end.y); }\n    public Boolean isVertical () { return start.x.equals(end.x); }\n\n    public Integer possibleSteps (Coord pathStart, Coord pathEnd) {\n        // Vertikale Bewegung und horizontales Hindernis\n        if (pathStart.x.equals(pathEnd.x) && isHorizontal()) {\n            Integer pathLine = pathStart.x;\n            Integer obstLine = start.y;\n            Integer pathMin = Math.min(pathStart.y, pathEnd.y);\n            Integer pathMax = Math.max(pathStart.y, pathEnd.y);\n            Integer obstMin = Math.min(start.x, end.x);\n            Integer obstMax = Math.max(start.x, end.x);\n\n            if (pathLine >= obstMin && pathLine < obstMax &&\n                    pathMax >= obstLine && pathMin < obstLine) {\n                Integer steps = Math.abs(pathStart.y - obstLine);\n                return (pathStart.y < pathEnd.y) ? steps - 1 : steps;\n            }\n        }\n        // Horizontale Bewegung und vertikales Hindernis\n        else if (pathStart.y.equals(pathEnd.y) && isVertical()) {\n            Integer pathLine = pathStart.y;\n            Integer obstLine = start.x;\n            Integer pathMin = Math.min(pathStart.x, pathEnd.x);\n            Integer pathMax = Math.max(pathStart.x, pathEnd.x);\n            Integer obstMin = Math.min(start.y, end.y);\n            Integer obstMax = Math.max(start.y, end.y);\n\n            if (pathLine >= obstMin && pathLine < obstMax &&\n                    pathMax >= obstLine && pathMin < obstLine) {\n                Integer steps = Math.abs(pathStart.x - obstLine);\n                return (pathStart.x < pathEnd.x) ? steps - 1 : steps;\n            }\n        }\n\n        return pathStart.pathLength(pathEnd);\n    }\n}\n\nclass Space {\n    public Space (Integer width, Integer height) {\n        this.width = width;\n        this.height = height;\n        obstacles = new ArrayList<>();\n        cleanerPosition = new Coord(0,0);\n    }\n\n    Integer width, height;\n    List<Obstacle> obstacles;\n    Coord cleanerPosition;\n\n    public void addObstacle (Obstacle obstacle) {\n        obstacles.add(obstacle);\n    }\n\n    public void setCleanerPosition (Coord coord) {\n        cleanerPosition = coord;\n    }\n\n    public Coord moveCleaner (Integer horSteps, Integer verSteps) {\n        Coord destination = new Coord(\n                cleanerPosition.x + horSteps,\n                cleanerPosition.y + verSteps\n        );\n\n        destination.x = Math.min(width-1, Math.max(0, destination.x));\n        destination.y = Math.min(height-1, Math.max(0, destination.y));\n\n        Integer minSteps = cleanerPosition.pathLength(destination);\n\n        for (Obstacle o : obstacles) {\n            Integer possibleSteps = o.possibleSteps(cleanerPosition, destination);\n            minSteps = Math.min(minSteps, possibleSteps);\n        }\n\n        cleanerPosition = new Coord(\n                (int) (cleanerPosition.x + Math.signum(horSteps) * minSteps),\n                (int) (cleanerPosition.y + Math.signum(verSteps) * minSteps)\n        );\n\n        return cleanerPosition;\n    }\n}\n\npublic class Exercise0 implements Walkable {\n\n    public Exercise0 () {\n        space = new Space(11, 8);\n        space.addObstacle(new Obstacle(new Coord( 2, 1), new Coord(10 ,1)));\n        space.addObstacle(new Obstacle(new Coord( 2, 1), new Coord( 2 ,6)));\n        space.addObstacle(new Obstacle(new Coord(10 ,1), new Coord(10, 8)));\n        space.addObstacle(new Obstacle(new Coord( 2 ,6), new Coord( 7, 6)));\n\n        space.setCleanerPosition(new Coord( 7, 7));\n    }\n\n    Space space;\n\n    @Override\n    public String walk (String walkCommandString) {\n        String direction = walkCommandString.substring(1, 3);\n        int horSteps = 0, verSteps = 0;\n        int steps = Integer.parseInt(\n                walkCommandString.substring(4, walkCommandString.length() - 1)\n        );\n\n        switch (direction) {\n            case \"no\": verSteps = steps; break;\n            case \"ea\": horSteps = steps; break;\n            case \"so\": verSteps = -steps; break;\n            case \"we\": horSteps = -steps; break;\n            default:\n                return \"\";\n        }\n\n        Coord coord = space.moveCleaner(horSteps, verSteps);\n\n        return \"(\" + coord.x.toString() + \",\" + coord.y.toString() + \")\";\n    }\n}\n"}, {"source": "student", "name": "student86", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walk(String walkCommandString);\n}\n"}, {"source": "student", "name": "student89", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport javassist.bytecode.stackmap.BasicBlock;\n\nimport java.io.Console;\n\npublic class Exercise0 implements Moveable {\n\n    public static String [][] position = new String[11][8];\n    int xstart=7;\n    int ystart=7;\n    /*Wand1\n    String wall1_1=\"(9,1)-(9,7)\";\n    String wall2_1=\"(9,1)-(2,1)\";\n    String wall3_1=\"(2,1)-(2,5)\";\n    String wall4_1=\"(2,5)-(6,5)\";\n    Wand2\n    String wall1=\"(10,0)-(10,7)\";\n    String wall2=\"(10,0)-(1,0)\";\n    String wall3=\"(1,0)-(1,6)\";\n    String wall4=\"(1,6)-(6,6)\";*/\n\n\n    @Override\n    public String move(String moveCommandString) {\n        String direction=\"\"+moveCommandString.toCharArray()[1]+moveCommandString.toCharArray()[2]+\"\";\n        char c =(moveCommandString.charAt(4));\n        int moves= Integer.parseInt(moveCommandString.replaceAll(\"\\\\D\", \"\"));\n        System.out.println(moves);\n        Waendebauen();\n\n        int takensteps=0;\n        System.out.println(moves);\n\n        try {\n\n            if (direction.equals(\"no\")) {\n                if (moves>position[0].length-1-ystart)\n                {\n                    moves=position[0].length-1-ystart;\n                }\n\n                while (takensteps < moves) {\n                    if (position[xstart][ystart + takensteps] == \"Wand1\" && position[xstart][ystart + takensteps + 1] == \"Wand2\") {\n                        ystart = ystart + takensteps;\n                        return \"(\" + xstart + \",\" + ystart + \")\";\n                    }\n\n\n                    if (position[xstart][ystart + takensteps] == \"Wand2\" && position[xstart][ystart + takensteps + 1] == \"Wand1\") {\n                        ystart = ystart + takensteps;\n                        return \"(\" + xstart + \",\" + ystart + \")\";\n                    } else {\n                        takensteps += 1;\n                    }\n                }\n\n                    ystart = ystart + takensteps;\n\n                }\n\n            if (direction.equals(\"ea\")) {\n\n                if (moves>position.length-1-xstart)\n                {\n                    moves=position.length-1-xstart;\n                }\n                while (takensteps < moves ) {\n                    if (position[xstart + takensteps ][ystart] == \"Wand1\"&&position[xstart + takensteps + 1][ystart] == \"Wand2\")\n                    {\n                        xstart=xstart+takensteps;\n                        return \"(\" + xstart + \",\" + ystart + \")\";\n                    }\n                    if (position[xstart + takensteps ][ystart] == \"Wand2\"&&position[xstart + takensteps + 1][ystart] == \"Wand1\")\n                    {\n                        xstart=xstart+takensteps;\n                        return \"(\" + xstart + \",\" + ystart + \")\";\n                    }\n                    else{\n                        takensteps += 1;\n                    }\n                }\n                xstart = xstart + takensteps;\n\n            }\n            if (direction.equals(\"so\")) {\n\n                if (ystart-moves<0)\n                {\n                    moves=ystart;\n                }\n                while (takensteps < moves ) {\n                    if (position[xstart][ystart - takensteps ] == \"Wand1\"&&position[xstart][ystart - takensteps - 1] == \"Wand2\")\n                    {\n                        ystart = ystart - takensteps;\n                        return \"(\" + xstart + \",\" + ystart + \")\";\n                    }\n                    if (position[xstart][ystart - takensteps ] == \"Wand2\"&&position[xstart][ystart - takensteps - 1] == \"Wand1\")\n                    {\n                        ystart = ystart - takensteps;\n                        return \"(\" + xstart + \",\" + ystart + \")\";\n                    }\n\n                    else {\n                        takensteps += 1;\n                    }\n                }\n                ystart = ystart - takensteps;\n\n\n            }\n            if (direction.equals(\"we\")) {\n                if (xstart-moves<0)\n                {\n                    moves=xstart;\n                }\n\n                while (takensteps < moves ) {\n                    if (position[xstart - takensteps ][ystart] == \"Wand1\"&&position[xstart - takensteps - 1][ystart] == \"Wand2\")\n                    {\n                        xstart=xstart-takensteps;\n                        return \"(\" + xstart + \",\" + ystart + \")\";\n                    }\n                    if (position[xstart - takensteps ][ystart] == \"Wand2\"&&position[xstart - takensteps - 1][ystart] == \"Wand1\")\n                    {\n                        xstart=xstart-takensteps;\n                        return \"(\" + xstart + \",\" + ystart + \")\";\n                    }\n                    else\n                    {\n                        takensteps += 1;\n                    }\n                }\n                xstart = xstart - takensteps;\n\n            }\n            return \"(\" + xstart + \",\" + ystart + \")\";\n\n        } catch(java.lang.ArrayIndexOutOfBoundsException use)\n        {\n            switch (direction) {\n                case \"no\": ystart = ystart + takensteps;\n                    return \"(\" + xstart + \",\" + ystart + \")\";\n                case \"ea\": xstart = xstart + takensteps;\n                    return \"(\" + xstart + \",\" + ystart + \")\";\n                case \"so\": ystart = ystart - takensteps;\n                    return \"(\" + xstart + \",\" + ystart + \")\";\n                case \"we\": xstart = xstart - takensteps;\n                    return \"(\" + xstart + \",\" + ystart + \")\";\n            }\n            return \"(\" + xstart + \",\" + ystart + \")\";\n        }\n    }\n\n\n\n    public static void Waendebauen() {\n        //Wand1\n        String wall1_1=\"(9,1)-(9,7)\";\n        String wall2_1=\"(9,1)-(2,1)\";\n        String wall3_1=\"(2,1)-(2,5)\";\n        String wall4_1=\"(2,5)-(6,5)\";\n        //Wand2\n        String wall1=\"(10,0)-(10,7)\";\n        String wall2=\"(10,0)-(1,0)\";\n        String wall3=\"(1,0)-(1,6)\";\n        String wall4=\"(1,6)-(6,6)\";\n//wand 1\n        for (int j = 1; j <= 7; j++) {\n            position[9][j] = \"Wand1\";\n        }\n\n\n        for (int j = 2; j <= 9; j++) {\n            position[j][1] = \"Wand1\";\n        }\n\n\n        for (int j = 1; j <= 5; j++) {\n            position[2][j] = \"Wand1\";\n        }\n\n\n        for (int j = 2; j <= 6; j++) {\n            position[j][5] = \"Wand1\";\n        }\n\n\n\n\n\n        //wand 2\n        for (int j = 0; j <= 7; j++) {\n            position[10][j] = \"Wand2\";\n        }\n\n\n        for (int j = 1; j <= 10; j++) {\n            position[j][0] = \"Wand2\";\n        }\n\n\n        for (int j = 0; j <= 6; j++) {\n            position[1][j] = \"Wand2\";\n        }\n\n\n        for (int j = 1; j <= 6; j++) {\n            position[j][6] = \"Wand2\";\n        }\n\n\n    }public static void main(String[] args) {\n        Waendebauen();\n        System.out.println(position[1][1]);\n\n      /*  for ( int zeile = 0; zeile < position.length; zeile++ )\n        {\n            System.out.print(\"Zeile \" + zeile + \": \");\n            for ( int spalte=0; spalte < position[zeile].length; spalte++ )\n                System.out.print( position[zeile][spalte] + \" \");\n            System.out.println();\n\n        }*/\n\n\n    }\n\n\n}\n"}, {"source": "student", "name": "student89", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String move(String moveCommandString);\n}\n"}, {"source": "student", "name": "student90", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Exercise0 implements Walkable {\n\n    //initialisieren und deklarieren der Startwerte x und y\n    private int x = 4;\n    private int y = 0;\n\n    //Initialiesieren der Barrieren als listen\n    private List<String> firstBarrier = Arrays.asList(\"(1,0)\", \"(1,1)\", \"(1,2)\", \"(1,3)\", \"(1,4)\", \"(1,5)\");\n    private List<String> secondBarrier = Arrays.asList(\"(1,6)\",\"(2,6)\", \"(3,6)\");\n    private List<String> thirdBarrier = Arrays.asList(\"(5,6)\",\"(6,6)\");\n    private List<String> fourthBarrier = Arrays.asList(\"(7,1)\", \"(7,2)\", \"(7,3)\", \"(7,4)\", \"(7,5)\");\n\n\n    //Implementierung der Methode walkTo()\n    @Override\n    public String walkTo(String walkCommandString) {\n        //throw new UnsupportedOperationException();\n\n\n        StringBuilder numberOfSteps = new StringBuilder();\n\n        String finalStringValue = \"(\"+ x + \",\" + y + \")\";\n\n\n\n        //pr\u00fcft die richtung in der der Bagger f\u00e4hrt\n        if(walkCommandString.contains(\"no\") || walkCommandString.contains(\"ea\") || walkCommandString.contains(\"so\")\n            || walkCommandString.contains(\"we\")){\n\n\n\n            //liest die Zahlen im string\n            for(char s : walkCommandString.toCharArray()){\n                if(Character.isDigit(s))\n                    numberOfSteps.append(s);\n\n            }\n            String stringSteps = numberOfSteps.toString();\n            int intSteps = Integer.parseInt(stringSteps);\n\n\n            if(walkCommandString.contains(\"no\")){   // wird ausgef\u00fchrt wenn der string 'no' enth\u00e4lt\n                if(intSteps == 0){return finalStringValue;}\n\n                if(intSteps == 1){\n                    y++;\n                    finalStringValue = \"(\" + x + \",\" + y + \")\";\n                    if(!secondBarrier.contains(finalStringValue) && !thirdBarrier.contains(finalStringValue)){\n                        return finalStringValue;\n                    }else{\n                        y--;\n                        finalStringValue = \"(\" + x + \",\" + y + \")\";\n                        return finalStringValue;\n                    }\n                }\n\n                y++;\n                finalStringValue = \"(\" + x + \",\" + y + \")\";\n                for(int i=0; i<intSteps-1; i++){\n                    if(!secondBarrier.contains(finalStringValue) && !thirdBarrier.contains(finalStringValue)){\n                        y++;\n                        finalStringValue = \"(\" + x + \",\" + y + \")\";\n                    } else {\n                        y--;\n                        finalStringValue = \"(\" + x + \",\" + y + \")\";\n                        break;\n                    }\n                }\n\n                if(y > 7){\n                    y=7;\n                    finalStringValue = \"(\" + x + \",\" + y + \")\";\n                }\n\n            } else if (walkCommandString.contains(\"so\")){   //wird ausgef\u00fchrt wenn der string so enth\u00e4lt\n\n                for(int iterator=0; iterator<intSteps; iterator++){\n                    if(!secondBarrier.contains(finalStringValue) && !thirdBarrier.contains(finalStringValue)){\n                        y--;\n                        finalStringValue = \"(\" + x + \",\" + y + \")\";\n                    } else\n                        break;\n                }\n\n                if(y<0){\n                    y=0;\n                    finalStringValue = \"(\" + x + \",\" + y + \")\";\n                }\n\n\n            } else if (walkCommandString.contains(\"ea\")){   // wird ausgef\u00fchrt wenn der string ea enth\u00e4lt\n                if(intSteps ==0){return finalStringValue;}\n\n                if(intSteps == 1){\n                    x++;\n                    finalStringValue = \"(\" + x + \",\" + y + \")\";\n                    if(!firstBarrier.contains(finalStringValue) && !fourthBarrier.contains(finalStringValue)){\n                        return finalStringValue;\n                    }else{\n                        x--;\n                        finalStringValue = \"(\" + x + \",\" + y + \")\";\n                        return finalStringValue;\n                    }\n                }\n\n                x++;\n                finalStringValue = \"(\" + x + \",\" + y + \")\";\n                for(int iterator=0; iterator<intSteps-1; iterator++){\n\n\n                    if(!firstBarrier.contains(finalStringValue) && !fourthBarrier.contains(finalStringValue)){\n                        x++;\n                        finalStringValue = \"(\" + x + \",\" + y + \")\";\n                    } else {\n                        x--;\n                        finalStringValue = \"(\" + x + \",\" + y + \")\";\n                        break;//\n                    }\n                }\n\n\n                if(x > 10){\n                    x=10;\n                    finalStringValue = \"(\" + x + \",\" + y + \")\";\n                }\n\n            } else if(walkCommandString.contains(\"we\")){ //Wird ausgef\u00fchrt, wenn der String 'we' enth\u00e4lt\n\n                for(int iterator=0; iterator<intSteps; iterator++){\n                    if(!firstBarrier.contains(finalStringValue) && !fourthBarrier.contains(finalStringValue)){\n                        x--;\n                        finalStringValue = \"(\" + x + \",\" + y + \")\";\n                    } else\n                        break;\n                }\n\n                if(x<0){\n                    x=0;\n                    finalStringValue = \"(\" + x + \",\" + y + \")\";\n                }\n            }\n\n\n        }\n\n\n        return finalStringValue;\n    }\n}\n"}, {"source": "student", "name": "student90", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "student", "name": "student92", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n\n    int startX = 1;\n    int startY = 7;\n\n    @Override\n    public String moveTo(String moveCommandString) {\n\n        int steps = moveCommandString.charAt(4) - '0';\n        String richtung = moveCommandString.substring(1,3);\n        int marker = 0;\n\n        switch(richtung){\n            case \"no\":\n                if (startY <= 2)\n                    marker = 1;\n                startY = startY + steps;\n                if (marker == 1 && startX == 3 && startY > 2)\n                    startY = 2;\n                if (marker == 1 && startX == 4 && startY > 2)\n                    startY = 2;\n                break;\n            case \"ea\":\n                if (startX <= 2 && startY >= 3) {\n                    startX = startX + steps;\n                    if (startX >= 3)\n                        startX = 2;\n                    break;\n                }\n                if (startX <= 4 && startY <= 1) {\n                    startX = startX + steps;\n                    if (startX >= 5)\n                        startX = 4;\n                    break;\n                }\n                if (startX <= 5 && startY <= 3) {\n                    startX = startX + steps;\n                    if (startX >= 6)\n                        startX = 5;\n                    break;\n                }\n                startX = startX + steps;\n                break;\n            case \"so\":\n                if (startY >= 3)\n                    marker = 1;\n                startY = startY - steps;\n                if (marker == 1 && startX == 3 && startY < 3)\n                    startY = 3;\n                if (marker == 1 && startX == 4 && startY < 3)\n                    startY = 3;\n                if (startY < 0)\n                    startY = 0;\n                break;\n            case \"we\":\n                if (startX >= 6 && startY <= 3) {\n                    startX = startX - steps;\n                    if (startX <= 5)\n                        startX = 6;\n                    break;\n                }\n                if (startX >= 5 && startY <= 1) {\n                    startX = startX - steps;\n                    if (startX <= 4)\n                        startX = 5;\n                    break;\n                }\n                if (startX >= 3 && startY >= 3) {\n                    startX = startX - steps;\n                    if (startX <= 2)\n                        startX = 3;\n                    break;\n                }\n                startX = startX - steps;\n                break;\n        }\n        return \"(\"+startX+\",\"+startY+\")\";\n    }\n}\n"}, {"source": "student", "name": "student92", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String moveTo(String moveCommandString);\n}\n"}, {"source": "student", "name": "student94", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\npublic class Exercise0 implements Walkable {\n    int x = 7;\n    int y = 7;\n    String initialPosition=\"(7,7)\";\n\n    String obstaclesAndWalls=\"(0,0)-(0,8),(11,0)-(11,8),(2,1)-(2,6),(10,1)-(10,8),(0,8)-(11,8),(0,0)-(11,0),(2,6)-(7,6),(2,1)-(10,1)\";\n\n    @Override\n    public String walkTo(String walkCommandString) {\n        // [no, 6]\n\n        String movement=walkCommandString.substring(1,walkCommandString.length()-1);\n        String[] walking=movement.split(\",\");\n        String directionMove=walking[0];\n        int stepToMove= Integer.parseInt(walking[1]);\n\n        switch (directionMove){\n            case \"no\":\n                if (x==0||x==1 || x==10){\n                    if ( (y+stepToMove)>7)\n                        y=7;\n                    else\n                        y+=stepToMove;\n                }\n                if (2<=x && x<=9 && y==0){\n                    y=0;\n                }\n\n                //top line\n                if (2<=x && x<=6 && 1<=y && y<=5){\n                    if ((y+stepToMove)>5)\n                        y=5;\n                    else\n                        y+=stepToMove;\n                }\n                if (7<=x && x<=9 && 1<=y){\n                    if ((y+stepToMove)>7)\n                        y=7;\n                    else\n                        y+=stepToMove;\n                }\n\n                if (2<=x && x<=6 && (y==6 || y==7)){\n                    if ((y+stepToMove)>7)\n                        y=7;\n                    else\n                        y+=stepToMove;\n                }break;\n\n            case \"so\":\n                if(x==0 || x==1 || x==10){\n                    if ((y-stepToMove)<0)\n                        y=0;\n                    else\n                        y-=stepToMove;\n                }\n                //Bottom line\n                if(2<=x && x<=9 && y==0){\n                        y=0;\n                }\n\n                if(2<=x && x<=6 && (1<=y && y<=5)){\n                    if ((y-stepToMove)<1)\n                        y=1;\n                    else\n                        y-= stepToMove;\n                 }\n\n                //top\n                if(7<=x && x<=9 && 1<=y){\n                    if ((y-stepToMove)<1)\n                        y=1;\n                    else\n                        y-= stepToMove;\n                }\n                if(2<=x && x<=6 && 6<=y){\n                    if ((y-stepToMove)<6)\n                        y=6;\n                    else\n                        y-= stepToMove;\n                }break;\n\n            case \"ea\":\n                if ((x==0 || x==1) && 1<=y && y<=5){\n                    if ((x+stepToMove)>1)\n                        x=1;\n                    else\n                        x+=stepToMove;\n                }\n\n                //secondline\n                if (2<=x && x<=9 && 1<=y && y<=5){\n                    if ((x+stepToMove)>9)\n                        x=9;\n                    else\n                        x+=stepToMove;\n                }\n                if (0<=x && x<=9 && 6<=y){\n                    if ((x+stepToMove)>9)\n                        x=9;\n                    else\n                        x+=stepToMove;\n                }\n                if (x==10 ){\n                    x=10;\n                }\n\n                if (y==0){\n                    if ((x+stepToMove)>10)\n                        x=10;\n                    else\n                        x+=stepToMove;\n                }break;\n\n            case \"we\":\n                //2ndWvertical\n                if (9<x && 1<=y){\n                    x=10;\n                }\n                if (2<=x && x<= 9 && 1<=y && y<=5){\n                    if((x-stepToMove)<2)\n                        x=2;\n                    else\n                        x-=stepToMove;\n                }\n                if (x<= 9 && 6<=y ){\n                    if((x-stepToMove)<0)\n                        x=0;\n                    else\n                        x-=stepToMove;\n                }\n\n                if ((x== 0 || x==1 )&& 1<=y && y<=5){\n                    if((x-stepToMove)<0)\n                        x=0;\n                    else\n                        x-=stepToMove;\n                }\n\n                if (y==0 ){\n                    if((x-stepToMove)<0)\n                        x=0;\n                    else\n                        x-=stepToMove;\n                }break;\n        }\n\n        return \"(\" + this.x+\",\"+ this.y+ \")\" ;\n    }\n}\n"}, {"source": "student", "name": "student94", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n\n}\n"}, {"source": "student", "name": "student96", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements GoAble {\n\n    //Initialize coordinates x+y and distance d\n    int[][][] horizontalBarriers = {\n            {{-1, -1}, {10, -1}},\n            {{-1, 7}, {10, 7}},\n            {{-1, 5}, {1, 5}},\n            {{1, 4}, {8, 4}}\n    };\n\n    int[][][] verticalBarriers = {\n            {{-1, -1}, {-1, 7}},\n            {{10, -1}, {10, 7}},\n            {{2, 6}, {2, 7}},\n            {{8, 1}, {8, 4}}\n    };\n\n    int x = 1;\n    int y = 6;\n\n\n\n    public String barrierDetected(){\n        //System.out.println(\"Barrier detected\");\n        //System.out.println( currentPosition() + \" abort mission\");\n        return currentPosition();\n    }\n\n    public String step(int steps, int i){\n        //System.out.println(\"Steps \" + (steps - i) +\" left\");\n        //System.out.println(\"New position \" + currentPosition());\n        return currentPosition();\n    }\n\n    public String currentPosition(){\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n\n    @Override\n    public String goTo(String goCommandString) {\n        System.out.println(goCommandString);\n       int steps = Integer.parseInt(goCommandString.replaceAll(\"[^0-9]\", \"\"));\n\n        // Determine direction in if statement\n\n        // going up\n        if (goCommandString.contains(\"no\")) {\n\n            //Make a step while i < steps\n            for (int i = 0; i < steps; i++) {\n\n                // Check Barriers\n\n                // Iterate over barriers\n                for (int[][] horizontalBarrier : horizontalBarriers) {\n                    //System.out.println(\"Check for barrier: \" + j + \" at \" + currentPosition());\n                    // Check if y Position is at hight of a barrier\n                    if (y == horizontalBarrier[0][1]) {\n                        // Check if x position is in between start and end of barrier\n                        if (horizontalBarrier[0][0] <= x && x <= horizontalBarrier[1][0]) {\n                            return barrierDetected();\n                        }\n                    }\n                }\n                y++;\n                step(steps, i );\n            }\n            return currentPosition();\n\n        } else if (goCommandString.contains(\"so\")) {\n            //Make a step while d\n            for (int i = 0; i < steps; i++) {\n\n                // Check Barriers\n\n                // Iterate over barriers\n                for (int[][] horizontalBarrier : horizontalBarriers) {\n                    //System.out.println(\"Check for barrier: \" + j + \" at \" + currentPosition());\n\n                    // Check if y Position is at hight of a barrier\n                    if (y == horizontalBarrier[0][1] + 1) {\n                        // Check if x position is in between start and end of barrier\n                        if (horizontalBarrier[0][0] <= x && x <= horizontalBarrier[1][0]) {\n                            return barrierDetected();\n                        }\n                    }\n                }\n                y--;\n                step(steps, i );\n            }\n            return currentPosition();\n\n\n        } else if (goCommandString.contains(\"ea\")) {\n            //System.out.println(\"Going RIGHT from \" + currentPosition());\n            //Make a step while i < steps\n            for (int i = 0; i < steps; i++) {\n\n                // Check Barriers\n\n                // Iterate over barriers\n                for (int[][] verticalBarrier : verticalBarriers) {\n                    //System.out.println(\"Check for barrier: \" + j + \" at \" + currentPosition());\n\n                    // Check if x Position is at hight of a barrier\n\n                    if (x == verticalBarrier[0][0] && x != 0) {\n                        // Check if y position is in between start and end of barrier\n                        if (verticalBarrier[0][1] <= y && y <= verticalBarrier[1][1]) {\n                            return barrierDetected();\n                        }\n                    }\n                }\n                // Make a step\n                x++;\n                step(steps, i);\n            }\n            return currentPosition();\n\n\n        // Go LEFT\n        } else if (goCommandString.contains(\"we\")) {\n            //System.out.println(\"Going LEFT from \" + currentPosition());\n            for (int i = 0; i < steps; i++) {\n\n                // Check Barriers\n\n                // Iterate over barriers\n                for (int[][] verticalBarrier : verticalBarriers) {\n\n                    // Check if x Position is at hight of a barrier\n                    if (x == verticalBarrier[0][0] + 1) {\n                        //System.out.println(\"Check for barrier: \" + i);\n                        // Check if y position is in between start and end of barrier\n                        if (verticalBarrier[0][1] <= y && y <= verticalBarrier[1][1]) {\n                            return barrierDetected();\n                        }\n                    }\n                }\n                // Make a step\n                x--;\n                step(steps, i);\n            }\n            return currentPosition();\n        }\n\n        return currentPosition();\n\n\n    }\n\n\n}"}, {"source": "student", "name": "student96", "file_name": "GoAble.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface GoAble {\n    String goTo(String goCommandString);\n}\n"}, {"source": "student", "name": "student97", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\n\npublic class Exercise0 implements Walkable {\n    int[] currentPosition = new int[] {1,7};\n    int[][] obstacles = new int[][] {\n        // vertical     0,x,x,y,y\n        // horizontal   1,y,y,x,x\n        {0,2,3,3,9},\n        {0,5,6,0,3},\n        {0,4,5,0,1},\n        {0,-1,0,0,9},\n        {0,12,13,0,9},\n        {1,2,3,3,4},\n        {1,-1,0,0,12},\n        {1,9,10,0,12}\n    };\n\n\n    @Override\n    public String walkTo(String walkCommandString) {\n\n        String direction = walkCommandString.split(\",\")[0].replace(\"[\", \"\");\n        int steps = Integer.parseInt(walkCommandString.split(\",\")[1].replace(\"]\", \"\"));\n\n\n        moveloop:\n        for(int i = 0; i < steps; i++) {\n\n\n            if(direction.equals(\"we\")) {\n                for(int a = 0; a < obstacles.length; a++) {\n                    if(\n                        // if obstacle is relevant for move\n                        (obstacles[a][0] == 0)\n                        // if current position is in range of obstacle\n                        && (currentPosition[1] >= obstacles[a][3] && currentPosition[1] <= obstacles[a][4])\n                        // if collision is ahead\n                        && (currentPosition[0] == obstacles[a][2])\n                    ) break moveloop;\n                }\n\n                currentPosition[0]--;\n            }\n\n\n            else if(direction.equals(\"ea\")) {\n                for(int a = 0; a < obstacles.length; a++) {\n                    if(\n                        (obstacles[a][0] == 0)\n                        && (currentPosition[1] >= obstacles[a][3] && currentPosition[1] <= obstacles[a][4])\n                        && (currentPosition[0] == obstacles[a][1])\n                    ) break moveloop;\n                }\n\n                currentPosition[0]++;\n            }\n            \n\n            else if(direction.equals(\"no\")) {\n                for(int a = 0; a < obstacles.length; a++) {\n                    if(\n                        (obstacles[a][0] == 1)\n                        && (currentPosition[0] >= obstacles[a][3] && currentPosition[0] <= obstacles[a][4])\n                        && (currentPosition[1] == obstacles[a][1])\n                    ) break moveloop;\n                }\n\n                currentPosition[1]++;\n            }\n\n\n            else if(direction.equals(\"so\")) {\n                for(int a = 0; a < obstacles.length; a++) {\n                    if(\n                        (obstacles[a][0] == 1)\n                        && (currentPosition[0] >= obstacles[a][3] && currentPosition[0] <= obstacles[a][4])\n                        && (currentPosition[1] == obstacles[a][2])\n                    ) break moveloop;\n                }\n\n                currentPosition[1]--;\n            }\n        }\n        \n        System.out.println(walkCommandString);\n        System.out.println(\"current Position: (\" + currentPosition[0] + \",\" + currentPosition[1] + \")\");\n        return \"(\" + currentPosition[0] + \",\" + currentPosition[1] + \")\";\n    }\n}"}, {"source": "student", "name": "student97", "file_name": "Walkable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Walkable {\n    String walkTo(String walkCommandString);\n}\n"}, {"source": "student", "name": "student98", "file_name": "AbstractMove.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nabstract public class AbstractMove {\n\n    abstract public Position moveUntilBlocked(Matrix Coordinates, Position position, int length);\n\n    protected Boolean validateStep(Matrix Coordinates, Position position, Orientation orientation) {\n        return Coordinates.validatePosition(position, orientation);\n    }\n}\n"}, {"source": "student", "name": "student98", "file_name": "CommandParser.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport lombok.Getter;\n\npublic class CommandParser {\n\n    @Getter\n    private Orientation orientation;\n\n    @Getter\n    private Integer stepLength;\n\n    private CommandParser(Orientation orientation, Integer stepLength) {\n        this.orientation = orientation;\n        this.stepLength = stepLength;\n    }\n\n    public static CommandParser StringToCommand(String command) {\n        int stepLength;\n        Orientation orientation;\n        String commandNoBraces = command.replaceAll(\"[\\\\[\\\\]]\", \"\");\n        String[] commandSplit = commandNoBraces.split(\",\");\n\n        switch (commandSplit[0]) {\n            case \"no\": orientation = Orientation.NO; break;\n            case \"ea\": orientation = Orientation.EA; break;\n            case \"so\": orientation = Orientation.SO; break;\n            case \"we\": orientation = Orientation.WE; break;\n            default: orientation = null;\n        }\n        stepLength = Integer.parseInt(commandSplit[1]);\n        return new CommandParser(orientation, stepLength);\n    }\n}\n"}, {"source": "student", "name": "student98", "file_name": "Exercise0.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Exercise0 implements Moveable {\n\n    private Position CurrentPos;\n    private Matrix Coordinates;\n\n    public Exercise0() {\n        this.CurrentPos = new Position(8, 3);\n        this.Coordinates = Matrix.createMatrix();\n    }\n\n    @Override\n    public String moveTo(String moveCommandString) {\n        AbstractMove Move = null;\n        CommandParser Command = CommandParser.StringToCommand(moveCommandString);\n\n//        System.out.println(CurrentPos);\n\n        switch (Command.getOrientation()) {\n            case NO: Move = new MoveNorth();    break;\n            case EA: Move = new MoveEast();     break;\n            case SO: Move = new MoveSouth();    break;\n            case WE: Move = new MoveWest();     break;\n        }\n        CurrentPos = Move.moveUntilBlocked(Coordinates, CurrentPos, Command.getStepLength());\n\n//        System.out.println(moveCommandString);\n//        System.out.println(CurrentPos.toString());\n//        System.out.println(\"\");\n        return CurrentPos.toString();\n    }\n}\n"}, {"source": "student", "name": "student98", "file_name": "Matrix.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class Matrix {\n\n    private final Boolean[][] matrix;\n    private final int xLen;\n    private final int yLen;\n\n    private Matrix(Boolean[][] matrix, int xLen, int yLen) {\n        this.matrix = matrix;\n        this.xLen = xLen;\n        this.yLen = yLen;\n    }\n\n    public static Matrix createMatrix() {\n        int xLen = 13;\n        int yLen = 10;\n        Boolean[][] matrix = new Boolean[xLen][yLen];\n        for (int i = 0; i < xLen; i++) {\n            for (int j = 0; j < yLen; j++) {\n                matrix[i][j] = false;\n            }\n        }\n            matrix[4][1] = true;\n            matrix[4][2] = true;\n            matrix[4][3] = true;\n            matrix[4][4] = true;\n            matrix[4][5] = true;\n            matrix[4][6] = true;\n            matrix[4][7] = true;\n\n            matrix[6][2] = true;\n            matrix[7][2] = true;\n            matrix[8][2] = true;\n            matrix[9][2] = true;\n\n            matrix[6][2] = true;\n            matrix[6][3] = true;\n            matrix[6][4] = true;\n            matrix[6][5] = true;\n\n            matrix[6][5] = true;\n            matrix[7][5] = true;\n            matrix[8][5] = true;\n            matrix[9][5] = true;\n        return new Matrix(matrix, xLen, yLen);\n    }\n\n    public Boolean validatePosition(Position newPosition, Orientation orientation) {\n        if (!validateOutOfBounds(newPosition))\n            return false;\n        if (!validateMovement(newPosition, orientation))\n            return false;\n        return true;\n    }\n\n    private Boolean validateOutOfBounds(Position newPosition) {\n        if (newPosition.getXPos() < 0)\n            return false;\n        if (newPosition.getXPos() >= xLen - 1)     // minus 1 because of tile definition\n            return false;\n        if (newPosition.getYPos() < 0)\n            return false;\n        if (newPosition.getYPos() >= yLen - 1)\n            return false;\n        return true;\n    }\n\n    private Boolean validateMovement(Position newPosition, Orientation orientation) {\n        switch (orientation) {\n            case NO: return validateNorthMovement(newPosition);\n            case EA: return validateEastMovement(newPosition);\n            case SO: return validateSouthMovement(newPosition);\n            case WE: return validateWestMovement(newPosition);\n        }\n        return false;\n    }\n\n    private Boolean validateNorthMovement(Position newPosition) {\n//        System.out.println(\"x: \" + newPosition.getXPos() + \", y: \" + newPosition.getYPos() + \", \" + matrix[newPosition.getXPos()][newPosition.getYPos()]);\n//        System.out.println(\"x: \" + (newPosition.getXPos() + 1) + \", y: \" + newPosition.getYPos() + \", \" + matrix[newPosition.getXPos() + 1][newPosition.getYPos()]);\n\n        if (matrix[newPosition.getXPos()][newPosition.getYPos()]) {\n            if (matrix[newPosition.getXPos() + 1][newPosition.getYPos()]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private Boolean validateEastMovement(Position newPosition) {\n        if (matrix[newPosition.getXPos()][newPosition.getYPos()]) {\n            if (matrix[newPosition.getXPos()][newPosition.getYPos() + 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private Boolean validateSouthMovement(Position newPosition) {\n        if (matrix[newPosition.getXPos()][newPosition.getYPos() + 1]) {\n            if (matrix[newPosition.getXPos() + 1][newPosition.getYPos() + 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private Boolean validateWestMovement(Position newPosition) {\n        if (matrix[newPosition.getXPos() + 1][newPosition.getYPos()]) {\n            if (matrix[newPosition.getXPos() + 1][newPosition.getYPos() + 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public String MatrixToString() {\n        String output = \"\";\n        for (int j = yLen - 1; j >= 0; j--) {\n            for (int i = 0; i < xLen; i++) {\n                output += (matrix[i][j] ? \"1\" : \"0\");\n                if (i + 1 >= xLen) {\n                    output += \"\\n\";\n                }\n            }\n        }\n        return output;\n    }\n}\n"}, {"source": "student", "name": "student98", "file_name": "Moveable.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic interface Moveable {\n    String moveTo(String moveCommandString);\n}\n"}, {"source": "student", "name": "student98", "file_name": "MoveEast.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class MoveEast extends AbstractMove {\n\n    @Override\n    public Position moveUntilBlocked(Matrix Coordinates, Position startPosition, int stepLength) {\n        Position currentPosition = new Position(startPosition.getXPos(), startPosition.getYPos());\n\n        while (stepLength > 0) {\n            Position newPosition = new Position(currentPosition.getXPos() + 1, currentPosition.getYPos());\n\n            if (!validateStep(Coordinates, newPosition, Orientation.EA))\n                return currentPosition;\n\n            currentPosition.setXPos(newPosition.getXPos());\n            stepLength--;\n        }\n        return currentPosition;\n    }\n}\n"}, {"source": "student", "name": "student98", "file_name": "MoveNorth.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class MoveNorth extends AbstractMove {\n\n    @Override\n    public Position moveUntilBlocked(Matrix Coordinates, Position startPosition, int stepLength) {\n        Position currentPosition = new Position(startPosition.getXPos(), startPosition.getYPos());\n\n        while (stepLength > 0) {\n            Position newPosition = new Position(currentPosition.getXPos(), currentPosition.getYPos() + 1);\n\n            if (!validateStep(Coordinates, newPosition, Orientation.NO))\n                return currentPosition;\n\n            currentPosition.setYPos(newPosition.getYPos());\n            stepLength--;\n        }\n        return currentPosition;\n    }\n}\n"}, {"source": "student", "name": "student98", "file_name": "MoveSouth.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class MoveSouth extends AbstractMove {\n\n    @Override\n    public Position moveUntilBlocked(Matrix Coordinates, Position startPosition, int stepLength) {\n        Position currentPosition = new Position(startPosition.getXPos(), startPosition.getYPos());\n\n        while (stepLength > 0) {\n            Position newPosition = new Position(currentPosition.getXPos(), currentPosition.getYPos() - 1);\n\n            if (!validateStep(Coordinates, newPosition, Orientation.SO))\n                return currentPosition;\n\n            currentPosition.setYPos(newPosition.getYPos());\n            stepLength--;\n        }\n        return currentPosition;\n    }\n}\n"}, {"source": "student", "name": "student98", "file_name": "MoveWest.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic class MoveWest extends AbstractMove {\n\n    @Override\n    public Position moveUntilBlocked(Matrix Coordinates, Position startPosition, int stepLength) {\n        Position currentPosition = new Position(startPosition.getXPos(), startPosition.getYPos());\n\n        while (stepLength > 0) {\n            Position newPosition = new Position(currentPosition.getXPos() - 1, currentPosition.getYPos());\n\n            if (!validateStep(Coordinates, newPosition, Orientation.WE))\n                return currentPosition;\n\n            currentPosition.setXPos(newPosition.getXPos());\n            stepLength--;\n        }\n        return currentPosition;\n    }\n}\n"}, {"source": "student", "name": "student98", "file_name": "Orientation.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\npublic enum Orientation {\n    NO,\n    EA,\n    SO,\n    WE\n}\n"}, {"source": "student", "name": "student98", "file_name": "Position.java", "code": "package thkoeln.st.st2praktikum.exercise;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\nimport lombok.Setter;\n\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Position {\n    @Getter\n    @Setter\n    private int xPos;\n\n    @Getter\n    @Setter\n    private int yPos;\n\n    public String toString() {\n        return \"(\"+xPos+\",\"+yPos+\")\";\n    }\n}\n"}]